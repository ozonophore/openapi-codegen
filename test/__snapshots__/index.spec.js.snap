// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`v2 should generate: ./test/generated/v2/core/ApiError.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
import type { ApiResult } from './ApiResult';

export class ApiError extends Error {
    public readonly url: string;
    public readonly status: number;
    public readonly statusText: string;
    public readonly body: any;

    constructor(response: ApiResult, message: string) {
        super(message);

        this.url = response.url;
        this.status = response.status;
        this.statusText = response.statusText;
        this.body = response.body;
    }
}"
`;

exports[`v2 should generate: ./test/generated/v2/core/ApiRequestOptions.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
export type ApiRequestOptions = {
    readonly method: 'GET' | 'PUT' | 'POST' | 'DELETE' | 'OPTIONS' | 'HEAD' | 'PATCH';
    readonly path: string;
    readonly cookies?: Record<string, any>;
    readonly headers?: Record<string, any>;
    readonly query?: Record<string, any>;
    readonly formData?: Record<string, any>;
    readonly body?: any;
    readonly mediaType?: string;
    readonly responseHeader?: string;
    // TODO TS2344: Redesign the logic for generating errors. Use the string value of the error code.
    // @ts-ignore
    readonly errors?: Record<number, string>;
}"
`;

exports[`v2 should generate: ./test/generated/v2/core/ApiResult.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
export type ApiResult = {
    readonly url: string;
    readonly ok: boolean;
    readonly status: number;
    readonly statusText: string;
    readonly body: any;
}"
`;

exports[`v2 should generate: ./test/generated/v2/core/HttpStatusCode.ts 1`] = `
"export enum EHTTP_STATUS_CODES {
    BAD_REQUEST = 400,
    UNAUTHORIZED = 401,
    FORBIDDEN = 403,
    NOT_FOUND = 404,
    INTERNAL_SERVER_ERROR = 500,
    BAD_GATEWAY = 502,
    SERVICE_UNAVAILABLE = 503,
}

export enum EHTTP_STATUS_NAME {
    BAD_REQUEST = 'Bad Request',
    UNAUTHORIZED = 'Unauthorized',
    FORBIDDEN = 'Forbidden',
    NOT_FOUND = 'Not Found',
    INTERNAL_SERVER_ERROR = 'Internal Server Error',
    BAD_GATEWAY = 'Bad Gateway',
    SERVICE_UNAVAILABLE = 'Service Unavailable',
}"
`;

exports[`v2 should generate: ./test/generated/v2/core/OpenAPI.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
import type { ApiRequestOptions } from './ApiRequestOptions';

type Resolver<T> = (options: ApiRequestOptions) => Promise<T>;
type Headers = Record<string, string>;

export type OpenAPIConfig = {
    BASE: string;
    VERSION: string;
    WITH_CREDENTIALS: boolean;
    TOKEN?: string | Resolver<string>;
    USERNAME?: string | Resolver<string>;
    PASSWORD?: string | Resolver<string>;
    HEADERS?: Headers | Resolver<Headers>;
}

export const OpenAPI: OpenAPIConfig = {
    BASE: 'http://localhost:3000/base',
    VERSION: '1.0',
    WITH_CREDENTIALS: false,
    TOKEN: undefined,
    USERNAME: undefined,
    PASSWORD: undefined,
    HEADERS: undefined,
};"
`;

exports[`v2 should generate: ./test/generated/v2/core/request.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
import { ApiError } from './ApiError';
import type { ApiRequestOptions } from './ApiRequestOptions';
import type { ApiResult } from './ApiResult';
import { OpenAPI, OpenAPIConfig } from './OpenAPI';
import { EHTTP_STATUS_CODES, EHTTP_STATUS_NAME } from './HttpStatusCode';

function isDefined<T>(value: T | null | undefined): value is Exclude<T, null | undefined> {
    return value !== undefined && value !== null;
}

function isString(value: any): value is string {
    return typeof value === 'string';
}

function isStringWithValue(value: any): value is string {
    return isString(value) && value !== '';
}

function isBlob(value: any): value is Blob {
    return value instanceof Blob;
}

function getQueryString(params: Record<string, any>): string {
    const qs: string[] = [];
    Object.keys(params).forEach(key => {
        const value = params[key];
        if (isDefined(value)) {
            if (Array.isArray(value)) {
                value.forEach(value => {
                    qs.push(\`\${encodeURIComponent(key)}=\${encodeURIComponent(String(value))}\`);
                });
            } else {
                qs.push(\`\${encodeURIComponent(key)}=\${encodeURIComponent(String(value))}\`);
            }
        }
    });
    if (qs.length > 0) {
        return \`?\${qs.join('&')}\`;
    }
    return '';
}

function getUrl(config: OpenAPIConfig, options: ApiRequestOptions): string {
    const path = options.path
        .replace('{api-version}', config.VERSION)
        .replace(/[:]/g, '_');
    const url = \`\${config.BASE}\${path}\`;

    if (options.query) {
        return \`\${url}\${getQueryString(options.query)}\`;
    }
    return url;
}

function getFormData(params: Record<string, any>): FormData {
    const formData = new FormData();
    Object.keys(params).forEach(key => {
        const value = params[key];
        if (isDefined(value)) {
            formData.append(key, value);
        }
    });
    return formData;
}

type Resolver<T> = (options: ApiRequestOptions) => Promise<T>;

async function resolve<T>(options: ApiRequestOptions, resolver?: T | Resolver<T>): Promise<T | undefined> {
    if (typeof resolver === 'function') {
        return (resolver as Resolver<T>)(options);
    }
    return resolver;
}

async function getHeaders(config: OpenAPIConfig, options: ApiRequestOptions): Promise<Headers> {
    const token = await resolve(options, config.TOKEN);
    const username = await resolve(options, config.USERNAME);
    const password = await resolve(options, config.PASSWORD);
    const defaultHeaders = await resolve(options, config.HEADERS);

    const headers = new Headers({
        Accept: 'application/json',
        ...defaultHeaders,
        ...options.headers,
    });

    if (isStringWithValue(token)) {
        headers.append('Authorization', \`Bearer \${token}\`);
    }

    if (isStringWithValue(username) && isStringWithValue(password)) {
        const credentials = btoa(\`\${username}:\${password}\`);
        headers.append('Authorization', \`Basic \${credentials}\`);
    }

    if (options.body) {
        if (options.mediaType) {
            headers.append('Content-Type', options.mediaType);
        } else if (isBlob(options.body)) {
            headers.append('Content-Type', options.body.type || 'application/octet-stream');
        } else if (isString(options.body)) {
            headers.append('Content-Type', 'text/plain');
        } else {
            headers.append('Content-Type', 'application/json');
        }
    }
    return headers;
}

function getRequestBody(options: ApiRequestOptions): BodyInit | undefined {
    if (options.formData) {
        return getFormData(options.formData);
    }
    if (options.body) {
        if (options.mediaType?.includes('/json')) {
            return JSON.stringify(options.body)
        } else if (isString(options.body) || isBlob(options.body)) {
            return options.body;
        } else {
            return JSON.stringify(options.body);
        }
    }
    return undefined;
}

async function sendRequest(config: OpenAPIConfig, options: ApiRequestOptions, url: string): Promise<Response> {

    const request: RequestInit = {
        method: options.method,
        headers: await getHeaders(config, options),
        body: getRequestBody(options),
    };

    if (config.WITH_CREDENTIALS) {
        request.credentials = 'include';
    }


    return await fetch(url, request);
}

function getResponseHeader(response: Response, responseHeader?: string): string | null {
    if (responseHeader) {
        const content = response.headers.get(responseHeader);
        if (isString(content)) {
            return content;
        }
    }
    return null;
}

async function getResponseBody(response: Response): Promise<any> {
    try {
        const contentType = response.headers.get('Content-Type');
        if (contentType) {
            const isJSON = contentType.toLowerCase().startsWith('application/json');
            if (isJSON) {
                return await response.json();
            } else {
                return await response.text();
            }
        }
    } catch (error) {
        console.error(error);
    }
    return null;
}

function catchErrors(options: ApiRequestOptions, result: ApiResult): void {
    const errors: Record<string, string> = {
        [EHTTP_STATUS_CODES.BAD_GATEWAY]: EHTTP_STATUS_NAME.BAD_GATEWAY,
        [EHTTP_STATUS_CODES.BAD_REQUEST]: EHTTP_STATUS_NAME.BAD_REQUEST,
        [EHTTP_STATUS_CODES.FORBIDDEN]: EHTTP_STATUS_NAME.FORBIDDEN,
        [EHTTP_STATUS_CODES.INTERNAL_SERVER_ERROR]: EHTTP_STATUS_NAME.INTERNAL_SERVER_ERROR,
        [EHTTP_STATUS_CODES.NOT_FOUND]: EHTTP_STATUS_NAME.NOT_FOUND,
        [EHTTP_STATUS_CODES.SERVICE_UNAVAILABLE]: EHTTP_STATUS_NAME.SERVICE_UNAVAILABLE,
        [EHTTP_STATUS_CODES.UNAUTHORIZED]: EHTTP_STATUS_NAME.UNAUTHORIZED,
        ...options.errors,
    }

    const error = errors[result.status];
    if (error) {
        throw new ApiError(result, error);
    }

    if (!result.ok) {
        throw new ApiError(result, 'Generic Error');
    }
}

/**
 * Request using fetch client
 * @param config The OpenAPI configuration object
 * @param options The request options from the the service
 * @returns ApiResult
 * @throws ApiError
 */
export async function request<T>(config: OpenAPIConfig,options: ApiRequestOptions): Promise<T> {
    return new Promise(async (resolve, reject) => {
        try {
            const url = getUrl(config, options);
            const response = await sendRequest(config, options, url);
            const responseBody = await getResponseBody(response);
            const responseHeader = getResponseHeader(response, options.responseHeader);

            const result: ApiResult = {
                url,
                ok: response.ok,
                status: response.status,
                statusText: response.statusText,
                body: responseHeader || responseBody,
            };

            catchErrors(options, result);
            resolve(result.body);
        } catch (error) {
            reject(error);
        }
    });
}
"
`;

exports[`v2 should generate: ./test/generated/v2/index.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
export { ApiError } from '././core/ApiError';
export { OpenAPI } from '././core/OpenAPI';

export type { IDictionaryWithReference } from '././models/DictionaryWithReference';
export type { IModelWithArray } from '././models/ModelWithArray';
export type { IModelWithDictionary } from '././models/ModelWithDictionary';
export { IModelWithEnumInteger } from '././models/ModelWithEnumInteger';
export type { IModelWithString } from '././models/ModelWithString';
export type { TModelThatExtends } from '././models/ModelThatExtends';
export type { TModelThatExtendsExtends } from '././models/ModelThatExtendsExtends';

export { IDictionaryWithReferenceSchema } from '././schemas/DictionaryWithReferenceSchema';
export { IModelWithArraySchema } from '././schemas/ModelWithArraySchema';
export { IModelWithDictionarySchema } from '././schemas/ModelWithDictionarySchema';
export { IModelWithEnumIntegerSchema } from '././schemas/ModelWithEnumIntegerSchema';
export { IModelWithStringSchema } from '././schemas/ModelWithStringSchema';
export { TModelThatExtendsSchema } from '././schemas/ModelThatExtendsSchema';
export { TModelThatExtendsExtendsSchema } from '././schemas/ModelThatExtendsExtendsSchema';

export { Service } from '././services/Service';
export { SimpleService } from '././services/SimpleService';
export { ParametersService } from '././services/ParametersService';
export { DefaultsService } from '././services/DefaultsService';
export { DuplicateService } from '././services/DuplicateService';
export { NoContentService } from '././services/NoContentService';
export { ResponseService } from '././services/ResponseService';
export { CollectionFormatService } from '././services/CollectionFormatService';
export { TypesService } from '././services/TypesService';
export { ComplexService } from '././services/ComplexService';
export { HeaderService } from '././services/HeaderService';
"
`;

exports[`v2 should generate: ./test/generated/v2/models/DictionaryWithReference.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */

import type { IModelWithString } from './ModelWithString';

/**
 * This is a string reference
 */
export type IDictionaryWithReference = Record<string, IModelWithString>;"
`;

exports[`v2 should generate: ./test/generated/v2/models/ModelThatExtends.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */

import type { IModelWithString } from './ModelWithString';

/**
 * This is a model that extends another model
 */
export type TModelThatExtends = (IModelWithString & {
    propExtendsA?: string,
    propExtendsB?: IModelWithString,
});
"
`;

exports[`v2 should generate: ./test/generated/v2/models/ModelThatExtendsExtends.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */

import type { TModelThatExtends } from './ModelThatExtends';
import type { IModelWithString } from './ModelWithString';

/**
 * This is a model that extends another model
 */
export type TModelThatExtendsExtends = (IModelWithString & TModelThatExtends & {
    propExtendsC?: string,
    propExtendsD?: IModelWithString,
});
"
`;

exports[`v2 should generate: ./test/generated/v2/models/ModelWithArray.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */

import type { IModelWithString } from './ModelWithString';

/**
 * This is a model with one property containing an array
 */
export interface IModelWithArray {
    prop?: Array<IModelWithString>;
    propWithFile?: Array<Blob>;
    propWithNumber?: Array<number>;
}
"
`;

exports[`v2 should generate: ./test/generated/v2/models/ModelWithDictionary.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */

/**
 * This is a model with one property containing a dictionary
 */
export interface IModelWithDictionary {
    prop?: Record<string, string>;
}
"
`;

exports[`v2 should generate: ./test/generated/v2/models/ModelWithEnumInteger.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */

/**
 * This is a model with one number property
 */
export interface IModelWithEnumInteger {
    /**
     * VALUE_1=1,VALUE_2=2,VALUE_3=3
     */
    prop?: IModelWithEnumInteger.prop;
}

export namespace IModelWithEnumInteger {

    /**
     * VALUE_1=1,VALUE_2=2,VALUE_3=3
     */
    export enum prop {
        VALUE_1 = 1,
        VALUE_2 = 2,
        VALUE_3 = 3,
    }


}
"
`;

exports[`v2 should generate: ./test/generated/v2/models/ModelWithString.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */

/**
 * This is a model with one string property
 */
export interface IModelWithString {
    /**
     * This is a simple string property
     */
    prop?: string;
}
"
`;

exports[`v2 should generate: ./test/generated/v2/schemas/DictionaryWithReferenceSchema.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
export const IDictionaryWithReferenceSchema = {
    type: 'dictionary',
    contains: {
        type: 'IModelWithString',
    },
};"
`;

exports[`v2 should generate: ./test/generated/v2/schemas/ModelThatExtendsExtendsSchema.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
export const TModelThatExtendsExtendsSchema = {
    type: 'all-of',
    contains: [{
        type: 'IModelWithString',
    }, {
        type: 'TModelThatExtends',
    }, {
        properties: {
            propExtendsC: {
                type: 'string',
            },
            propExtendsD: {
                type: 'IModelWithString',
            },
        },
    }],
};"
`;

exports[`v2 should generate: ./test/generated/v2/schemas/ModelThatExtendsSchema.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
export const TModelThatExtendsSchema = {
    type: 'all-of',
    contains: [{
        type: 'IModelWithString',
    }, {
        properties: {
            propExtendsA: {
                type: 'string',
            },
            propExtendsB: {
                type: 'IModelWithString',
            },
        },
    }],
};"
`;

exports[`v2 should generate: ./test/generated/v2/schemas/ModelWithArraySchema.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
export const IModelWithArraySchema = {
    properties: {
        prop: {
            type: 'array',
            contains: {
                type: 'IModelWithString',
            },
        },
        propWithFile: {
            type: 'array',
            contains: {
                type: 'File',
            },
        },
        propWithNumber: {
            type: 'array',
            contains: {
                type: 'number',
            },
        },
    },
};"
`;

exports[`v2 should generate: ./test/generated/v2/schemas/ModelWithDictionarySchema.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
export const IModelWithDictionarySchema = {
    properties: {
        prop: {
            type: 'dictionary',
            contains: {
                type: 'string',
            },
        },
    },
};"
`;

exports[`v2 should generate: ./test/generated/v2/schemas/ModelWithEnumIntegerSchema.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
export const IModelWithEnumIntegerSchema = {
    properties: {
        prop: {
            type: 'Enum',
        },
    },
};"
`;

exports[`v2 should generate: ./test/generated/v2/schemas/ModelWithStringSchema.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
export const IModelWithStringSchema = {
    properties: {
        prop: {
            type: 'string',
        },
    },
};"
`;

exports[`v2 should generate: ./test/generated/v2/services/CollectionFormatService.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
import { request as __request } from './../core/request';
import type { ApiRequestOptions } from './../core/ApiRequestOptions';
import { OpenAPI } from './../core/OpenAPI';

const collectionFormat = (
    parameterArrayCsv: Array<string>,
    parameterArraySsv: Array<string>,
    parameterArrayTsv: Array<string>,
    parameterArrayPipes: Array<string>,
    parameterArrayMulti: Array<string>,
): ApiRequestOptions => ({
    method: 'GET',
    path: \`/api/v{api-version}/collectionFormat\`,
    query: {
        'parameterArrayCSV': parameterArrayCsv,
        'parameterArraySSV': parameterArraySsv,
        'parameterArrayTSV': parameterArrayTsv,
        'parameterArrayPipes': parameterArrayPipes,
        'parameterArrayMulti': parameterArrayMulti,
    },
});


export type TCollectionFormatServiceOptions = {
    collectionFormat: (
        parameterArrayCsv: Array<string>,
        parameterArraySsv: Array<string>,
        parameterArrayTsv: Array<string>,
        parameterArrayPipes: Array<string>,
        parameterArrayMulti: Array<string>,
    ) => ApiRequestOptions;
}

export const CollectionFormatServiceOptions: TCollectionFormatServiceOptions = {
    collectionFormat: collectionFormat,
}

export class CollectionFormatService {

    /**
     * @param parameterArrayCsv This is an array parameter that is send as csv format (comma-separated values)
     * @param parameterArraySsv This is an array parameter that is send as ssv format (space-separated values)
     * @param parameterArrayTsv This is an array parameter that is send as tsv format (tab-separated values)
     * @param parameterArrayPipes This is an array parameter that is send as pipes format (pipe-separated values)
     * @param parameterArrayMulti This is an array parameter that is send as multi format (multiple parameter instances)
     * @throws ApiError
     */
    public static collectionFormat(
        parameterArrayCsv: Array<string>,
        parameterArraySsv: Array<string>,
        parameterArrayTsv: Array<string>,
        parameterArrayPipes: Array<string>,
        parameterArrayMulti: Array<string>,
    ): Promise<void> {
        return __request<void>(OpenAPI, CollectionFormatServiceOptions.collectionFormat(
            parameterArrayCsv,
            parameterArraySsv,
            parameterArrayTsv,
            parameterArrayPipes,
            parameterArrayMulti,
        ));
    }
}"
`;

exports[`v2 should generate: ./test/generated/v2/services/ComplexService.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
import type { IModelWithString } from './../models/ModelWithString';
import { request as __request } from './../core/request';
import type { ApiRequestOptions } from './../core/ApiRequestOptions';
import { OpenAPI } from './../core/OpenAPI';

const complexTypes = (
    parameterObject: {
        first?: {
            second?: {
                third?: string,
            },
        },
    },
    parameterReference: IModelWithString,
): ApiRequestOptions => ({
    method: 'GET',
    path: \`/api/v{api-version}/complex\`,
    query: {
        'parameterObject': parameterObject,
        'parameterReference': parameterReference,
    },
    errors: {
        400: \`400 server error\`,
        500: \`500 server error\`,
    },
});


export type TComplexServiceOptions = {
    complexTypes: (
        parameterObject: {
            first?: {
                second?: {
                    third?: string,
                },
            },
        },
        parameterReference: IModelWithString,
    ) => ApiRequestOptions;
}

export const ComplexServiceOptions: TComplexServiceOptions = {
    complexTypes: complexTypes,
}

export class ComplexService {

    /**
     * @param parameterObject Parameter containing object
     * @param parameterReference Parameter containing reference
     * @returns IModelWithString Successful response
     * @throws ApiError
     */
    public static complexTypes(
        parameterObject: {
            first?: {
                second?: {
                    third?: string,
                },
            },
        },
        parameterReference: IModelWithString,
    ): Promise<Array<IModelWithString>> {
        return __request<Array<IModelWithString>>(OpenAPI, ComplexServiceOptions.complexTypes(
            parameterObject,
            parameterReference,
        ));
    }
}"
`;

exports[`v2 should generate: ./test/generated/v2/services/DefaultsService.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
import type { IModelWithString } from './../models/ModelWithString';
import { request as __request } from './../core/request';
import type { ApiRequestOptions } from './../core/ApiRequestOptions';
import { OpenAPI } from './../core/OpenAPI';

const callWithDefaultParameters = (
    parameterString: string = 'Hello World!',
    parameterNumber: number = 123,
    parameterBoolean: boolean = true,
    parameterEnum: 'Success' | 'Warning' | 'Error' = 'Success',
    parameterModel: IModelWithString = {
        \\"prop\\": \\"Hello World!\\"
    },
): ApiRequestOptions => ({
    method: 'GET',
    path: \`/api/v{api-version}/defaults\`,
    query: {
        'parameterString': parameterString,
        'parameterNumber': parameterNumber,
        'parameterBoolean': parameterBoolean,
        'parameterEnum': parameterEnum,
        'parameterModel': parameterModel,
    },
});

const callWithDefaultOptionalParameters = (
    parameterString: string = 'Hello World!',
    parameterNumber: number = 123,
    parameterBoolean: boolean = true,
    parameterEnum: 'Success' | 'Warning' | 'Error' = 'Success',
    parameterModel: IModelWithString = {
        \\"prop\\": \\"Hello World!\\"
    },
): ApiRequestOptions => ({
    method: 'POST',
    path: \`/api/v{api-version}/defaults\`,
    query: {
        'parameterString': parameterString,
        'parameterNumber': parameterNumber,
        'parameterBoolean': parameterBoolean,
        'parameterEnum': parameterEnum,
        'parameterModel': parameterModel,
    },
});

const callToTestOrderOfParams = (
    parameterStringWithNoDefault: string,
    parameterStringWithDefault: string = 'Hello World!',
    parameterStringWithEmptyDefault: string = '',
    parameterOptionalStringWithDefault: string = 'Hello World!',
    parameterOptionalStringWithEmptyDefault: string = '',
    parameterOptionalStringWithNoDefault?: string,
): ApiRequestOptions => ({
    method: 'PUT',
    path: \`/api/v{api-version}/defaults\`,
    query: {
        'parameterStringWithNoDefault': parameterStringWithNoDefault,
        'parameterStringWithDefault': parameterStringWithDefault,
        'parameterStringWithEmptyDefault': parameterStringWithEmptyDefault,
        'parameterOptionalStringWithDefault': parameterOptionalStringWithDefault,
        'parameterOptionalStringWithEmptyDefault': parameterOptionalStringWithEmptyDefault,
        'parameterOptionalStringWithNoDefault': parameterOptionalStringWithNoDefault,
    },
});


export type TDefaultsServiceOptions = {
    callWithDefaultParameters: (
        parameterString: string,
        parameterNumber: number,
        parameterBoolean: boolean,
        parameterEnum: 'Success' | 'Warning' | 'Error',
        parameterModel: IModelWithString,
    ) => ApiRequestOptions;
    callWithDefaultOptionalParameters: (
        parameterString: string,
        parameterNumber: number,
        parameterBoolean: boolean,
        parameterEnum: 'Success' | 'Warning' | 'Error',
        parameterModel: IModelWithString,
    ) => ApiRequestOptions;
    callToTestOrderOfParams: (
        parameterStringWithNoDefault: string,
        parameterStringWithDefault: string,
        parameterStringWithEmptyDefault: string,
        parameterOptionalStringWithDefault: string,
        parameterOptionalStringWithEmptyDefault: string,
        parameterOptionalStringWithNoDefault?: string,
    ) => ApiRequestOptions;
}

export const DefaultsServiceOptions: TDefaultsServiceOptions = {
    callWithDefaultParameters: callWithDefaultParameters,
    callWithDefaultOptionalParameters: callWithDefaultOptionalParameters,
    callToTestOrderOfParams: callToTestOrderOfParams,
}

export class DefaultsService {

    /**
     * @param parameterString This is a simple string with default value
     * @param parameterNumber This is a simple number with default value
     * @param parameterBoolean This is a simple boolean with default value
     * @param parameterEnum This is a simple enum with default value
     * @param parameterModel This is a simple model with default value
     * @throws ApiError
     */
    public static callWithDefaultParameters(
        parameterString: string = 'Hello World!',
        parameterNumber: number = 123,
        parameterBoolean: boolean = true,
        parameterEnum: 'Success' | 'Warning' | 'Error' = 'Success',
        parameterModel: IModelWithString = {
            \\"prop\\": \\"Hello World!\\"
        },
    ): Promise<void> {
        return __request<void>(OpenAPI, DefaultsServiceOptions.callWithDefaultParameters(
            parameterString,
            parameterNumber,
            parameterBoolean,
            parameterEnum,
            parameterModel,
        ));
    }
    /**
     * @param parameterString This is a simple string that is optional with default value
     * @param parameterNumber This is a simple number that is optional with default value
     * @param parameterBoolean This is a simple boolean that is optional with default value
     * @param parameterEnum This is a simple enum that is optional with default value
     * @param parameterModel This is a simple model that is optional with default value
     * @throws ApiError
     */
    public static callWithDefaultOptionalParameters(
        parameterString: string = 'Hello World!',
        parameterNumber: number = 123,
        parameterBoolean: boolean = true,
        parameterEnum: 'Success' | 'Warning' | 'Error' = 'Success',
        parameterModel: IModelWithString = {
            \\"prop\\": \\"Hello World!\\"
        },
    ): Promise<void> {
        return __request<void>(OpenAPI, DefaultsServiceOptions.callWithDefaultOptionalParameters(
            parameterString,
            parameterNumber,
            parameterBoolean,
            parameterEnum,
            parameterModel,
        ));
    }
    /**
     * @param parameterStringWithNoDefault This is a string with no default
     * @param parameterStringWithDefault This is a string with default
     * @param parameterStringWithEmptyDefault This is a string with empty default
     * @param parameterOptionalStringWithDefault This is a optional string with default
     * @param parameterOptionalStringWithEmptyDefault This is a optional string with empty default
     * @param parameterOptionalStringWithNoDefault This is a optional string with no default
     * @throws ApiError
     */
    public static callToTestOrderOfParams(
        parameterStringWithNoDefault: string,
        parameterStringWithDefault: string = 'Hello World!',
        parameterStringWithEmptyDefault: string = '',
        parameterOptionalStringWithDefault: string = 'Hello World!',
        parameterOptionalStringWithEmptyDefault: string = '',
        parameterOptionalStringWithNoDefault?: string,
    ): Promise<void> {
        return __request<void>(OpenAPI, DefaultsServiceOptions.callToTestOrderOfParams(
            parameterStringWithNoDefault,
            parameterStringWithDefault,
            parameterStringWithEmptyDefault,
            parameterOptionalStringWithDefault,
            parameterOptionalStringWithEmptyDefault,
            parameterOptionalStringWithNoDefault,
        ));
    }
}"
`;

exports[`v2 should generate: ./test/generated/v2/services/DuplicateService.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
import { request as __request } from './../core/request';
import type { ApiRequestOptions } from './../core/ApiRequestOptions';
import { OpenAPI } from './../core/OpenAPI';

const duplicateName = (): ApiRequestOptions => ({
    method: 'GET',
    path: \`/api/v{api-version}/duplicate\`,
});

const duplicateName1 = (): ApiRequestOptions => ({
    method: 'POST',
    path: \`/api/v{api-version}/duplicate\`,
});

const duplicateName2 = (): ApiRequestOptions => ({
    method: 'PUT',
    path: \`/api/v{api-version}/duplicate\`,
});

const duplicateName3 = (): ApiRequestOptions => ({
    method: 'DELETE',
    path: \`/api/v{api-version}/duplicate\`,
});


export type TDuplicateServiceOptions = {
    duplicateName: () => ApiRequestOptions;
    duplicateName1: () => ApiRequestOptions;
    duplicateName2: () => ApiRequestOptions;
    duplicateName3: () => ApiRequestOptions;
}

export const DuplicateServiceOptions: TDuplicateServiceOptions = {
    duplicateName: duplicateName,
    duplicateName1: duplicateName1,
    duplicateName2: duplicateName2,
    duplicateName3: duplicateName3,
}

export class DuplicateService {

    /**
     * @throws ApiError
     */
    public static duplicateName(): Promise<void> {
        return __request<void>(OpenAPI, DuplicateServiceOptions.duplicateName());
    }
    /**
     * @throws ApiError
     */
    public static duplicateName1(): Promise<void> {
        return __request<void>(OpenAPI, DuplicateServiceOptions.duplicateName1());
    }
    /**
     * @throws ApiError
     */
    public static duplicateName2(): Promise<void> {
        return __request<void>(OpenAPI, DuplicateServiceOptions.duplicateName2());
    }
    /**
     * @throws ApiError
     */
    public static duplicateName3(): Promise<void> {
        return __request<void>(OpenAPI, DuplicateServiceOptions.duplicateName3());
    }
}"
`;

exports[`v2 should generate: ./test/generated/v2/services/HeaderService.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
import { request as __request } from './../core/request';
import type { ApiRequestOptions } from './../core/ApiRequestOptions';
import { OpenAPI } from './../core/OpenAPI';

const callWithResultFromHeader = (): ApiRequestOptions => ({
    method: 'POST',
    path: \`/api/v{api-version}/header\`,
    responseHeader: 'operation-location',
    errors: {
        400: \`400 server error\`,
        500: \`500 server error\`,
    },
});


export type THeaderServiceOptions = {
    callWithResultFromHeader: () => ApiRequestOptions;
}

export const HeaderServiceOptions: THeaderServiceOptions = {
    callWithResultFromHeader: callWithResultFromHeader,
}

export class HeaderService {

    /**
     * @returns string Successful response
     * @throws ApiError
     */
    public static callWithResultFromHeader(): Promise<string> {
        return __request<string>(OpenAPI, HeaderServiceOptions.callWithResultFromHeader());
    }
}"
`;

exports[`v2 should generate: ./test/generated/v2/services/NoContentService.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
import { request as __request } from './../core/request';
import type { ApiRequestOptions } from './../core/ApiRequestOptions';
import { OpenAPI } from './../core/OpenAPI';

const callWithNoContentResponse = (): ApiRequestOptions => ({
    method: 'GET',
    path: \`/api/v{api-version}/no-content\`,
});


export type TNoContentServiceOptions = {
    callWithNoContentResponse: () => ApiRequestOptions;
}

export const NoContentServiceOptions: TNoContentServiceOptions = {
    callWithNoContentResponse: callWithNoContentResponse,
}

export class NoContentService {

    /**
     * @returns void
     * @throws ApiError
     */
    public static callWithNoContentResponse(): Promise<void> {
        return __request<void>(OpenAPI, NoContentServiceOptions.callWithNoContentResponse());
    }
}"
`;

exports[`v2 should generate: ./test/generated/v2/services/ParametersService.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
import { request as __request } from './../core/request';
import type { ApiRequestOptions } from './../core/ApiRequestOptions';
import { OpenAPI } from './../core/OpenAPI';

const callWithParameters = (
    parameterHeader: string,
    parameterQuery: string,
    parameterForm: string,
    parameterBody: string,
    parameterPath: string,
): ApiRequestOptions => ({
    method: 'GET',
    path: \`/api/v{api-version}/parameters/\${parameterPath}\`,
    headers: {
        'parameterHeader': parameterHeader,
    },
    query: {
        'parameterQuery': parameterQuery,
    },
    formData: {
        'parameterForm': parameterForm,
    },
    body: parameterBody,
});

const callWithWeirdParameterNames = (
    parameterHeader: string,
    parameterQuery: string,
    parameterForm: string,
    parameterBody: string,
    parameterPath1?: string,
    parameterPath2?: string,
    parameterPath3?: string,
    _default?: string,
): ApiRequestOptions => ({
    method: 'GET',
    path: \`/api/v{api-version}/parameters/\${parameterPath1}/\${parameterPath2}/\${parameterPath3}\`,
    headers: {
        'parameter.header': parameterHeader,
    },
    query: {
        'parameter-query': parameterQuery,
        'default': _default,
    },
    formData: {
        'parameter_form': parameterForm,
    },
    body: parameterBody,
});


export type TParametersServiceOptions = {
    callWithParameters: (
        parameterHeader: string,
        parameterQuery: string,
        parameterForm: string,
        parameterBody: string,
        parameterPath: string,
    ) => ApiRequestOptions;
    callWithWeirdParameterNames: (
        parameterHeader: string,
        parameterQuery: string,
        parameterForm: string,
        parameterBody: string,
        parameterPath1?: string,
        parameterPath2?: string,
        parameterPath3?: string,
        _default?: string,
    ) => ApiRequestOptions;
}

export const ParametersServiceOptions: TParametersServiceOptions = {
    callWithParameters: callWithParameters,
    callWithWeirdParameterNames: callWithWeirdParameterNames,
}

export class ParametersService {

    /**
     * @param parameterHeader This is the parameter that goes into the header
     * @param parameterQuery This is the parameter that goes into the query params
     * @param parameterForm This is the parameter that goes into the form data
     * @param parameterBody This is the parameter that is send as request body
     * @param parameterPath This is the parameter that goes into the path
     * @throws ApiError
     */
    public static callWithParameters(
        parameterHeader: string,
        parameterQuery: string,
        parameterForm: string,
        parameterBody: string,
        parameterPath: string,
    ): Promise<void> {
        return __request<void>(OpenAPI, ParametersServiceOptions.callWithParameters(
            parameterHeader,
            parameterQuery,
            parameterForm,
            parameterBody,
            parameterPath,
        ));
    }
    /**
     * @param parameterHeader This is the parameter that goes into the request header
     * @param parameterQuery This is the parameter that goes into the request query params
     * @param parameterForm This is the parameter that goes into the request form data
     * @param parameterBody This is the parameter that is send as request body
     * @param parameterPath1 This is the parameter that goes into the path
     * @param parameterPath2 This is the parameter that goes into the path
     * @param parameterPath3 This is the parameter that goes into the path
     * @param _default This is the parameter with a reserved keyword
     * @throws ApiError
     */
    public static callWithWeirdParameterNames(
        parameterHeader: string,
        parameterQuery: string,
        parameterForm: string,
        parameterBody: string,
        parameterPath1?: string,
        parameterPath2?: string,
        parameterPath3?: string,
        _default?: string,
    ): Promise<void> {
        return __request<void>(OpenAPI, ParametersServiceOptions.callWithWeirdParameterNames(
            parameterHeader,
            parameterQuery,
            parameterForm,
            parameterBody,
            parameterPath1,
            parameterPath2,
            parameterPath3,
            _default,
        ));
    }
}"
`;

exports[`v2 should generate: ./test/generated/v2/services/ResponseService.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
import type { TModelThatExtendsExtends } from './../models/ModelThatExtendsExtends';
import type { TModelThatExtends } from './../models/ModelThatExtends';
import type { IModelWithString } from './../models/ModelWithString';
import { request as __request } from './../core/request';
import type { ApiRequestOptions } from './../core/ApiRequestOptions';
import { OpenAPI } from './../core/OpenAPI';

const callWithResponse = (): ApiRequestOptions => ({
    method: 'GET',
    path: \`/api/v{api-version}/response\`,
});

const callWithDuplicateResponses = (): ApiRequestOptions => ({
    method: 'POST',
    path: \`/api/v{api-version}/response\`,
    errors: {
        500: \`Message for 500 error\`,
        501: \`Message for 501 error\`,
        502: \`Message for 502 error\`,
    },
});

const callWithResponses = (): ApiRequestOptions => ({
    method: 'PUT',
    path: \`/api/v{api-version}/response\`,
    errors: {
        500: \`Message for 500 error\`,
        501: \`Message for 501 error\`,
        502: \`Message for 502 error\`,
    },
});


export type TResponseServiceOptions = {
    callWithResponse: () => ApiRequestOptions;
    callWithDuplicateResponses: () => ApiRequestOptions;
    callWithResponses: () => ApiRequestOptions;
}

export const ResponseServiceOptions: TResponseServiceOptions = {
    callWithResponse: callWithResponse,
    callWithDuplicateResponses: callWithDuplicateResponses,
    callWithResponses: callWithResponses,
}

export class ResponseService {

    /**
     * @returns IModelWithString Message for default response
     * @throws ApiError
     */
    public static callWithResponse(): Promise<IModelWithString> {
        return __request<IModelWithString>(OpenAPI, ResponseServiceOptions.callWithResponse());
    }
    /**
     * @returns IModelWithString Message for default response
     * @throws ApiError
     */
    public static callWithDuplicateResponses(): Promise<IModelWithString> {
        return __request<IModelWithString>(OpenAPI, ResponseServiceOptions.callWithDuplicateResponses());
    }
    /**
     * @returns any Message for 200 response
     * @returns IModelWithString Message for default response
     * @returns TModelThatExtends Message for 201 response
     * @returns TModelThatExtendsExtends Message for 202 response
     * @throws ApiError
     */
    public static callWithResponses(): Promise<{
        readonly '@namespace.string'?: string,
        readonly '@namespace.integer'?: number,
        readonly value?: Array<IModelWithString>,
    } | IModelWithString | TModelThatExtends | TModelThatExtendsExtends> {
        return __request<{
            readonly '@namespace.string'?: string,
            readonly '@namespace.integer'?: number,
            readonly value?: Array<IModelWithString>,
        } | IModelWithString | TModelThatExtends | TModelThatExtendsExtends>(OpenAPI, ResponseServiceOptions.callWithResponses());
    }
}"
`;

exports[`v2 should generate: ./test/generated/v2/services/Service.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
import type { IDictionaryWithReference } from './../models/DictionaryWithReference';
import type { IModelWithArray } from './../models/ModelWithArray';
import type { IModelWithDictionary } from './../models/ModelWithDictionary';
import type { IModelWithEnumInteger } from './../models/ModelWithEnumInteger';
import { request as __request } from './../core/request';
import type { ApiRequestOptions } from './../core/ApiRequestOptions';
import { OpenAPI } from './../core/OpenAPI';

const getCallWithModelWithDictionaryReference = (): ApiRequestOptions => ({
    method: 'GET',
    path: \`/api/v{api-version}/getModelWithDictionaryReference\`,
});

const getCallWithModelWithDictionary = (): ApiRequestOptions => ({
    method: 'GET',
    path: \`/api/v{api-version}/getModelWithDictionary\`,
});

const getCallWithSimpleInteger = (): ApiRequestOptions => ({
    method: 'GET',
    path: \`/api/v{api-version}/simpleEnum\`,
});

const getCallWithModelArray = (): ApiRequestOptions => ({
    method: 'GET',
    path: \`/api/v{api-version}/getModelWithArray\`,
});


export type TServiceOptions = {
    getCallWithModelWithDictionaryReference: () => ApiRequestOptions;
    getCallWithModelWithDictionary: () => ApiRequestOptions;
    getCallWithSimpleInteger: () => ApiRequestOptions;
    getCallWithModelArray: () => ApiRequestOptions;
}

export const ServiceOptions: TServiceOptions = {
    getCallWithModelWithDictionaryReference: getCallWithModelWithDictionaryReference,
    getCallWithModelWithDictionary: getCallWithModelWithDictionary,
    getCallWithSimpleInteger: getCallWithSimpleInteger,
    getCallWithModelArray: getCallWithModelArray,
}

export class Service {

    /**
     * @returns IDictionaryWithReference Message for default response
     * @throws ApiError
     */
    public static getCallWithModelWithDictionaryReference(): Promise<IDictionaryWithReference> {
        return __request<IDictionaryWithReference>(OpenAPI, ServiceOptions.getCallWithModelWithDictionaryReference());
    }
    /**
     * @returns IModelWithDictionary Message for default response
     * @throws ApiError
     */
    public static getCallWithModelWithDictionary(): Promise<IModelWithDictionary> {
        return __request<IModelWithDictionary>(OpenAPI, ServiceOptions.getCallWithModelWithDictionary());
    }
    /**
     * @returns IModelWithEnumInteger Message for default response
     * @throws ApiError
     */
    public static getCallWithSimpleInteger(): Promise<IModelWithEnumInteger> {
        return __request<IModelWithEnumInteger>(OpenAPI, ServiceOptions.getCallWithSimpleInteger());
    }
    /**
     * @returns IModelWithArray Message for default response
     * @throws ApiError
     */
    public static getCallWithModelArray(): Promise<IModelWithArray> {
        return __request<IModelWithArray>(OpenAPI, ServiceOptions.getCallWithModelArray());
    }
}"
`;

exports[`v2 should generate: ./test/generated/v2/services/SimpleService.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
import { request as __request } from './../core/request';
import type { ApiRequestOptions } from './../core/ApiRequestOptions';
import { OpenAPI } from './../core/OpenAPI';

const getCallWithoutParametersAndResponse = (): ApiRequestOptions => ({
    method: 'GET',
    path: \`/api/v{api-version}/simple\`,
});

const putCallWithoutParametersAndResponse = (): ApiRequestOptions => ({
    method: 'PUT',
    path: \`/api/v{api-version}/simple\`,
});

const postCallWithoutParametersAndResponse = (): ApiRequestOptions => ({
    method: 'POST',
    path: \`/api/v{api-version}/simple\`,
});

const deleteCallWithoutParametersAndResponse = (): ApiRequestOptions => ({
    method: 'DELETE',
    path: \`/api/v{api-version}/simple\`,
});

const optionsCallWithoutParametersAndResponse = (): ApiRequestOptions => ({
    method: 'OPTIONS',
    path: \`/api/v{api-version}/simple\`,
});

const headCallWithoutParametersAndResponse = (): ApiRequestOptions => ({
    method: 'HEAD',
    path: \`/api/v{api-version}/simple\`,
});

const patchCallWithoutParametersAndResponse = (): ApiRequestOptions => ({
    method: 'PATCH',
    path: \`/api/v{api-version}/simple\`,
});


export type TSimpleServiceOptions = {
    getCallWithoutParametersAndResponse: () => ApiRequestOptions;
    putCallWithoutParametersAndResponse: () => ApiRequestOptions;
    postCallWithoutParametersAndResponse: () => ApiRequestOptions;
    deleteCallWithoutParametersAndResponse: () => ApiRequestOptions;
    optionsCallWithoutParametersAndResponse: () => ApiRequestOptions;
    headCallWithoutParametersAndResponse: () => ApiRequestOptions;
    patchCallWithoutParametersAndResponse: () => ApiRequestOptions;
}

export const SimpleServiceOptions: TSimpleServiceOptions = {
    getCallWithoutParametersAndResponse: getCallWithoutParametersAndResponse,
    putCallWithoutParametersAndResponse: putCallWithoutParametersAndResponse,
    postCallWithoutParametersAndResponse: postCallWithoutParametersAndResponse,
    deleteCallWithoutParametersAndResponse: deleteCallWithoutParametersAndResponse,
    optionsCallWithoutParametersAndResponse: optionsCallWithoutParametersAndResponse,
    headCallWithoutParametersAndResponse: headCallWithoutParametersAndResponse,
    patchCallWithoutParametersAndResponse: patchCallWithoutParametersAndResponse,
}

export class SimpleService {

    /**
     * @throws ApiError
     */
    public static getCallWithoutParametersAndResponse(): Promise<void> {
        return __request<void>(OpenAPI, SimpleServiceOptions.getCallWithoutParametersAndResponse());
    }
    /**
     * @throws ApiError
     */
    public static putCallWithoutParametersAndResponse(): Promise<void> {
        return __request<void>(OpenAPI, SimpleServiceOptions.putCallWithoutParametersAndResponse());
    }
    /**
     * @throws ApiError
     */
    public static postCallWithoutParametersAndResponse(): Promise<void> {
        return __request<void>(OpenAPI, SimpleServiceOptions.postCallWithoutParametersAndResponse());
    }
    /**
     * @throws ApiError
     */
    public static deleteCallWithoutParametersAndResponse(): Promise<void> {
        return __request<void>(OpenAPI, SimpleServiceOptions.deleteCallWithoutParametersAndResponse());
    }
    /**
     * @throws ApiError
     */
    public static optionsCallWithoutParametersAndResponse(): Promise<void> {
        return __request<void>(OpenAPI, SimpleServiceOptions.optionsCallWithoutParametersAndResponse());
    }
    /**
     * @throws ApiError
     */
    public static headCallWithoutParametersAndResponse(): Promise<void> {
        return __request<void>(OpenAPI, SimpleServiceOptions.headCallWithoutParametersAndResponse());
    }
    /**
     * @throws ApiError
     */
    public static patchCallWithoutParametersAndResponse(): Promise<void> {
        return __request<void>(OpenAPI, SimpleServiceOptions.patchCallWithoutParametersAndResponse());
    }
}"
`;

exports[`v2 should generate: ./test/generated/v2/services/TypesService.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
import { request as __request } from './../core/request';
import type { ApiRequestOptions } from './../core/ApiRequestOptions';
import { OpenAPI } from './../core/OpenAPI';

const types = (
    parameterArray: Array<string>,
    parameterDictionary: Record<string, string>,
    parameterEnum: 'Success' | 'Warning' | 'Error',
    parameterNumber: number = 123,
    parameterString: string = 'default',
    parameterBoolean: boolean = true,
    parameterObject: any = null,
    id?: number,
): ApiRequestOptions => ({
    method: 'GET',
    path: \`/api/v{api-version}/types\`,
    query: {
        'parameterArray': parameterArray,
        'parameterDictionary': parameterDictionary,
        'parameterEnum': parameterEnum,
        'parameterNumber': parameterNumber,
        'parameterString': parameterString,
        'parameterBoolean': parameterBoolean,
        'parameterObject': parameterObject,
    },
});


export type TTypesServiceOptions = {
    types: (
        parameterArray: Array<string>,
        parameterDictionary: Record<string, string>,
        parameterEnum: 'Success' | 'Warning' | 'Error',
        parameterNumber: number,
        parameterString: string,
        parameterBoolean: boolean,
        parameterObject: any,
        id?: number,
    ) => ApiRequestOptions;
}

export const TypesServiceOptions: TTypesServiceOptions = {
    types: types,
}

export class TypesService {

    /**
     * @param parameterArray This is an array parameter
     * @param parameterDictionary This is a dictionary parameter
     * @param parameterEnum This is an enum parameter
     * @param parameterNumber This is a number parameter
     * @param parameterString This is a string parameter
     * @param parameterBoolean This is a boolean parameter
     * @param parameterObject This is an object parameter
     * @param id This is a number parameter
     * @returns number Response is a simple number
     * @returns string Response is a simple string
     * @returns boolean Response is a simple boolean
     * @returns any Response is a simple object
     * @throws ApiError
     */
    public static types(
        parameterArray: Array<string>,
        parameterDictionary: Record<string, string>,
        parameterEnum: 'Success' | 'Warning' | 'Error',
        parameterNumber: number = 123,
        parameterString: string = 'default',
        parameterBoolean: boolean = true,
        parameterObject: any = null,
        id?: number,
    ): Promise<number | string | boolean | any> {
        return __request<number | string | boolean | any>(OpenAPI, TypesServiceOptions.types(
            parameterArray,
            parameterDictionary,
            parameterEnum,
            parameterNumber,
            parameterString,
            parameterBoolean,
            parameterObject,
            id,
        ));
    }
}"
`;

exports[`v3 should generate from different files: ./test/generated/v3_1/core/ApiError.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
import type { ApiResult } from './ApiResult';

export class ApiError extends Error {
    public readonly url: string;
    public readonly status: number;
    public readonly statusText: string;
    public readonly body: any;

    constructor(response: ApiResult, message: string) {
        super(message);

        this.url = response.url;
        this.status = response.status;
        this.statusText = response.statusText;
        this.body = response.body;
    }
}"
`;

exports[`v3 should generate from different files: ./test/generated/v3_1/core/ApiRequestOptions.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
export type ApiRequestOptions = {
    readonly method: 'GET' | 'PUT' | 'POST' | 'DELETE' | 'OPTIONS' | 'HEAD' | 'PATCH';
    readonly path: string;
    readonly cookies?: Record<string, any>;
    readonly headers?: Record<string, any>;
    readonly query?: Record<string, any>;
    readonly formData?: Record<string, any>;
    readonly body?: any;
    readonly mediaType?: string;
    readonly responseHeader?: string;
    // TODO TS2344: Redesign the logic for generating errors. Use the string value of the error code.
    // @ts-ignore
    readonly errors?: Record<number, string>;
}"
`;

exports[`v3 should generate from different files: ./test/generated/v3_1/core/ApiResult.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
export type ApiResult = {
    readonly url: string;
    readonly ok: boolean;
    readonly status: number;
    readonly statusText: string;
    readonly body: any;
}"
`;

exports[`v3 should generate from different files: ./test/generated/v3_1/core/HttpStatusCode.ts 1`] = `
"export enum EHTTP_STATUS_CODES {
    BAD_REQUEST = 400,
    UNAUTHORIZED = 401,
    FORBIDDEN = 403,
    NOT_FOUND = 404,
    INTERNAL_SERVER_ERROR = 500,
    BAD_GATEWAY = 502,
    SERVICE_UNAVAILABLE = 503,
}

export enum EHTTP_STATUS_NAME {
    BAD_REQUEST = 'Bad Request',
    UNAUTHORIZED = 'Unauthorized',
    FORBIDDEN = 'Forbidden',
    NOT_FOUND = 'Not Found',
    INTERNAL_SERVER_ERROR = 'Internal Server Error',
    BAD_GATEWAY = 'Bad Gateway',
    SERVICE_UNAVAILABLE = 'Service Unavailable',
}"
`;

exports[`v3 should generate from different files: ./test/generated/v3_1/core/OpenAPI.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
import type { ApiRequestOptions } from './ApiRequestOptions';

type Resolver<T> = (options: ApiRequestOptions) => Promise<T>;
type Headers = Record<string, string>;

export type OpenAPIConfig = {
    BASE: string;
    VERSION: string;
    WITH_CREDENTIALS: boolean;
    TOKEN?: string | Resolver<string>;
    USERNAME?: string | Resolver<string>;
    PASSWORD?: string | Resolver<string>;
    HEADERS?: Headers | Resolver<Headers>;
}

export const OpenAPI: OpenAPIConfig = {
    BASE: 'http://localhost:3000/base',
    VERSION: '1.0',
    WITH_CREDENTIALS: false,
    TOKEN: undefined,
    USERNAME: undefined,
    PASSWORD: undefined,
    HEADERS: undefined,
};"
`;

exports[`v3 should generate from different files: ./test/generated/v3_1/core/request.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
import { ApiError } from './ApiError';
import type { ApiRequestOptions } from './ApiRequestOptions';
import type { ApiResult } from './ApiResult';
import { OpenAPI, OpenAPIConfig } from './OpenAPI';
import { EHTTP_STATUS_CODES, EHTTP_STATUS_NAME } from './HttpStatusCode';

function isDefined<T>(value: T | null | undefined): value is Exclude<T, null | undefined> {
    return value !== undefined && value !== null;
}

function isString(value: any): value is string {
    return typeof value === 'string';
}

function isStringWithValue(value: any): value is string {
    return isString(value) && value !== '';
}

function isBlob(value: any): value is Blob {
    return value instanceof Blob;
}

function getQueryString(params: Record<string, any>): string {
    const qs: string[] = [];
    Object.keys(params).forEach(key => {
        const value = params[key];
        if (isDefined(value)) {
            if (Array.isArray(value)) {
                value.forEach(value => {
                    qs.push(\`\${encodeURIComponent(key)}=\${encodeURIComponent(String(value))}\`);
                });
            } else {
                qs.push(\`\${encodeURIComponent(key)}=\${encodeURIComponent(String(value))}\`);
            }
        }
    });
    if (qs.length > 0) {
        return \`?\${qs.join('&')}\`;
    }
    return '';
}

function getUrl(config: OpenAPIConfig, options: ApiRequestOptions): string {
    const path = options.path
        .replace('{api-version}', config.VERSION)
        .replace(/[:]/g, '_');
    const url = \`\${config.BASE}\${path}\`;

    if (options.query) {
        return \`\${url}\${getQueryString(options.query)}\`;
    }
    return url;
}

function getFormData(params: Record<string, any>): FormData {
    const formData = new FormData();
    Object.keys(params).forEach(key => {
        const value = params[key];
        if (isDefined(value)) {
            formData.append(key, value);
        }
    });
    return formData;
}

type Resolver<T> = (options: ApiRequestOptions) => Promise<T>;

async function resolve<T>(options: ApiRequestOptions, resolver?: T | Resolver<T>): Promise<T | undefined> {
    if (typeof resolver === 'function') {
        return (resolver as Resolver<T>)(options);
    }
    return resolver;
}

async function getHeaders(config: OpenAPIConfig, options: ApiRequestOptions): Promise<Headers> {
    const token = await resolve(options, config.TOKEN);
    const username = await resolve(options, config.USERNAME);
    const password = await resolve(options, config.PASSWORD);
    const defaultHeaders = await resolve(options, config.HEADERS);

    const headers = new Headers({
        Accept: 'application/json',
        ...defaultHeaders,
        ...options.headers,
    });

    if (isStringWithValue(token)) {
        headers.append('Authorization', \`Bearer \${token}\`);
    }

    if (isStringWithValue(username) && isStringWithValue(password)) {
        const credentials = btoa(\`\${username}:\${password}\`);
        headers.append('Authorization', \`Basic \${credentials}\`);
    }

    if (options.body) {
        if (options.mediaType) {
            headers.append('Content-Type', options.mediaType);
        } else if (isBlob(options.body)) {
            headers.append('Content-Type', options.body.type || 'application/octet-stream');
        } else if (isString(options.body)) {
            headers.append('Content-Type', 'text/plain');
        } else {
            headers.append('Content-Type', 'application/json');
        }
    }
    return headers;
}

function getRequestBody(options: ApiRequestOptions): BodyInit | undefined {
    if (options.formData) {
        return getFormData(options.formData);
    }
    if (options.body) {
        if (options.mediaType?.includes('/json')) {
            return JSON.stringify(options.body)
        } else if (isString(options.body) || isBlob(options.body)) {
            return options.body;
        } else {
            return JSON.stringify(options.body);
        }
    }
    return undefined;
}

async function sendRequest(config: OpenAPIConfig, options: ApiRequestOptions, url: string): Promise<Response> {

    const request: RequestInit = {
        method: options.method,
        headers: await getHeaders(config, options),
        body: getRequestBody(options),
    };

    if (config.WITH_CREDENTIALS) {
        request.credentials = 'include';
    }


    return await fetch(url, request);
}

function getResponseHeader(response: Response, responseHeader?: string): string | null {
    if (responseHeader) {
        const content = response.headers.get(responseHeader);
        if (isString(content)) {
            return content;
        }
    }
    return null;
}

async function getResponseBody(response: Response): Promise<any> {
    try {
        const contentType = response.headers.get('Content-Type');
        if (contentType) {
            const isJSON = contentType.toLowerCase().startsWith('application/json');
            if (isJSON) {
                return await response.json();
            } else {
                return await response.text();
            }
        }
    } catch (error) {
        console.error(error);
    }
    return null;
}

function catchErrors(options: ApiRequestOptions, result: ApiResult): void {
    const errors: Record<string, string> = {
        [EHTTP_STATUS_CODES.BAD_GATEWAY]: EHTTP_STATUS_NAME.BAD_GATEWAY,
        [EHTTP_STATUS_CODES.BAD_REQUEST]: EHTTP_STATUS_NAME.BAD_REQUEST,
        [EHTTP_STATUS_CODES.FORBIDDEN]: EHTTP_STATUS_NAME.FORBIDDEN,
        [EHTTP_STATUS_CODES.INTERNAL_SERVER_ERROR]: EHTTP_STATUS_NAME.INTERNAL_SERVER_ERROR,
        [EHTTP_STATUS_CODES.NOT_FOUND]: EHTTP_STATUS_NAME.NOT_FOUND,
        [EHTTP_STATUS_CODES.SERVICE_UNAVAILABLE]: EHTTP_STATUS_NAME.SERVICE_UNAVAILABLE,
        [EHTTP_STATUS_CODES.UNAUTHORIZED]: EHTTP_STATUS_NAME.UNAUTHORIZED,
        ...options.errors,
    }

    const error = errors[result.status];
    if (error) {
        throw new ApiError(result, error);
    }

    if (!result.ok) {
        throw new ApiError(result, 'Generic Error');
    }
}

/**
 * Request using fetch client
 * @param config The OpenAPI configuration object
 * @param options The request options from the the service
 * @returns ApiResult
 * @throws ApiError
 */
export async function request<T>(config: OpenAPIConfig,options: ApiRequestOptions): Promise<T> {
    return new Promise(async (resolve, reject) => {
        try {
            const url = getUrl(config, options);
            const response = await sendRequest(config, options, url);
            const responseBody = await getResponseBody(response);
            const responseHeader = getResponseHeader(response, options.responseHeader);

            const result: ApiResult = {
                url,
                ok: response.ok,
                status: response.status,
                statusText: response.statusText,
                body: responseHeader || responseBody,
            };

            catchErrors(options, result);
            resolve(result.body);
        } catch (error) {
            reject(error);
        }
    });
}
"
`;

exports[`v3 should generate from different files: ./test/generated/v3_1/index.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
export { ApiError } from '././core/ApiError';
export { OpenAPI } from '././core/OpenAPI';

export { EEnumWithNumbers } from '././models/schemas/EnumWithNumbers';
export { EEnumWithStrings } from '././models/schemas/EnumWithStrings';
export type { IModelWithArray } from '././models/schemas/ModelWithArray';
export type { IModelWithCircularReference } from '././models/schemas/ModelWithCircularReference';
export type { IModelWithDictionary } from '././models/schemas/ModelWithDictionary';
export { IModelWithEnum } from '././models/schemas/ModelWithEnum';
export type { IModelWithString } from '././models/schemas/ModelWithString';
export type { TArrayWithArray } from '././models/ArrayWithArray';
export type { TModelThatExtends } from '././models/schemas/ModelThatExtends';

export { EEnumWithNumbersSchema } from '././schemas/schemas/EnumWithNumbersSchema';
export { EEnumWithStringsSchema } from '././schemas/schemas/EnumWithStringsSchema';
export { IModelWithArraySchema } from '././schemas/schemas/ModelWithArraySchema';
export { IModelWithCircularReferenceSchema } from '././schemas/schemas/ModelWithCircularReferenceSchema';
export { IModelWithDictionarySchema } from '././schemas/schemas/ModelWithDictionarySchema';
export { IModelWithEnumSchema } from '././schemas/schemas/ModelWithEnumSchema';
export { IModelWithStringSchema } from '././schemas/schemas/ModelWithStringSchema';
export { TArrayWithArraySchema } from '././schemas/ArrayWithArraySchema';
export { TModelThatExtendsSchema } from '././schemas/schemas/ModelThatExtendsSchema';

export { SimpleService } from '././services/SimpleService';
export { ParametersService } from '././services/ParametersService';
export { RequestBodyService } from '././services/RequestBodyService';
export { DefaultsService } from '././services/DefaultsService';
export { DuplicateService } from '././services/DuplicateService';
export { NoContentService } from '././services/NoContentService';
export { ResponseService } from '././services/ResponseService';
export { CollectionFormatService } from '././services/CollectionFormatService';
export { TypesService } from '././services/TypesService';
export { UploadService } from '././services/UploadService';
export { ComplexService } from '././services/ComplexService';
export { MultipartService } from '././services/MultipartService';
export { HeaderService } from '././services/HeaderService';
export { CircularService } from '././services/CircularService';
export { EnumsService } from '././services/EnumsService';
"
`;

exports[`v3 should generate from different files: ./test/generated/v3_1/models/ArrayWithArray.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */

import type { IModelWithString } from './schemas/ModelWithString';

/**
 * This is a simple array containing an array
 */
export type TArrayWithArray = Array<Array<IModelWithString>>;"
`;

exports[`v3 should generate from different files: ./test/generated/v3_1/models/schemas/EnumWithNumbers.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */

/**
 * This is a simple enum with numbers
 */
export enum EEnumWithNumbers {
    '_1' = 1,
    '_2' = 2,
    '_3' = 3,
    '_1.1' = 1.1,
    '_1.2' = 1.2,
    '_1.3' = 1.3,
    '_100' = 100,
    '_200' = 200,
    '_300' = 300,
    '_-100' = -100,
    '_-200' = -200,
    '_-300' = -300,
    '_-1.1' = -1.1,
    '_-1.2' = -1.2,
    '_-1.3' = -1.3,
}"
`;

exports[`v3 should generate from different files: ./test/generated/v3_1/models/schemas/EnumWithStrings.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */

/**
 * This is a simple enum with strings
 */
export enum EEnumWithStrings {
    SUCCESS = 'Success',
    WARNING = 'Warning',
    ERROR = 'Error',
}"
`;

exports[`v3 should generate from different files: ./test/generated/v3_1/models/schemas/ModelThatExtends.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */

import type { IModelWithString } from './ModelWithString';

/**
 * This is a model that extends another model
 */
export type TModelThatExtends = (IModelWithString & {
    propExtendsA?: string,
    propExtendsB?: IModelWithString,
});
"
`;

exports[`v3 should generate from different files: ./test/generated/v3_1/models/schemas/ModelWithArray.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */

import type { IModelWithString } from './ModelWithString';

/**
 * This is a model with one property containing an array
 */
export interface IModelWithArray {
    prop?: Array<IModelWithString>;
    propWithFile?: Array<Blob>;
    propWithNumber?: Array<number>;
}
"
`;

exports[`v3 should generate from different files: ./test/generated/v3_1/models/schemas/ModelWithCircularReference.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */

/**
 * This is a model with one property containing a circular reference
 */
export interface IModelWithCircularReference {
    prop?: IModelWithCircularReference;
}
"
`;

exports[`v3 should generate from different files: ./test/generated/v3_1/models/schemas/ModelWithDictionary.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */

/**
 * This is a model with one property containing a dictionary
 */
export interface IModelWithDictionary {
    prop?: Record<string, string>;
}
"
`;

exports[`v3 should generate from different files: ./test/generated/v3_1/models/schemas/ModelWithEnum.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */

/**
 * This is a model with one enum
 */
export interface IModelWithEnum {
    /**
     * This is a simple enum with strings
     */
    test?: IModelWithEnum.ETest;
    /**
     * These are the HTTP error code enums
     */
    statusCode?: IModelWithEnum.EStatusCode;
    /**
     * Simple boolean enum
     */
    bool?: boolean;
}

export namespace IModelWithEnum {

    /**
     * This is a simple enum with strings
     */
    export enum ETest {
        SUCCESS = 'Success',
        WARNING = 'Warning',
        ERROR = 'Error',
    }

    /**
     * These are the HTTP error code enums
     */
    export enum EStatusCode {
        _100 = '100',
        _200_FOO = '200 FOO',
        _300_FOO_BAR = '300 FOO_BAR',
        _400_FOO_BAR = '400 foo-bar',
        _500_FOO_BAR = '500 foo.bar',
        _600_FOO_BAR = '600 foo&bar',
    }


}
"
`;

exports[`v3 should generate from different files: ./test/generated/v3_1/models/schemas/ModelWithString.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */

/**
 * This is a model with one string property
 */
export interface IModelWithString {
    /**
     * This is a simple string property
     */
    prop?: string;
}
"
`;

exports[`v3 should generate from different files: ./test/generated/v3_1/schemas/ArrayWithArraySchema.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
export const TArrayWithArraySchema = {
    type: 'array',
    contains: {
        type: 'array',
        contains: {
            type: 'IModelWithString',
        },
    },
};"
`;

exports[`v3 should generate from different files: ./test/generated/v3_1/schemas/schemas/EnumWithNumbersSchema.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
export const EEnumWithNumbersSchema = {
    type: 'Enum',
};"
`;

exports[`v3 should generate from different files: ./test/generated/v3_1/schemas/schemas/EnumWithStringsSchema.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
export const EEnumWithStringsSchema = {
    type: 'Enum',
};"
`;

exports[`v3 should generate from different files: ./test/generated/v3_1/schemas/schemas/ModelThatExtendsSchema.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
export const TModelThatExtendsSchema = {
    type: 'all-of',
    contains: [{
        type: 'IModelWithString',
    }, {
        properties: {
            propExtendsA: {
                type: 'string',
            },
            propExtendsB: {
                type: 'IModelWithString',
            },
        },
    }],
};"
`;

exports[`v3 should generate from different files: ./test/generated/v3_1/schemas/schemas/ModelWithArraySchema.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
export const IModelWithArraySchema = {
    properties: {
        prop: {
            type: 'array',
            contains: {
                type: 'IModelWithString',
            },
        },
        propWithFile: {
            type: 'array',
            contains: {
                type: 'File',
            },
        },
        propWithNumber: {
            type: 'array',
            contains: {
                type: 'number',
            },
        },
    },
};"
`;

exports[`v3 should generate from different files: ./test/generated/v3_1/schemas/schemas/ModelWithCircularReferenceSchema.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
export const IModelWithCircularReferenceSchema = {
    properties: {
        prop: {
            type: 'IModelWithCircularReference',
        },
    },
};"
`;

exports[`v3 should generate from different files: ./test/generated/v3_1/schemas/schemas/ModelWithDictionarySchema.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
export const IModelWithDictionarySchema = {
    properties: {
        prop: {
            type: 'dictionary',
            contains: {
                type: 'string',
            },
        },
    },
};"
`;

exports[`v3 should generate from different files: ./test/generated/v3_1/schemas/schemas/ModelWithEnumSchema.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
export const IModelWithEnumSchema = {
    properties: {
        test: {
            type: 'Enum',
        },
        statusCode: {
            type: 'Enum',
        },
        bool: {
            type: 'boolean',
        },
    },
};"
`;

exports[`v3 should generate from different files: ./test/generated/v3_1/schemas/schemas/ModelWithStringSchema.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
export const IModelWithStringSchema = {
    properties: {
        prop: {
            type: 'string',
        },
    },
};"
`;

exports[`v3 should generate from different files: ./test/generated/v3_1/services/CircularService.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
import type { IModelWithCircularReference } from './../models/schemas/ModelWithCircularReference';
import { request as __request } from './../core/request';
import type { ApiRequestOptions } from './../core/ApiRequestOptions';
import { OpenAPI } from './../core/OpenAPI';

const callWithCircularModel = (): ApiRequestOptions => ({
    method: 'GET',
    path: \`/api/v{api-version}/circular\`,
});


export type TCircularOptions = {
    callWithCircularModel: () => ApiRequestOptions;
}

export const CircularOptions: TCircularOptions = {
    callWithCircularModel: callWithCircularModel,
}

export class CircularService {

    /**
     * @returns IModelWithCircularReference
     * @throws ApiError
     */
    public static callWithCircularModel(): Promise<IModelWithCircularReference> {
        return __request<IModelWithCircularReference>(OpenAPI, CircularOptions.callWithCircularModel());
    }
}"
`;

exports[`v3 should generate from different files: ./test/generated/v3_1/services/CollectionFormatService.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
import { request as __request } from './../core/request';
import type { ApiRequestOptions } from './../core/ApiRequestOptions';
import { OpenAPI } from './../core/OpenAPI';

const collectionFormat = (
    parameterArrayCsv: Array<string> | null,
    parameterArraySsv: Array<string> | null,
    parameterArrayTsv: Array<string> | null,
    parameterArrayPipes: Array<string> | null,
    parameterArrayMulti: Array<string> | null,
): ApiRequestOptions => ({
    method: 'GET',
    path: \`/api/v{api-version}/collectionFormat\`,
    query: {
        'parameterArrayCSV': parameterArrayCsv,
        'parameterArraySSV': parameterArraySsv,
        'parameterArrayTSV': parameterArrayTsv,
        'parameterArrayPipes': parameterArrayPipes,
        'parameterArrayMulti': parameterArrayMulti,
    },
});


export type TCollectionFormatOptions = {
    collectionFormat: (
        parameterArrayCsv: Array<string> | null,
        parameterArraySsv: Array<string> | null,
        parameterArrayTsv: Array<string> | null,
        parameterArrayPipes: Array<string> | null,
        parameterArrayMulti: Array<string> | null,
    ) => ApiRequestOptions;
}

export const CollectionFormatOptions: TCollectionFormatOptions = {
    collectionFormat: collectionFormat,
}

export class CollectionFormatService {

    /**
     * @param parameterArrayCsv This is an array parameter that is send as csv format (comma-separated values)
     * @param parameterArraySsv This is an array parameter that is send as ssv format (space-separated values)
     * @param parameterArrayTsv This is an array parameter that is send as tsv format (tab-separated values)
     * @param parameterArrayPipes This is an array parameter that is send as pipes format (pipe-separated values)
     * @param parameterArrayMulti This is an array parameter that is send as multi format (multiple parameter instances)
     * @throws ApiError
     */
    public static collectionFormat(
        parameterArrayCsv: Array<string> | null,
        parameterArraySsv: Array<string> | null,
        parameterArrayTsv: Array<string> | null,
        parameterArrayPipes: Array<string> | null,
        parameterArrayMulti: Array<string> | null,
    ): Promise<void> {
        return __request<void>(OpenAPI, CollectionFormatOptions.collectionFormat(
            parameterArrayCsv,
            parameterArraySsv,
            parameterArrayTsv,
            parameterArrayPipes,
            parameterArrayMulti,
        ));
    }
}"
`;

exports[`v3 should generate from different files: ./test/generated/v3_1/services/ComplexService.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
import type { IModelWithArray } from './../models/schemas/ModelWithArray';
import type { IModelWithDictionary } from './../models/schemas/ModelWithDictionary';
import type { IModelWithEnum } from './../models/schemas/ModelWithEnum';
import type { IModelWithString } from './../models/schemas/ModelWithString';
import { request as __request } from './../core/request';
import type { ApiRequestOptions } from './../core/ApiRequestOptions';
import { OpenAPI } from './../core/OpenAPI';

const complexTypes = (
    parameterObject: {
        first?: {
            second?: {
                third?: string,
            },
        },
    },
    parameterReference: IModelWithString,
): ApiRequestOptions => ({
    method: 'GET',
    path: \`/api/v{api-version}/complex\`,
    query: {
        'parameterObject': parameterObject,
        'parameterReference': parameterReference,
    },
    errors: {
        400: \`400 server error\`,
        500: \`500 server error\`,
    },
});

const complexParams = (
    id: number,
    requestBody?: {
        readonly key: string | null,
        name: string | null,
        enabled: boolean,
        readonly type: 'Monkey' | 'Horse' | 'Bird',
        listOfModels?: Array<IModelWithString> | null,
        listOfStrings?: Array<string> | null,
        parameters: (IModelWithString | IModelWithEnum | IModelWithArray | IModelWithDictionary),
        readonly user?: {
            readonly id?: number,
            readonly name?: string | null,
        },
    },
): ApiRequestOptions => ({
    method: 'PUT',
    path: \`/api/v{api-version}/complex/\${id}\`,
    body: requestBody,
    mediaType: 'application/json-patch+json',
});


export type TComplexOptions = {
    complexTypes: (
        parameterObject: {
            first?: {
                second?: {
                    third?: string,
                },
            },
        },
        parameterReference: IModelWithString,
    ) => ApiRequestOptions;
    complexParams: (
        id: number,
        requestBody?: {
            readonly key: string | null,
            name: string | null,
            enabled: boolean,
            readonly type: 'Monkey' | 'Horse' | 'Bird',
            listOfModels?: Array<IModelWithString> | null,
            listOfStrings?: Array<string> | null,
            parameters: (IModelWithString | IModelWithEnum | IModelWithArray | IModelWithDictionary),
            readonly user?: {
                readonly id?: number,
                readonly name?: string | null,
            },
        },
    ) => ApiRequestOptions;
}

export const ComplexOptions: TComplexOptions = {
    complexTypes: complexTypes,
    complexParams: complexParams,
}

export class ComplexService {

    /**
     * @param parameterObject Parameter containing object
     * @param parameterReference Parameter containing reference
     * @returns IModelWithString Successful response
     * @throws ApiError
     */
    public static complexTypes(
        parameterObject: {
            first?: {
                second?: {
                    third?: string,
                },
            },
        },
        parameterReference: IModelWithString,
    ): Promise<Array<IModelWithString>> {
        return __request<Array<IModelWithString>>(OpenAPI, ComplexOptions.complexTypes(
            parameterObject,
            parameterReference,
        ));
    }
    /**
     * @param id
     * @param requestBody
     * @returns IModelWithString Success
     * @throws ApiError
     */
    public static complexParams(
        id: number,
        requestBody?: {
            readonly key: string | null,
            name: string | null,
            enabled: boolean,
            readonly type: 'Monkey' | 'Horse' | 'Bird',
            listOfModels?: Array<IModelWithString> | null,
            listOfStrings?: Array<string> | null,
            parameters: (IModelWithString | IModelWithEnum | IModelWithArray | IModelWithDictionary),
            readonly user?: {
                readonly id?: number,
                readonly name?: string | null,
            },
        },
    ): Promise<IModelWithString> {
        return __request<IModelWithString>(OpenAPI, ComplexOptions.complexParams(
            id,
            requestBody,
        ));
    }
}"
`;

exports[`v3 should generate from different files: ./test/generated/v3_1/services/DefaultsService.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
import type { IModelWithString } from './../models/schemas/ModelWithString';
import { request as __request } from './../core/request';
import type { ApiRequestOptions } from './../core/ApiRequestOptions';
import { OpenAPI } from './../core/OpenAPI';

const callWithDefaultParameters = (
    parameterString: string | null = 'Hello World!',
    parameterNumber: number | null = 123,
    parameterBoolean: boolean | null = true,
    parameterEnum: 'Success' | 'Warning' | 'Error' = 'Success',
    parameterModel: IModelWithString | null = {
        \\"prop\\": \\"Hello World!\\"
    },
): ApiRequestOptions => ({
    method: 'GET',
    path: \`/api/v{api-version}/defaults\`,
    query: {
        'parameterString': parameterString,
        'parameterNumber': parameterNumber,
        'parameterBoolean': parameterBoolean,
        'parameterEnum': parameterEnum,
        'parameterModel': parameterModel,
    },
});

const callWithDefaultOptionalParameters = (
    parameterString: string = 'Hello World!',
    parameterNumber: number = 123,
    parameterBoolean: boolean = true,
    parameterEnum: 'Success' | 'Warning' | 'Error' = 'Success',
    parameterModel: IModelWithString = {
        \\"prop\\": \\"Hello World!\\"
    },
): ApiRequestOptions => ({
    method: 'POST',
    path: \`/api/v{api-version}/defaults\`,
    query: {
        'parameterString': parameterString,
        'parameterNumber': parameterNumber,
        'parameterBoolean': parameterBoolean,
        'parameterEnum': parameterEnum,
        'parameterModel': parameterModel,
    },
});

const callToTestOrderOfParams = (
    parameterStringWithNoDefault: string,
    parameterOptionalStringWithDefault: string = 'Hello World!',
    parameterOptionalStringWithEmptyDefault: string = '',
    parameterStringWithDefault: string = 'Hello World!',
    parameterStringWithEmptyDefault: string = '',
    parameterOptionalStringWithNoDefault?: string,
): ApiRequestOptions => ({
    method: 'PUT',
    path: \`/api/v{api-version}/defaults\`,
    query: {
        'parameterStringWithNoDefault': parameterStringWithNoDefault,
        'parameterOptionalStringWithDefault': parameterOptionalStringWithDefault,
        'parameterOptionalStringWithEmptyDefault': parameterOptionalStringWithEmptyDefault,
        'parameterStringWithDefault': parameterStringWithDefault,
        'parameterStringWithEmptyDefault': parameterStringWithEmptyDefault,
        'parameterOptionalStringWithNoDefault': parameterOptionalStringWithNoDefault,
    },
});


export type TDefaultsOptions = {
    callWithDefaultParameters: (
        parameterString: string | null,
        parameterNumber: number | null,
        parameterBoolean: boolean | null,
        parameterEnum: 'Success' | 'Warning' | 'Error',
        parameterModel: IModelWithString | null,
    ) => ApiRequestOptions;
    callWithDefaultOptionalParameters: (
        parameterString: string,
        parameterNumber: number,
        parameterBoolean: boolean,
        parameterEnum: 'Success' | 'Warning' | 'Error',
        parameterModel: IModelWithString,
    ) => ApiRequestOptions;
    callToTestOrderOfParams: (
        parameterStringWithNoDefault: string,
        parameterOptionalStringWithDefault: string,
        parameterOptionalStringWithEmptyDefault: string,
        parameterStringWithDefault: string,
        parameterStringWithEmptyDefault: string,
        parameterOptionalStringWithNoDefault?: string,
    ) => ApiRequestOptions;
}

export const DefaultsOptions: TDefaultsOptions = {
    callWithDefaultParameters: callWithDefaultParameters,
    callWithDefaultOptionalParameters: callWithDefaultOptionalParameters,
    callToTestOrderOfParams: callToTestOrderOfParams,
}

export class DefaultsService {

    /**
     * @param parameterString This is a simple string with default value
     * @param parameterNumber This is a simple number with default value
     * @param parameterBoolean This is a simple boolean with default value
     * @param parameterEnum This is a simple enum with default value
     * @param parameterModel This is a simple model with default value
     * @throws ApiError
     */
    public static callWithDefaultParameters(
        parameterString: string | null = 'Hello World!',
        parameterNumber: number | null = 123,
        parameterBoolean: boolean | null = true,
        parameterEnum: 'Success' | 'Warning' | 'Error' = 'Success',
        parameterModel: IModelWithString | null = {
            \\"prop\\": \\"Hello World!\\"
        },
    ): Promise<void> {
        return __request<void>(OpenAPI, DefaultsOptions.callWithDefaultParameters(
            parameterString,
            parameterNumber,
            parameterBoolean,
            parameterEnum,
            parameterModel,
        ));
    }
    /**
     * @param parameterString This is a simple string that is optional with default value
     * @param parameterNumber This is a simple number that is optional with default value
     * @param parameterBoolean This is a simple boolean that is optional with default value
     * @param parameterEnum This is a simple enum that is optional with default value
     * @param parameterModel This is a simple model that is optional with default value
     * @throws ApiError
     */
    public static callWithDefaultOptionalParameters(
        parameterString: string = 'Hello World!',
        parameterNumber: number = 123,
        parameterBoolean: boolean = true,
        parameterEnum: 'Success' | 'Warning' | 'Error' = 'Success',
        parameterModel: IModelWithString = {
            \\"prop\\": \\"Hello World!\\"
        },
    ): Promise<void> {
        return __request<void>(OpenAPI, DefaultsOptions.callWithDefaultOptionalParameters(
            parameterString,
            parameterNumber,
            parameterBoolean,
            parameterEnum,
            parameterModel,
        ));
    }
    /**
     * @param parameterStringWithNoDefault This is a string with no default
     * @param parameterOptionalStringWithDefault This is a optional string with default
     * @param parameterOptionalStringWithEmptyDefault This is a optional string with empty default
     * @param parameterStringWithDefault This is a string with default
     * @param parameterStringWithEmptyDefault This is a string with empty default
     * @param parameterOptionalStringWithNoDefault This is a optional string with no default
     * @throws ApiError
     */
    public static callToTestOrderOfParams(
        parameterStringWithNoDefault: string,
        parameterOptionalStringWithDefault: string = 'Hello World!',
        parameterOptionalStringWithEmptyDefault: string = '',
        parameterStringWithDefault: string = 'Hello World!',
        parameterStringWithEmptyDefault: string = '',
        parameterOptionalStringWithNoDefault?: string,
    ): Promise<void> {
        return __request<void>(OpenAPI, DefaultsOptions.callToTestOrderOfParams(
            parameterStringWithNoDefault,
            parameterOptionalStringWithDefault,
            parameterOptionalStringWithEmptyDefault,
            parameterStringWithDefault,
            parameterStringWithEmptyDefault,
            parameterOptionalStringWithNoDefault,
        ));
    }
}"
`;

exports[`v3 should generate from different files: ./test/generated/v3_1/services/DuplicateService.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
import { request as __request } from './../core/request';
import type { ApiRequestOptions } from './../core/ApiRequestOptions';
import { OpenAPI } from './../core/OpenAPI';

const duplicateName = (): ApiRequestOptions => ({
    method: 'GET',
    path: \`/api/v{api-version}/duplicate\`,
});

const duplicateName1 = (): ApiRequestOptions => ({
    method: 'POST',
    path: \`/api/v{api-version}/duplicate\`,
});

const duplicateName2 = (): ApiRequestOptions => ({
    method: 'PUT',
    path: \`/api/v{api-version}/duplicate\`,
});

const duplicateName3 = (): ApiRequestOptions => ({
    method: 'DELETE',
    path: \`/api/v{api-version}/duplicate\`,
});


export type TDuplicateOptions = {
    duplicateName: () => ApiRequestOptions;
    duplicateName1: () => ApiRequestOptions;
    duplicateName2: () => ApiRequestOptions;
    duplicateName3: () => ApiRequestOptions;
}

export const DuplicateOptions: TDuplicateOptions = {
    duplicateName: duplicateName,
    duplicateName1: duplicateName1,
    duplicateName2: duplicateName2,
    duplicateName3: duplicateName3,
}

export class DuplicateService {

    /**
     * @throws ApiError
     */
    public static duplicateName(): Promise<void> {
        return __request<void>(OpenAPI, DuplicateOptions.duplicateName());
    }
    /**
     * @throws ApiError
     */
    public static duplicateName1(): Promise<void> {
        return __request<void>(OpenAPI, DuplicateOptions.duplicateName1());
    }
    /**
     * @throws ApiError
     */
    public static duplicateName2(): Promise<void> {
        return __request<void>(OpenAPI, DuplicateOptions.duplicateName2());
    }
    /**
     * @throws ApiError
     */
    public static duplicateName3(): Promise<void> {
        return __request<void>(OpenAPI, DuplicateOptions.duplicateName3());
    }
}"
`;

exports[`v3 should generate from different files: ./test/generated/v3_1/services/EnumsService.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
import { request as __request } from './../core/request';
import type { ApiRequestOptions } from './../core/ApiRequestOptions';
import { OpenAPI } from './../core/OpenAPI';

const callWithEnums = (
    requestBody?: any,
): ApiRequestOptions => ({
    method: 'POST',
    path: \`/api/v{api-version}/enums\`,
    body: requestBody,
});


export type TEnumsOptions = {
    callWithEnums: (
        requestBody?: any,
    ) => ApiRequestOptions;
}

export const EnumsOptions: TEnumsOptions = {
    callWithEnums: callWithEnums,
}

export class EnumsService {

    /**
     * @param requestBody
     * @throws ApiError
     */
    public static callWithEnums(
        requestBody?: any,
    ): Promise<void> {
        return __request<void>(OpenAPI, EnumsOptions.callWithEnums(
            requestBody,
        ));
    }
}"
`;

exports[`v3 should generate from different files: ./test/generated/v3_1/services/HeaderService.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
import { request as __request } from './../core/request';
import type { ApiRequestOptions } from './../core/ApiRequestOptions';
import { OpenAPI } from './../core/OpenAPI';

const callWithResultFromHeader = (): ApiRequestOptions => ({
    method: 'POST',
    path: \`/api/v{api-version}/header\`,
    responseHeader: 'operation-location',
    errors: {
        400: \`400 server error\`,
        500: \`500 server error\`,
    },
});


export type THeaderOptions = {
    callWithResultFromHeader: () => ApiRequestOptions;
}

export const HeaderOptions: THeaderOptions = {
    callWithResultFromHeader: callWithResultFromHeader,
}

export class HeaderService {

    /**
     * @returns string Successful response
     * @throws ApiError
     */
    public static callWithResultFromHeader(): Promise<string> {
        return __request<string>(OpenAPI, HeaderOptions.callWithResultFromHeader());
    }
}"
`;

exports[`v3 should generate from different files: ./test/generated/v3_1/services/MultipartService.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
import { request as __request } from './../core/request';
import type { ApiRequestOptions } from './../core/ApiRequestOptions';
import { OpenAPI } from './../core/OpenAPI';

const multipartResponse = (): ApiRequestOptions => ({
    method: 'GET',
    path: \`/api/v{api-version}/multipart\`,
});


export type TMultipartOptions = {
    multipartResponse: () => ApiRequestOptions;
}

export const MultipartOptions: TMultipartOptions = {
    multipartResponse: multipartResponse,
}

export class MultipartService {

    /**
     * @returns any OK
     * @throws ApiError
     */
    public static multipartResponse(): Promise<{
        file?: string,
        metadata?: {
            foo?: string,
            bar?: string,
        },
    }> {
        return __request<{
            file?: string,
            metadata?: {
                foo?: string,
                bar?: string,
            },
        }>(OpenAPI, MultipartOptions.multipartResponse());
    }
}"
`;

exports[`v3 should generate from different files: ./test/generated/v3_1/services/NoContentService.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
import { request as __request } from './../core/request';
import type { ApiRequestOptions } from './../core/ApiRequestOptions';
import { OpenAPI } from './../core/OpenAPI';

const callWithNoContentResponse = (): ApiRequestOptions => ({
    method: 'GET',
    path: \`/api/v{api-version}/no-content\`,
});


export type TNoContentOptions = {
    callWithNoContentResponse: () => ApiRequestOptions;
}

export const NoContentOptions: TNoContentOptions = {
    callWithNoContentResponse: callWithNoContentResponse,
}

export class NoContentService {

    /**
     * @returns void
     * @throws ApiError
     */
    public static callWithNoContentResponse(): Promise<void> {
        return __request<void>(OpenAPI, NoContentOptions.callWithNoContentResponse());
    }
}"
`;

exports[`v3 should generate from different files: ./test/generated/v3_1/services/ParametersService.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
import type { IModelWithString } from './../models/schemas/ModelWithString';
import { request as __request } from './../core/request';
import type { ApiRequestOptions } from './../core/ApiRequestOptions';
import { OpenAPI } from './../core/OpenAPI';

const callWithParameters = (
    parameterHeader: string | null,
    parameterQuery: string | null,
    parameterForm: string | null,
    parameterCookie: string | null,
    parameterPath: string | null,
    requestBody: IModelWithString | null,
): ApiRequestOptions => ({
    method: 'GET',
    path: \`/api/v{api-version}/parameters/\${parameterPath}\`,
    cookies: {
        'parameterCookie': parameterCookie,
    },
    headers: {
        'parameterHeader': parameterHeader,
    },
    query: {
        'parameterQuery': parameterQuery,
    },
    formData: {
        'parameterForm': parameterForm,
    },
    body: requestBody,
    mediaType: 'application/json',
});

const callWithWeirdParameterNames = (
    parameterHeader: string | null,
    parameterQuery: string | null,
    parameterForm: string | null,
    parameterCookie: string | null,
    requestBody: IModelWithString | null,
    parameterPath1?: string,
    parameterPath2?: string,
    parameterPath3?: string,
    _default?: string,
): ApiRequestOptions => ({
    method: 'GET',
    path: \`/api/v{api-version}/parameters/\${parameterPath1}/\${parameterPath2}/\${parameterPath3}\`,
    cookies: {
        'PARAMETER-COOKIE': parameterCookie,
    },
    headers: {
        'parameter.header': parameterHeader,
    },
    query: {
        'parameter-query': parameterQuery,
        'default': _default,
    },
    formData: {
        'parameter_form': parameterForm,
    },
    body: requestBody,
    mediaType: 'application/json',
});

const getCallWithOptionalParam = (
    requestBody: IModelWithString,
    parameter?: string,
): ApiRequestOptions => ({
    method: 'GET',
    path: \`/api/v{api-version}/parameters/\`,
    query: {
        'parameter': parameter,
    },
    body: requestBody,
    mediaType: 'application/json',
});

const postCallWithOptionalParam = (
    parameter: string,
    requestBody?: IModelWithString,
): ApiRequestOptions => ({
    method: 'POST',
    path: \`/api/v{api-version}/parameters/\`,
    query: {
        'parameter': parameter,
    },
    body: requestBody,
    mediaType: 'application/json',
});


export type TParametersOptions = {
    callWithParameters: (
        parameterHeader: string | null,
        parameterQuery: string | null,
        parameterForm: string | null,
        parameterCookie: string | null,
        parameterPath: string | null,
        requestBody: IModelWithString | null,
    ) => ApiRequestOptions;
    callWithWeirdParameterNames: (
        parameterHeader: string | null,
        parameterQuery: string | null,
        parameterForm: string | null,
        parameterCookie: string | null,
        requestBody: IModelWithString | null,
        parameterPath1?: string,
        parameterPath2?: string,
        parameterPath3?: string,
        _default?: string,
    ) => ApiRequestOptions;
    getCallWithOptionalParam: (
        requestBody: IModelWithString,
        parameter?: string,
    ) => ApiRequestOptions;
    postCallWithOptionalParam: (
        parameter: string,
        requestBody?: IModelWithString,
    ) => ApiRequestOptions;
}

export const ParametersOptions: TParametersOptions = {
    callWithParameters: callWithParameters,
    callWithWeirdParameterNames: callWithWeirdParameterNames,
    getCallWithOptionalParam: getCallWithOptionalParam,
    postCallWithOptionalParam: postCallWithOptionalParam,
}

export class ParametersService {

    /**
     * @param parameterHeader This is the parameter that goes into the header
     * @param parameterQuery This is the parameter that goes into the query params
     * @param parameterForm This is the parameter that goes into the form data
     * @param parameterCookie This is the parameter that goes into the cookie
     * @param parameterPath This is the parameter that goes into the path
     * @param requestBody This is the parameter that goes into the body
     * @throws ApiError
     */
    public static callWithParameters(
        parameterHeader: string | null,
        parameterQuery: string | null,
        parameterForm: string | null,
        parameterCookie: string | null,
        parameterPath: string | null,
        requestBody: IModelWithString | null,
    ): Promise<void> {
        return __request<void>(OpenAPI, ParametersOptions.callWithParameters(
            parameterHeader,
            parameterQuery,
            parameterForm,
            parameterCookie,
            parameterPath,
            requestBody,
        ));
    }
    /**
     * @param parameterHeader This is the parameter that goes into the request header
     * @param parameterQuery This is the parameter that goes into the request query params
     * @param parameterForm This is the parameter that goes into the request form data
     * @param parameterCookie This is the parameter that goes into the cookie
     * @param requestBody This is the parameter that goes into the body
     * @param parameterPath1 This is the parameter that goes into the path
     * @param parameterPath2 This is the parameter that goes into the path
     * @param parameterPath3 This is the parameter that goes into the path
     * @param _default This is the parameter with a reserved keyword
     * @throws ApiError
     */
    public static callWithWeirdParameterNames(
        parameterHeader: string | null,
        parameterQuery: string | null,
        parameterForm: string | null,
        parameterCookie: string | null,
        requestBody: IModelWithString | null,
        parameterPath1?: string,
        parameterPath2?: string,
        parameterPath3?: string,
        _default?: string,
    ): Promise<void> {
        return __request<void>(OpenAPI, ParametersOptions.callWithWeirdParameterNames(
            parameterHeader,
            parameterQuery,
            parameterForm,
            parameterCookie,
            requestBody,
            parameterPath1,
            parameterPath2,
            parameterPath3,
            _default,
        ));
    }
    /**
     * @param requestBody This is a required parameter
     * @param parameter This is an optional parameter
     * @throws ApiError
     */
    public static getCallWithOptionalParam(
        requestBody: IModelWithString,
        parameter?: string,
    ): Promise<void> {
        return __request<void>(OpenAPI, ParametersOptions.getCallWithOptionalParam(
            requestBody,
            parameter,
        ));
    }
    /**
     * @param parameter This is a required parameter
     * @param requestBody This is an optional parameter
     * @throws ApiError
     */
    public static postCallWithOptionalParam(
        parameter: string,
        requestBody?: IModelWithString,
    ): Promise<void> {
        return __request<void>(OpenAPI, ParametersOptions.postCallWithOptionalParam(
            parameter,
            requestBody,
        ));
    }
}"
`;

exports[`v3 should generate from different files: ./test/generated/v3_1/services/RequestBodyService.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
import type { IModelWithString } from './../models/schemas/ModelWithString';
import { request as __request } from './../core/request';
import type { ApiRequestOptions } from './../core/ApiRequestOptions';
import { OpenAPI } from './../core/OpenAPI';

const postRequestBodyService = (
    requestBody?: IModelWithString,
): ApiRequestOptions => ({
    method: 'POST',
    path: \`/api/v{api-version}/requestBody/\`,
    body: requestBody,
    mediaType: 'application/json',
});


export type TRequestBodyOptions = {
    postRequestBodyService: (
        requestBody?: IModelWithString,
    ) => ApiRequestOptions;
}

export const RequestBodyOptions: TRequestBodyOptions = {
    postRequestBodyService: postRequestBodyService,
}

export class RequestBodyService {

    /**
     * @param requestBody A reusable request body
     * @throws ApiError
     */
    public static postRequestBodyService(
        requestBody?: IModelWithString,
    ): Promise<void> {
        return __request<void>(OpenAPI, RequestBodyOptions.postRequestBodyService(
            requestBody,
        ));
    }
}"
`;

exports[`v3 should generate from different files: ./test/generated/v3_1/services/ResponseService.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
import type { TModelThatExtends } from './../models/schemas/ModelThatExtends';
import type { IModelWithString } from './../models/schemas/ModelWithString';
import { request as __request } from './../core/request';
import type { ApiRequestOptions } from './../core/ApiRequestOptions';
import { OpenAPI } from './../core/OpenAPI';

const callWithResponse = (): ApiRequestOptions => ({
    method: 'GET',
    path: \`/api/v{api-version}/response\`,
});

const callWithDuplicateResponses = (): ApiRequestOptions => ({
    method: 'POST',
    path: \`/api/v{api-version}/response\`,
    errors: {
        500: \`Message for 500 error\`,
        501: \`Message for 501 error\`,
        502: \`Message for 502 error\`,
    },
});

const callWithResponses = (): ApiRequestOptions => ({
    method: 'PUT',
    path: \`/api/v{api-version}/response\`,
    errors: {
        500: \`Message for 500 error\`,
        501: \`Message for 501 error\`,
        502: \`Message for 502 error\`,
    },
});


export type TResponseOptions = {
    callWithResponse: () => ApiRequestOptions;
    callWithDuplicateResponses: () => ApiRequestOptions;
    callWithResponses: () => ApiRequestOptions;
}

export const ResponseOptions: TResponseOptions = {
    callWithResponse: callWithResponse,
    callWithDuplicateResponses: callWithDuplicateResponses,
    callWithResponses: callWithResponses,
}

export class ResponseService {

    /**
     * @returns IModelWithString
     * @throws ApiError
     */
    public static callWithResponse(): Promise<IModelWithString> {
        return __request<IModelWithString>(OpenAPI, ResponseOptions.callWithResponse());
    }
    /**
     * @returns IModelWithString Message for default response
     * @throws ApiError
     */
    public static callWithDuplicateResponses(): Promise<IModelWithString> {
        return __request<IModelWithString>(OpenAPI, ResponseOptions.callWithDuplicateResponses());
    }
    /**
     * @returns any Message for 200 response
     * @returns IModelWithString Message for default response
     * @returns TModelThatExtends Message for 201 response
     * @throws ApiError
     */
    public static callWithResponses(): Promise<{
        readonly '@namespace.string'?: string,
        readonly '@namespace.integer'?: number,
        readonly value?: Array<IModelWithString>,
    } | IModelWithString | TModelThatExtends> {
        return __request<{
            readonly '@namespace.string'?: string,
            readonly '@namespace.integer'?: number,
            readonly value?: Array<IModelWithString>,
        } | IModelWithString | TModelThatExtends>(OpenAPI, ResponseOptions.callWithResponses());
    }
}"
`;

exports[`v3 should generate from different files: ./test/generated/v3_1/services/SimpleService.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
import { request as __request } from './../core/request';
import type { ApiRequestOptions } from './../core/ApiRequestOptions';
import { OpenAPI } from './../core/OpenAPI';

const getCallWithoutParametersAndResponse = (): ApiRequestOptions => ({
    method: 'GET',
    path: \`/api/v{api-version}/simple\`,
});

const putCallWithoutParametersAndResponse = (): ApiRequestOptions => ({
    method: 'PUT',
    path: \`/api/v{api-version}/simple\`,
});

const postCallWithoutParametersAndResponse = (): ApiRequestOptions => ({
    method: 'POST',
    path: \`/api/v{api-version}/simple\`,
});

const deleteCallWithoutParametersAndResponse = (): ApiRequestOptions => ({
    method: 'DELETE',
    path: \`/api/v{api-version}/simple\`,
});

const optionsCallWithoutParametersAndResponse = (): ApiRequestOptions => ({
    method: 'OPTIONS',
    path: \`/api/v{api-version}/simple\`,
});

const headCallWithoutParametersAndResponse = (): ApiRequestOptions => ({
    method: 'HEAD',
    path: \`/api/v{api-version}/simple\`,
});

const patchCallWithoutParametersAndResponse = (): ApiRequestOptions => ({
    method: 'PATCH',
    path: \`/api/v{api-version}/simple\`,
});


export type TSimpleOptions = {
    getCallWithoutParametersAndResponse: () => ApiRequestOptions;
    putCallWithoutParametersAndResponse: () => ApiRequestOptions;
    postCallWithoutParametersAndResponse: () => ApiRequestOptions;
    deleteCallWithoutParametersAndResponse: () => ApiRequestOptions;
    optionsCallWithoutParametersAndResponse: () => ApiRequestOptions;
    headCallWithoutParametersAndResponse: () => ApiRequestOptions;
    patchCallWithoutParametersAndResponse: () => ApiRequestOptions;
}

export const SimpleOptions: TSimpleOptions = {
    getCallWithoutParametersAndResponse: getCallWithoutParametersAndResponse,
    putCallWithoutParametersAndResponse: putCallWithoutParametersAndResponse,
    postCallWithoutParametersAndResponse: postCallWithoutParametersAndResponse,
    deleteCallWithoutParametersAndResponse: deleteCallWithoutParametersAndResponse,
    optionsCallWithoutParametersAndResponse: optionsCallWithoutParametersAndResponse,
    headCallWithoutParametersAndResponse: headCallWithoutParametersAndResponse,
    patchCallWithoutParametersAndResponse: patchCallWithoutParametersAndResponse,
}

export class SimpleService {

    /**
     * @throws ApiError
     */
    public static getCallWithoutParametersAndResponse(): Promise<void> {
        return __request<void>(OpenAPI, SimpleOptions.getCallWithoutParametersAndResponse());
    }
    /**
     * @throws ApiError
     */
    public static putCallWithoutParametersAndResponse(): Promise<void> {
        return __request<void>(OpenAPI, SimpleOptions.putCallWithoutParametersAndResponse());
    }
    /**
     * @throws ApiError
     */
    public static postCallWithoutParametersAndResponse(): Promise<void> {
        return __request<void>(OpenAPI, SimpleOptions.postCallWithoutParametersAndResponse());
    }
    /**
     * @throws ApiError
     */
    public static deleteCallWithoutParametersAndResponse(): Promise<void> {
        return __request<void>(OpenAPI, SimpleOptions.deleteCallWithoutParametersAndResponse());
    }
    /**
     * @throws ApiError
     */
    public static optionsCallWithoutParametersAndResponse(): Promise<void> {
        return __request<void>(OpenAPI, SimpleOptions.optionsCallWithoutParametersAndResponse());
    }
    /**
     * @throws ApiError
     */
    public static headCallWithoutParametersAndResponse(): Promise<void> {
        return __request<void>(OpenAPI, SimpleOptions.headCallWithoutParametersAndResponse());
    }
    /**
     * @throws ApiError
     */
    public static patchCallWithoutParametersAndResponse(): Promise<void> {
        return __request<void>(OpenAPI, SimpleOptions.patchCallWithoutParametersAndResponse());
    }
}"
`;

exports[`v3 should generate from different files: ./test/generated/v3_1/services/TypesService.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
import { request as __request } from './../core/request';
import type { ApiRequestOptions } from './../core/ApiRequestOptions';
import { OpenAPI } from './../core/OpenAPI';

const types = (
    parameterArray: Array<string> | null,
    parameterDictionary: any,
    parameterEnum: 'Success' | 'Warning' | 'Error' | null,
    parameterNumber: number = 123,
    parameterString: string | null = 'default',
    parameterBoolean: boolean | null = true,
    parameterObject: any = null,
    id?: number,
): ApiRequestOptions => ({
    method: 'GET',
    path: \`/api/v{api-version}/types\`,
    query: {
        'parameterArray': parameterArray,
        'parameterDictionary': parameterDictionary,
        'parameterEnum': parameterEnum,
        'parameterNumber': parameterNumber,
        'parameterString': parameterString,
        'parameterBoolean': parameterBoolean,
        'parameterObject': parameterObject,
    },
});


export type TTypesOptions = {
    types: (
        parameterArray: Array<string> | null,
        parameterDictionary: any,
        parameterEnum: 'Success' | 'Warning' | 'Error' | null,
        parameterNumber: number,
        parameterString: string | null,
        parameterBoolean: boolean | null,
        parameterObject: any,
        id?: number,
    ) => ApiRequestOptions;
}

export const TypesOptions: TTypesOptions = {
    types: types,
}

export class TypesService {

    /**
     * @param parameterArray This is an array parameter
     * @param parameterDictionary This is a dictionary parameter
     * @param parameterEnum This is an enum parameter
     * @param parameterNumber This is a number parameter
     * @param parameterString This is a string parameter
     * @param parameterBoolean This is a boolean parameter
     * @param parameterObject This is an object parameter
     * @param id This is a number parameter
     * @returns number Response is a simple number
     * @returns string Response is a simple string
     * @returns boolean Response is a simple boolean
     * @returns any Response is a simple object
     * @throws ApiError
     */
    public static types(
        parameterArray: Array<string> | null,
        parameterDictionary: any,
        parameterEnum: 'Success' | 'Warning' | 'Error' | null,
        parameterNumber: number = 123,
        parameterString: string | null = 'default',
        parameterBoolean: boolean | null = true,
        parameterObject: any = null,
        id?: number,
    ): Promise<number | string | boolean | any> {
        return __request<number | string | boolean | any>(OpenAPI, TypesOptions.types(
            parameterArray,
            parameterDictionary,
            parameterEnum,
            parameterNumber,
            parameterString,
            parameterBoolean,
            parameterObject,
            id,
        ));
    }
}"
`;

exports[`v3 should generate from different files: ./test/generated/v3_1/services/UploadService.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
import { request as __request } from './../core/request';
import type { ApiRequestOptions } from './../core/ApiRequestOptions';
import { OpenAPI } from './../core/OpenAPI';

const uploadFile = (
    file: Blob,
): ApiRequestOptions => ({
    method: 'POST',
    path: \`/api/v{api-version}/upload\`,
    formData: {
        'file': file,
    },
});


export type TUploadOptions = {
    uploadFile: (
        file: Blob,
    ) => ApiRequestOptions;
}

export const UploadOptions: TUploadOptions = {
    uploadFile: uploadFile,
}

export class UploadService {

    /**
     * @param file Supply a file reference for upload
     * @returns boolean
     * @throws ApiError
     */
    public static uploadFile(
        file: Blob,
    ): Promise<boolean> {
        return __request<boolean>(OpenAPI, UploadOptions.uploadFile(
            file,
        ));
    }
}"
`;

exports[`v3 should generate: ./test/generated/v3/core/ApiError.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
import type { ApiResult } from './ApiResult';

export class ApiError extends Error {
    public readonly url: string;
    public readonly status: number;
    public readonly statusText: string;
    public readonly body: any;

    constructor(response: ApiResult, message: string) {
        super(message);

        this.url = response.url;
        this.status = response.status;
        this.statusText = response.statusText;
        this.body = response.body;
    }
}"
`;

exports[`v3 should generate: ./test/generated/v3/core/ApiRequestOptions.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
export type ApiRequestOptions = {
    readonly method: 'GET' | 'PUT' | 'POST' | 'DELETE' | 'OPTIONS' | 'HEAD' | 'PATCH';
    readonly path: string;
    readonly cookies?: Record<string, any>;
    readonly headers?: Record<string, any>;
    readonly query?: Record<string, any>;
    readonly formData?: Record<string, any>;
    readonly body?: any;
    readonly mediaType?: string;
    readonly responseHeader?: string;
    // TODO TS2344: Redesign the logic for generating errors. Use the string value of the error code.
    // @ts-ignore
    readonly errors?: Record<number, string>;
}"
`;

exports[`v3 should generate: ./test/generated/v3/core/ApiResult.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
export type ApiResult = {
    readonly url: string;
    readonly ok: boolean;
    readonly status: number;
    readonly statusText: string;
    readonly body: any;
}"
`;

exports[`v3 should generate: ./test/generated/v3/core/HttpStatusCode.ts 1`] = `
"export enum EHTTP_STATUS_CODES {
    BAD_REQUEST = 400,
    UNAUTHORIZED = 401,
    FORBIDDEN = 403,
    NOT_FOUND = 404,
    INTERNAL_SERVER_ERROR = 500,
    BAD_GATEWAY = 502,
    SERVICE_UNAVAILABLE = 503,
}

export enum EHTTP_STATUS_NAME {
    BAD_REQUEST = 'Bad Request',
    UNAUTHORIZED = 'Unauthorized',
    FORBIDDEN = 'Forbidden',
    NOT_FOUND = 'Not Found',
    INTERNAL_SERVER_ERROR = 'Internal Server Error',
    BAD_GATEWAY = 'Bad Gateway',
    SERVICE_UNAVAILABLE = 'Service Unavailable',
}"
`;

exports[`v3 should generate: ./test/generated/v3/core/OpenAPI.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
import type { ApiRequestOptions } from './ApiRequestOptions';

type Resolver<T> = (options: ApiRequestOptions) => Promise<T>;
type Headers = Record<string, string>;

export type OpenAPIConfig = {
    BASE: string;
    VERSION: string;
    WITH_CREDENTIALS: boolean;
    TOKEN?: string | Resolver<string>;
    USERNAME?: string | Resolver<string>;
    PASSWORD?: string | Resolver<string>;
    HEADERS?: Headers | Resolver<Headers>;
}

export const OpenAPI: OpenAPIConfig = {
    BASE: 'http://localhost:3000/base',
    VERSION: '1.0',
    WITH_CREDENTIALS: false,
    TOKEN: undefined,
    USERNAME: undefined,
    PASSWORD: undefined,
    HEADERS: undefined,
};"
`;

exports[`v3 should generate: ./test/generated/v3/core/request.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
import { ApiError } from './ApiError';
import type { ApiRequestOptions } from './ApiRequestOptions';
import type { ApiResult } from './ApiResult';
import { OpenAPI, OpenAPIConfig } from './OpenAPI';
import { EHTTP_STATUS_CODES, EHTTP_STATUS_NAME } from './HttpStatusCode';

function isDefined<T>(value: T | null | undefined): value is Exclude<T, null | undefined> {
    return value !== undefined && value !== null;
}

function isString(value: any): value is string {
    return typeof value === 'string';
}

function isStringWithValue(value: any): value is string {
    return isString(value) && value !== '';
}

function isBlob(value: any): value is Blob {
    return value instanceof Blob;
}

function getQueryString(params: Record<string, any>): string {
    const qs: string[] = [];
    Object.keys(params).forEach(key => {
        const value = params[key];
        if (isDefined(value)) {
            if (Array.isArray(value)) {
                value.forEach(value => {
                    qs.push(\`\${encodeURIComponent(key)}=\${encodeURIComponent(String(value))}\`);
                });
            } else {
                qs.push(\`\${encodeURIComponent(key)}=\${encodeURIComponent(String(value))}\`);
            }
        }
    });
    if (qs.length > 0) {
        return \`?\${qs.join('&')}\`;
    }
    return '';
}

function getUrl(config: OpenAPIConfig, options: ApiRequestOptions): string {
    const path = options.path
        .replace('{api-version}', config.VERSION)
        .replace(/[:]/g, '_');
    const url = \`\${config.BASE}\${path}\`;

    if (options.query) {
        return \`\${url}\${getQueryString(options.query)}\`;
    }
    return url;
}

function getFormData(params: Record<string, any>): FormData {
    const formData = new FormData();
    Object.keys(params).forEach(key => {
        const value = params[key];
        if (isDefined(value)) {
            formData.append(key, value);
        }
    });
    return formData;
}

type Resolver<T> = (options: ApiRequestOptions) => Promise<T>;

async function resolve<T>(options: ApiRequestOptions, resolver?: T | Resolver<T>): Promise<T | undefined> {
    if (typeof resolver === 'function') {
        return (resolver as Resolver<T>)(options);
    }
    return resolver;
}

async function getHeaders(config: OpenAPIConfig, options: ApiRequestOptions): Promise<Headers> {
    const token = await resolve(options, config.TOKEN);
    const username = await resolve(options, config.USERNAME);
    const password = await resolve(options, config.PASSWORD);
    const defaultHeaders = await resolve(options, config.HEADERS);

    const headers = new Headers({
        Accept: 'application/json',
        ...defaultHeaders,
        ...options.headers,
    });

    if (isStringWithValue(token)) {
        headers.append('Authorization', \`Bearer \${token}\`);
    }

    if (isStringWithValue(username) && isStringWithValue(password)) {
        const credentials = btoa(\`\${username}:\${password}\`);
        headers.append('Authorization', \`Basic \${credentials}\`);
    }

    if (options.body) {
        if (options.mediaType) {
            headers.append('Content-Type', options.mediaType);
        } else if (isBlob(options.body)) {
            headers.append('Content-Type', options.body.type || 'application/octet-stream');
        } else if (isString(options.body)) {
            headers.append('Content-Type', 'text/plain');
        } else {
            headers.append('Content-Type', 'application/json');
        }
    }
    return headers;
}

function getRequestBody(options: ApiRequestOptions): BodyInit | undefined {
    if (options.formData) {
        return getFormData(options.formData);
    }
    if (options.body) {
        if (options.mediaType?.includes('/json')) {
            return JSON.stringify(options.body)
        } else if (isString(options.body) || isBlob(options.body)) {
            return options.body;
        } else {
            return JSON.stringify(options.body);
        }
    }
    return undefined;
}

async function sendRequest(config: OpenAPIConfig, options: ApiRequestOptions, url: string): Promise<Response> {

    const request: RequestInit = {
        method: options.method,
        headers: await getHeaders(config, options),
        body: getRequestBody(options),
    };

    if (config.WITH_CREDENTIALS) {
        request.credentials = 'include';
    }


    return await fetch(url, request);
}

function getResponseHeader(response: Response, responseHeader?: string): string | null {
    if (responseHeader) {
        const content = response.headers.get(responseHeader);
        if (isString(content)) {
            return content;
        }
    }
    return null;
}

async function getResponseBody(response: Response): Promise<any> {
    try {
        const contentType = response.headers.get('Content-Type');
        if (contentType) {
            const isJSON = contentType.toLowerCase().startsWith('application/json');
            if (isJSON) {
                return await response.json();
            } else {
                return await response.text();
            }
        }
    } catch (error) {
        console.error(error);
    }
    return null;
}

function catchErrors(options: ApiRequestOptions, result: ApiResult): void {
    const errors: Record<string, string> = {
        [EHTTP_STATUS_CODES.BAD_GATEWAY]: EHTTP_STATUS_NAME.BAD_GATEWAY,
        [EHTTP_STATUS_CODES.BAD_REQUEST]: EHTTP_STATUS_NAME.BAD_REQUEST,
        [EHTTP_STATUS_CODES.FORBIDDEN]: EHTTP_STATUS_NAME.FORBIDDEN,
        [EHTTP_STATUS_CODES.INTERNAL_SERVER_ERROR]: EHTTP_STATUS_NAME.INTERNAL_SERVER_ERROR,
        [EHTTP_STATUS_CODES.NOT_FOUND]: EHTTP_STATUS_NAME.NOT_FOUND,
        [EHTTP_STATUS_CODES.SERVICE_UNAVAILABLE]: EHTTP_STATUS_NAME.SERVICE_UNAVAILABLE,
        [EHTTP_STATUS_CODES.UNAUTHORIZED]: EHTTP_STATUS_NAME.UNAUTHORIZED,
        ...options.errors,
    }

    const error = errors[result.status];
    if (error) {
        throw new ApiError(result, error);
    }

    if (!result.ok) {
        throw new ApiError(result, 'Generic Error');
    }
}

/**
 * Request using fetch client
 * @param config The OpenAPI configuration object
 * @param options The request options from the the service
 * @returns ApiResult
 * @throws ApiError
 */
export async function request<T>(config: OpenAPIConfig,options: ApiRequestOptions): Promise<T> {
    return new Promise(async (resolve, reject) => {
        try {
            const url = getUrl(config, options);
            const response = await sendRequest(config, options, url);
            const responseBody = await getResponseBody(response);
            const responseHeader = getResponseHeader(response, options.responseHeader);

            const result: ApiResult = {
                url,
                ok: response.ok,
                status: response.status,
                statusText: response.statusText,
                body: responseHeader || responseBody,
            };

            catchErrors(options, result);
            resolve(result.body);
        } catch (error) {
            reject(error);
        }
    });
}
"
`;

exports[`v3 should generate: ./test/generated/v3/index.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
export { ApiError } from '././core/ApiError';
export { OpenAPI } from '././core/OpenAPI';

export { EEnumWithNumbers } from '././models/EnumWithNumbers';
export { EEnumWithStrings } from '././models/EnumWithStrings';
export { EEnumWithStringsWithType } from '././models/EnumWithStringsWithType';
export type { IModelWithArray } from '././models/ModelWithArray';
export type { IModelWithDictionary } from '././models/ModelWithDictionary';
export { IModelWithEnum } from '././models/ModelWithEnum';
export type { IModelWithString } from '././models/ModelWithString';
export type { TArrayWithArray } from '././models/ArrayWithArray';
export type { TModelThatExtends } from '././models/ModelThatExtends';
export type { TModelThatExtendsExtends } from '././models/ModelThatExtendsExtends';

export { EEnumWithNumbersSchema } from '././schemas/EnumWithNumbersSchema';
export { EEnumWithStringsSchema } from '././schemas/EnumWithStringsSchema';
export { EEnumWithStringsWithTypeSchema } from '././schemas/EnumWithStringsWithTypeSchema';
export { IModelWithArraySchema } from '././schemas/ModelWithArraySchema';
export { IModelWithDictionarySchema } from '././schemas/ModelWithDictionarySchema';
export { IModelWithEnumSchema } from '././schemas/ModelWithEnumSchema';
export { IModelWithStringSchema } from '././schemas/ModelWithStringSchema';
export { TArrayWithArraySchema } from '././schemas/ArrayWithArraySchema';
export { TModelThatExtendsSchema } from '././schemas/ModelThatExtendsSchema';
export { TModelThatExtendsExtendsSchema } from '././schemas/ModelThatExtendsExtendsSchema';

export { SimpleService } from '././services/SimpleService';
export { ParametersService } from '././services/ParametersService';
export { RequestBodyService } from '././services/RequestBodyService';
export { DefaultsService } from '././services/DefaultsService';
export { DuplicateService } from '././services/DuplicateService';
export { NoContentService } from '././services/NoContentService';
export { ResponseService } from '././services/ResponseService';
export { CollectionFormatService } from '././services/CollectionFormatService';
export { TypesService } from '././services/TypesService';
export { UploadService } from '././services/UploadService';
export { ComplexService } from '././services/ComplexService';
export { MultipartService } from '././services/MultipartService';
export { HeaderService } from '././services/HeaderService';
export { EnumsService } from '././services/EnumsService';
"
`;

exports[`v3 should generate: ./test/generated/v3/models/ArrayWithArray.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */

import type { IModelWithString } from './ModelWithString';

/**
 * This is a simple array containing an array
 */
export type TArrayWithArray = Array<Array<IModelWithString>>;"
`;

exports[`v3 should generate: ./test/generated/v3/models/EnumWithNumbers.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */

/**
 * This is a simple enum with numbers
 */
export enum EEnumWithNumbers {
    '_1' = 1,
    '_2' = 2,
    '_3' = 3,
    '_1.1' = 1.1,
    '_1.2' = 1.2,
    '_1.3' = 1.3,
    '_100' = 100,
    '_200' = 200,
    '_300' = 300,
    '_-100' = -100,
    '_-200' = -200,
    '_-300' = -300,
    '_-1.1' = -1.1,
    '_-1.2' = -1.2,
    '_-1.3' = -1.3,
}"
`;

exports[`v3 should generate: ./test/generated/v3/models/EnumWithStrings.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */

/**
 * This is a simple enum with strings
 */
export enum EEnumWithStrings {
    SUCCESS = 'Success',
    WARNING = 'Warning',
    ERROR = 'Error',
}"
`;

exports[`v3 should generate: ./test/generated/v3/models/EnumWithStringsWithType.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */

/**
 * This is a simple enum with strings and type
 */
export enum EEnumWithStringsWithType {
    VALUE1 = 'VALUE1',
    VALUE2 = 'VALUE2',
}"
`;

exports[`v3 should generate: ./test/generated/v3/models/ModelThatExtends.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */

import type { IModelWithString } from './ModelWithString';

/**
 * This is a model that extends another model
 */
export type TModelThatExtends = (IModelWithString & {
    propExtendsA?: string,
    propExtendsB?: IModelWithString,
});
"
`;

exports[`v3 should generate: ./test/generated/v3/models/ModelThatExtendsExtends.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */

import type { TModelThatExtends } from './ModelThatExtends';
import type { IModelWithString } from './ModelWithString';

/**
 * This is a model that extends another model
 */
export type TModelThatExtendsExtends = (IModelWithString & TModelThatExtends & {
    propExtendsC?: string,
    propExtendsD?: IModelWithString,
});
"
`;

exports[`v3 should generate: ./test/generated/v3/models/ModelWithArray.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */

import type { IModelWithString } from './ModelWithString';

/**
 * This is a model with one property containing an array
 */
export interface IModelWithArray {
    prop?: Array<IModelWithString>;
    propWithFile?: Array<Blob>;
    propWithNumber?: Array<number>;
}
"
`;

exports[`v3 should generate: ./test/generated/v3/models/ModelWithDictionary.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */

/**
 * This is a model with one property containing a dictionary
 */
export interface IModelWithDictionary {
    prop?: Record<string, string>;
}
"
`;

exports[`v3 should generate: ./test/generated/v3/models/ModelWithEnum.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */

/**
 * This is a model with one enum
 */
export interface IModelWithEnum {
    /**
     * This is a simple enum with strings
     */
    test?: IModelWithEnum.ETest;
    /**
     * These are the HTTP error code enums
     */
    statusCode?: IModelWithEnum.EStatusCode;
    /**
     * Simple boolean enum
     */
    bool?: boolean;
}

export namespace IModelWithEnum {

    /**
     * This is a simple enum with strings
     */
    export enum ETest {
        SUCCESS = 'Success',
        WARNING = 'Warning',
        ERROR = 'Error',
    }

    /**
     * These are the HTTP error code enums
     */
    export enum EStatusCode {
        _100 = '100',
        _200_FOO = '200 FOO',
        _300_FOO_BAR = '300 FOO_BAR',
        _400_FOO_BAR = '400 foo-bar',
        _500_FOO_BAR = '500 foo.bar',
        _600_FOO_BAR = '600 foo&bar',
    }


}
"
`;

exports[`v3 should generate: ./test/generated/v3/models/ModelWithString.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */

/**
 * This is a model with one string property
 */
export interface IModelWithString {
    /**
     * This is a simple string property
     */
    prop?: string;
}
"
`;

exports[`v3 should generate: ./test/generated/v3/schemas/ArrayWithArraySchema.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
export const TArrayWithArraySchema = {
    type: 'array',
    contains: {
        type: 'array',
        contains: {
            type: 'IModelWithString',
        },
    },
};"
`;

exports[`v3 should generate: ./test/generated/v3/schemas/EnumWithNumbersSchema.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
export const EEnumWithNumbersSchema = {
    type: 'Enum',
};"
`;

exports[`v3 should generate: ./test/generated/v3/schemas/EnumWithStringsSchema.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
export const EEnumWithStringsSchema = {
    type: 'Enum',
};"
`;

exports[`v3 should generate: ./test/generated/v3/schemas/EnumWithStringsWithTypeSchema.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
export const EEnumWithStringsWithTypeSchema = {
    type: 'Enum',
};"
`;

exports[`v3 should generate: ./test/generated/v3/schemas/ModelThatExtendsExtendsSchema.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
export const TModelThatExtendsExtendsSchema = {
    type: 'all-of',
    contains: [{
        type: 'IModelWithString',
    }, {
        type: 'TModelThatExtends',
    }, {
        properties: {
            propExtendsC: {
                type: 'string',
            },
            propExtendsD: {
                type: 'IModelWithString',
            },
        },
    }],
};"
`;

exports[`v3 should generate: ./test/generated/v3/schemas/ModelThatExtendsSchema.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
export const TModelThatExtendsSchema = {
    type: 'all-of',
    contains: [{
        type: 'IModelWithString',
    }, {
        properties: {
            propExtendsA: {
                type: 'string',
            },
            propExtendsB: {
                type: 'IModelWithString',
            },
        },
    }],
};"
`;

exports[`v3 should generate: ./test/generated/v3/schemas/ModelWithArraySchema.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
export const IModelWithArraySchema = {
    properties: {
        prop: {
            type: 'array',
            contains: {
                type: 'IModelWithString',
            },
        },
        propWithFile: {
            type: 'array',
            contains: {
                type: 'File',
            },
        },
        propWithNumber: {
            type: 'array',
            contains: {
                type: 'number',
            },
        },
    },
};"
`;

exports[`v3 should generate: ./test/generated/v3/schemas/ModelWithDictionarySchema.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
export const IModelWithDictionarySchema = {
    properties: {
        prop: {
            type: 'dictionary',
            contains: {
                type: 'string',
            },
        },
    },
};"
`;

exports[`v3 should generate: ./test/generated/v3/schemas/ModelWithEnumSchema.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
export const IModelWithEnumSchema = {
    properties: {
        test: {
            type: 'Enum',
        },
        statusCode: {
            type: 'Enum',
        },
        bool: {
            type: 'boolean',
        },
    },
};"
`;

exports[`v3 should generate: ./test/generated/v3/schemas/ModelWithStringSchema.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
export const IModelWithStringSchema = {
    properties: {
        prop: {
            type: 'string',
        },
    },
};"
`;

exports[`v3 should generate: ./test/generated/v3/services/CollectionFormatService.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
import { request as __request } from './../core/request';
import type { ApiRequestOptions } from './../core/ApiRequestOptions';
import { OpenAPI } from './../core/OpenAPI';

const collectionFormat = (
    parameterArrayCsv: Array<string> | null,
    parameterArraySsv: Array<string> | null,
    parameterArrayTsv: Array<string> | null,
    parameterArrayPipes: Array<string> | null,
    parameterArrayMulti: Array<string> | null,
): ApiRequestOptions => ({
    method: 'GET',
    path: \`/api/v{api-version}/collectionFormat\`,
    query: {
        'parameterArrayCSV': parameterArrayCsv,
        'parameterArraySSV': parameterArraySsv,
        'parameterArrayTSV': parameterArrayTsv,
        'parameterArrayPipes': parameterArrayPipes,
        'parameterArrayMulti': parameterArrayMulti,
    },
});


export type TCollectionFormatOptions = {
    collectionFormat: (
        parameterArrayCsv: Array<string> | null,
        parameterArraySsv: Array<string> | null,
        parameterArrayTsv: Array<string> | null,
        parameterArrayPipes: Array<string> | null,
        parameterArrayMulti: Array<string> | null,
    ) => ApiRequestOptions;
}

export const CollectionFormatOptions: TCollectionFormatOptions = {
    collectionFormat: collectionFormat,
}

export class CollectionFormatService {

    /**
     * @param parameterArrayCsv This is an array parameter that is send as csv format (comma-separated values)
     * @param parameterArraySsv This is an array parameter that is send as ssv format (space-separated values)
     * @param parameterArrayTsv This is an array parameter that is send as tsv format (tab-separated values)
     * @param parameterArrayPipes This is an array parameter that is send as pipes format (pipe-separated values)
     * @param parameterArrayMulti This is an array parameter that is send as multi format (multiple parameter instances)
     * @throws ApiError
     */
    public static collectionFormat(
        parameterArrayCsv: Array<string> | null,
        parameterArraySsv: Array<string> | null,
        parameterArrayTsv: Array<string> | null,
        parameterArrayPipes: Array<string> | null,
        parameterArrayMulti: Array<string> | null,
    ): Promise<void> {
        return __request<void>(OpenAPI, CollectionFormatOptions.collectionFormat(
            parameterArrayCsv,
            parameterArraySsv,
            parameterArrayTsv,
            parameterArrayPipes,
            parameterArrayMulti,
        ));
    }
}"
`;

exports[`v3 should generate: ./test/generated/v3/services/ComplexService.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
import type { IModelWithArray } from './../models/ModelWithArray';
import type { IModelWithDictionary } from './../models/ModelWithDictionary';
import type { IModelWithEnum } from './../models/ModelWithEnum';
import type { IModelWithString } from './../models/ModelWithString';
import { request as __request } from './../core/request';
import type { ApiRequestOptions } from './../core/ApiRequestOptions';
import { OpenAPI } from './../core/OpenAPI';

const complexTypes = (
    parameterObject: {
        first?: {
            second?: {
                third?: string,
            },
        },
    },
    parameterReference: IModelWithString,
): ApiRequestOptions => ({
    method: 'GET',
    path: \`/api/v{api-version}/complex\`,
    query: {
        'parameterObject': parameterObject,
        'parameterReference': parameterReference,
    },
    errors: {
        400: \`400 server error\`,
        500: \`500 server error\`,
    },
});

const complexParams = (
    id: number,
    requestBody?: {
        readonly key: string | null,
        name: string | null,
        enabled: boolean,
        readonly type: 'Monkey' | 'Horse' | 'Bird',
        listOfModels?: Array<IModelWithString> | null,
        listOfStrings?: Array<string> | null,
        parameters: (IModelWithString | IModelWithEnum | IModelWithArray | IModelWithDictionary),
        readonly user?: {
            readonly id?: number,
            readonly name?: string | null,
        },
    },
): ApiRequestOptions => ({
    method: 'PUT',
    path: \`/api/v{api-version}/complex/\${id}\`,
    body: requestBody,
    mediaType: 'application/json-patch+json',
});


export type TComplexOptions = {
    complexTypes: (
        parameterObject: {
            first?: {
                second?: {
                    third?: string,
                },
            },
        },
        parameterReference: IModelWithString,
    ) => ApiRequestOptions;
    complexParams: (
        id: number,
        requestBody?: {
            readonly key: string | null,
            name: string | null,
            enabled: boolean,
            readonly type: 'Monkey' | 'Horse' | 'Bird',
            listOfModels?: Array<IModelWithString> | null,
            listOfStrings?: Array<string> | null,
            parameters: (IModelWithString | IModelWithEnum | IModelWithArray | IModelWithDictionary),
            readonly user?: {
                readonly id?: number,
                readonly name?: string | null,
            },
        },
    ) => ApiRequestOptions;
}

export const ComplexOptions: TComplexOptions = {
    complexTypes: complexTypes,
    complexParams: complexParams,
}

export class ComplexService {

    /**
     * @param parameterObject Parameter containing object
     * @param parameterReference Parameter containing reference
     * @returns IModelWithString Successful response
     * @throws ApiError
     */
    public static complexTypes(
        parameterObject: {
            first?: {
                second?: {
                    third?: string,
                },
            },
        },
        parameterReference: IModelWithString,
    ): Promise<Array<IModelWithString>> {
        return __request<Array<IModelWithString>>(OpenAPI, ComplexOptions.complexTypes(
            parameterObject,
            parameterReference,
        ));
    }
    /**
     * @param id
     * @param requestBody
     * @returns IModelWithString Success
     * @throws ApiError
     */
    public static complexParams(
        id: number,
        requestBody?: {
            readonly key: string | null,
            name: string | null,
            enabled: boolean,
            readonly type: 'Monkey' | 'Horse' | 'Bird',
            listOfModels?: Array<IModelWithString> | null,
            listOfStrings?: Array<string> | null,
            parameters: (IModelWithString | IModelWithEnum | IModelWithArray | IModelWithDictionary),
            readonly user?: {
                readonly id?: number,
                readonly name?: string | null,
            },
        },
    ): Promise<IModelWithString> {
        return __request<IModelWithString>(OpenAPI, ComplexOptions.complexParams(
            id,
            requestBody,
        ));
    }
}"
`;

exports[`v3 should generate: ./test/generated/v3/services/DefaultsService.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
import type { IModelWithString } from './../models/ModelWithString';
import { request as __request } from './../core/request';
import type { ApiRequestOptions } from './../core/ApiRequestOptions';
import { OpenAPI } from './../core/OpenAPI';

const callWithDefaultParameters = (
    parameterString: string | null = 'Hello World!',
    parameterNumber: number | null = 123,
    parameterBoolean: boolean | null = true,
    parameterEnum: 'Success' | 'Warning' | 'Error' = 'Success',
    parameterModel: IModelWithString | null = {
        \\"prop\\": \\"Hello World!\\"
    },
): ApiRequestOptions => ({
    method: 'GET',
    path: \`/api/v{api-version}/defaults\`,
    query: {
        'parameterString': parameterString,
        'parameterNumber': parameterNumber,
        'parameterBoolean': parameterBoolean,
        'parameterEnum': parameterEnum,
        'parameterModel': parameterModel,
    },
});

const callWithDefaultOptionalParameters = (
    parameterString: string = 'Hello World!',
    parameterNumber: number = 123,
    parameterBoolean: boolean = true,
    parameterEnum: 'Success' | 'Warning' | 'Error' = 'Success',
    parameterModel: IModelWithString = {
        \\"prop\\": \\"Hello World!\\"
    },
): ApiRequestOptions => ({
    method: 'POST',
    path: \`/api/v{api-version}/defaults\`,
    query: {
        'parameterString': parameterString,
        'parameterNumber': parameterNumber,
        'parameterBoolean': parameterBoolean,
        'parameterEnum': parameterEnum,
        'parameterModel': parameterModel,
    },
});

const callToTestOrderOfParams = (
    parameterStringWithNoDefault: string,
    parameterOptionalStringWithDefault: string = 'Hello World!',
    parameterOptionalStringWithEmptyDefault: string = '',
    parameterStringWithDefault: string = 'Hello World!',
    parameterStringWithEmptyDefault: string = '',
    parameterOptionalStringWithNoDefault?: string,
): ApiRequestOptions => ({
    method: 'PUT',
    path: \`/api/v{api-version}/defaults\`,
    query: {
        'parameterStringWithNoDefault': parameterStringWithNoDefault,
        'parameterOptionalStringWithDefault': parameterOptionalStringWithDefault,
        'parameterOptionalStringWithEmptyDefault': parameterOptionalStringWithEmptyDefault,
        'parameterStringWithDefault': parameterStringWithDefault,
        'parameterStringWithEmptyDefault': parameterStringWithEmptyDefault,
        'parameterOptionalStringWithNoDefault': parameterOptionalStringWithNoDefault,
    },
});


export type TDefaultsOptions = {
    callWithDefaultParameters: (
        parameterString: string | null,
        parameterNumber: number | null,
        parameterBoolean: boolean | null,
        parameterEnum: 'Success' | 'Warning' | 'Error',
        parameterModel: IModelWithString | null,
    ) => ApiRequestOptions;
    callWithDefaultOptionalParameters: (
        parameterString: string,
        parameterNumber: number,
        parameterBoolean: boolean,
        parameterEnum: 'Success' | 'Warning' | 'Error',
        parameterModel: IModelWithString,
    ) => ApiRequestOptions;
    callToTestOrderOfParams: (
        parameterStringWithNoDefault: string,
        parameterOptionalStringWithDefault: string,
        parameterOptionalStringWithEmptyDefault: string,
        parameterStringWithDefault: string,
        parameterStringWithEmptyDefault: string,
        parameterOptionalStringWithNoDefault?: string,
    ) => ApiRequestOptions;
}

export const DefaultsOptions: TDefaultsOptions = {
    callWithDefaultParameters: callWithDefaultParameters,
    callWithDefaultOptionalParameters: callWithDefaultOptionalParameters,
    callToTestOrderOfParams: callToTestOrderOfParams,
}

export class DefaultsService {

    /**
     * @param parameterString This is a simple string with default value
     * @param parameterNumber This is a simple number with default value
     * @param parameterBoolean This is a simple boolean with default value
     * @param parameterEnum This is a simple enum with default value
     * @param parameterModel This is a simple model with default value
     * @throws ApiError
     */
    public static callWithDefaultParameters(
        parameterString: string | null = 'Hello World!',
        parameterNumber: number | null = 123,
        parameterBoolean: boolean | null = true,
        parameterEnum: 'Success' | 'Warning' | 'Error' = 'Success',
        parameterModel: IModelWithString | null = {
            \\"prop\\": \\"Hello World!\\"
        },
    ): Promise<void> {
        return __request<void>(OpenAPI, DefaultsOptions.callWithDefaultParameters(
            parameterString,
            parameterNumber,
            parameterBoolean,
            parameterEnum,
            parameterModel,
        ));
    }
    /**
     * @param parameterString This is a simple string that is optional with default value
     * @param parameterNumber This is a simple number that is optional with default value
     * @param parameterBoolean This is a simple boolean that is optional with default value
     * @param parameterEnum This is a simple enum that is optional with default value
     * @param parameterModel This is a simple model that is optional with default value
     * @throws ApiError
     */
    public static callWithDefaultOptionalParameters(
        parameterString: string = 'Hello World!',
        parameterNumber: number = 123,
        parameterBoolean: boolean = true,
        parameterEnum: 'Success' | 'Warning' | 'Error' = 'Success',
        parameterModel: IModelWithString = {
            \\"prop\\": \\"Hello World!\\"
        },
    ): Promise<void> {
        return __request<void>(OpenAPI, DefaultsOptions.callWithDefaultOptionalParameters(
            parameterString,
            parameterNumber,
            parameterBoolean,
            parameterEnum,
            parameterModel,
        ));
    }
    /**
     * @param parameterStringWithNoDefault This is a string with no default
     * @param parameterOptionalStringWithDefault This is a optional string with default
     * @param parameterOptionalStringWithEmptyDefault This is a optional string with empty default
     * @param parameterStringWithDefault This is a string with default
     * @param parameterStringWithEmptyDefault This is a string with empty default
     * @param parameterOptionalStringWithNoDefault This is a optional string with no default
     * @throws ApiError
     */
    public static callToTestOrderOfParams(
        parameterStringWithNoDefault: string,
        parameterOptionalStringWithDefault: string = 'Hello World!',
        parameterOptionalStringWithEmptyDefault: string = '',
        parameterStringWithDefault: string = 'Hello World!',
        parameterStringWithEmptyDefault: string = '',
        parameterOptionalStringWithNoDefault?: string,
    ): Promise<void> {
        return __request<void>(OpenAPI, DefaultsOptions.callToTestOrderOfParams(
            parameterStringWithNoDefault,
            parameterOptionalStringWithDefault,
            parameterOptionalStringWithEmptyDefault,
            parameterStringWithDefault,
            parameterStringWithEmptyDefault,
            parameterOptionalStringWithNoDefault,
        ));
    }
}"
`;

exports[`v3 should generate: ./test/generated/v3/services/DuplicateService.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
import { request as __request } from './../core/request';
import type { ApiRequestOptions } from './../core/ApiRequestOptions';
import { OpenAPI } from './../core/OpenAPI';

const duplicateName = (): ApiRequestOptions => ({
    method: 'GET',
    path: \`/api/v{api-version}/duplicate\`,
});

const duplicateName1 = (): ApiRequestOptions => ({
    method: 'POST',
    path: \`/api/v{api-version}/duplicate\`,
});

const duplicateName2 = (): ApiRequestOptions => ({
    method: 'PUT',
    path: \`/api/v{api-version}/duplicate\`,
});

const duplicateName3 = (): ApiRequestOptions => ({
    method: 'DELETE',
    path: \`/api/v{api-version}/duplicate\`,
});


export type TDuplicateOptions = {
    duplicateName: () => ApiRequestOptions;
    duplicateName1: () => ApiRequestOptions;
    duplicateName2: () => ApiRequestOptions;
    duplicateName3: () => ApiRequestOptions;
}

export const DuplicateOptions: TDuplicateOptions = {
    duplicateName: duplicateName,
    duplicateName1: duplicateName1,
    duplicateName2: duplicateName2,
    duplicateName3: duplicateName3,
}

export class DuplicateService {

    /**
     * @throws ApiError
     */
    public static duplicateName(): Promise<void> {
        return __request<void>(OpenAPI, DuplicateOptions.duplicateName());
    }
    /**
     * @throws ApiError
     */
    public static duplicateName1(): Promise<void> {
        return __request<void>(OpenAPI, DuplicateOptions.duplicateName1());
    }
    /**
     * @throws ApiError
     */
    public static duplicateName2(): Promise<void> {
        return __request<void>(OpenAPI, DuplicateOptions.duplicateName2());
    }
    /**
     * @throws ApiError
     */
    public static duplicateName3(): Promise<void> {
        return __request<void>(OpenAPI, DuplicateOptions.duplicateName3());
    }
}"
`;

exports[`v3 should generate: ./test/generated/v3/services/EnumsService.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
import { request as __request } from './../core/request';
import type { ApiRequestOptions } from './../core/ApiRequestOptions';
import { OpenAPI } from './../core/OpenAPI';

const callWithEnums = (
    requestBody?: any,
): ApiRequestOptions => ({
    method: 'POST',
    path: \`/api/v{api-version}/enums\`,
    body: requestBody,
});


export type TEnumsOptions = {
    callWithEnums: (
        requestBody?: any,
    ) => ApiRequestOptions;
}

export const EnumsOptions: TEnumsOptions = {
    callWithEnums: callWithEnums,
}

export class EnumsService {

    /**
     * @param requestBody
     * @throws ApiError
     */
    public static callWithEnums(
        requestBody?: any,
    ): Promise<void> {
        return __request<void>(OpenAPI, EnumsOptions.callWithEnums(
            requestBody,
        ));
    }
}"
`;

exports[`v3 should generate: ./test/generated/v3/services/HeaderService.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
import { request as __request } from './../core/request';
import type { ApiRequestOptions } from './../core/ApiRequestOptions';
import { OpenAPI } from './../core/OpenAPI';

const callWithResultFromHeader = (): ApiRequestOptions => ({
    method: 'POST',
    path: \`/api/v{api-version}/header\`,
    responseHeader: 'operation-location',
    errors: {
        400: \`400 server error\`,
        500: \`500 server error\`,
    },
});


export type THeaderOptions = {
    callWithResultFromHeader: () => ApiRequestOptions;
}

export const HeaderOptions: THeaderOptions = {
    callWithResultFromHeader: callWithResultFromHeader,
}

export class HeaderService {

    /**
     * @returns string Successful response
     * @throws ApiError
     */
    public static callWithResultFromHeader(): Promise<string> {
        return __request<string>(OpenAPI, HeaderOptions.callWithResultFromHeader());
    }
}"
`;

exports[`v3 should generate: ./test/generated/v3/services/MultipartService.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
import { request as __request } from './../core/request';
import type { ApiRequestOptions } from './../core/ApiRequestOptions';
import { OpenAPI } from './../core/OpenAPI';

const multipartResponse = (): ApiRequestOptions => ({
    method: 'GET',
    path: \`/api/v{api-version}/multipart\`,
});


export type TMultipartOptions = {
    multipartResponse: () => ApiRequestOptions;
}

export const MultipartOptions: TMultipartOptions = {
    multipartResponse: multipartResponse,
}

export class MultipartService {

    /**
     * @returns any OK
     * @throws ApiError
     */
    public static multipartResponse(): Promise<{
        file?: string,
        metadata?: {
            foo?: string,
            bar?: string,
        },
    }> {
        return __request<{
            file?: string,
            metadata?: {
                foo?: string,
                bar?: string,
            },
        }>(OpenAPI, MultipartOptions.multipartResponse());
    }
}"
`;

exports[`v3 should generate: ./test/generated/v3/services/NoContentService.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
import { request as __request } from './../core/request';
import type { ApiRequestOptions } from './../core/ApiRequestOptions';
import { OpenAPI } from './../core/OpenAPI';

const callWithNoContentResponse = (): ApiRequestOptions => ({
    method: 'GET',
    path: \`/api/v{api-version}/no-content\`,
});


export type TNoContentOptions = {
    callWithNoContentResponse: () => ApiRequestOptions;
}

export const NoContentOptions: TNoContentOptions = {
    callWithNoContentResponse: callWithNoContentResponse,
}

export class NoContentService {

    /**
     * @returns void
     * @throws ApiError
     */
    public static callWithNoContentResponse(): Promise<void> {
        return __request<void>(OpenAPI, NoContentOptions.callWithNoContentResponse());
    }
}"
`;

exports[`v3 should generate: ./test/generated/v3/services/ParametersService.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
import type { IModelWithString } from './../models/ModelWithString';
import { request as __request } from './../core/request';
import type { ApiRequestOptions } from './../core/ApiRequestOptions';
import { OpenAPI } from './../core/OpenAPI';

const callWithParameters = (
    parameterHeader: string | null,
    parameterQuery: string | null,
    parameterForm: string | null,
    parameterCookie: string | null,
    parameterPath: string | null,
    requestBody: IModelWithString | null,
): ApiRequestOptions => ({
    method: 'GET',
    path: \`/api/v{api-version}/parameters/\${parameterPath}\`,
    cookies: {
        'parameterCookie': parameterCookie,
    },
    headers: {
        'parameterHeader': parameterHeader,
    },
    query: {
        'parameterQuery': parameterQuery,
    },
    formData: {
        'parameterForm': parameterForm,
    },
    body: requestBody,
    mediaType: 'application/json',
});

const callWithWeirdParameterNames = (
    parameterHeader: string | null,
    parameterQuery: string | null,
    parameterForm: string | null,
    parameterCookie: string | null,
    requestBody: IModelWithString | null,
    parameterPath1?: string,
    parameterPath2?: string,
    parameterPath3?: string,
    _default?: string,
): ApiRequestOptions => ({
    method: 'GET',
    path: \`/api/v{api-version}/parameters/\${parameterPath1}/\${parameterPath2}/\${parameterPath3}\`,
    cookies: {
        'PARAMETER-COOKIE': parameterCookie,
    },
    headers: {
        'parameter.header': parameterHeader,
    },
    query: {
        'parameter-query': parameterQuery,
        'default': _default,
    },
    formData: {
        'parameter_form': parameterForm,
    },
    body: requestBody,
    mediaType: 'application/json',
});

const getCallWithOptionalParam = (
    requestBody: IModelWithString,
    parameter?: string,
): ApiRequestOptions => ({
    method: 'GET',
    path: \`/api/v{api-version}/parameters/\`,
    query: {
        'parameter': parameter,
    },
    body: requestBody,
    mediaType: 'application/json',
});

const postCallWithOptionalParam = (
    parameter: string,
    requestBody?: IModelWithString,
): ApiRequestOptions => ({
    method: 'POST',
    path: \`/api/v{api-version}/parameters/\`,
    query: {
        'parameter': parameter,
    },
    body: requestBody,
    mediaType: 'application/json',
});


export type TParametersOptions = {
    callWithParameters: (
        parameterHeader: string | null,
        parameterQuery: string | null,
        parameterForm: string | null,
        parameterCookie: string | null,
        parameterPath: string | null,
        requestBody: IModelWithString | null,
    ) => ApiRequestOptions;
    callWithWeirdParameterNames: (
        parameterHeader: string | null,
        parameterQuery: string | null,
        parameterForm: string | null,
        parameterCookie: string | null,
        requestBody: IModelWithString | null,
        parameterPath1?: string,
        parameterPath2?: string,
        parameterPath3?: string,
        _default?: string,
    ) => ApiRequestOptions;
    getCallWithOptionalParam: (
        requestBody: IModelWithString,
        parameter?: string,
    ) => ApiRequestOptions;
    postCallWithOptionalParam: (
        parameter: string,
        requestBody?: IModelWithString,
    ) => ApiRequestOptions;
}

export const ParametersOptions: TParametersOptions = {
    callWithParameters: callWithParameters,
    callWithWeirdParameterNames: callWithWeirdParameterNames,
    getCallWithOptionalParam: getCallWithOptionalParam,
    postCallWithOptionalParam: postCallWithOptionalParam,
}

export class ParametersService {

    /**
     * @param parameterHeader This is the parameter that goes into the header
     * @param parameterQuery This is the parameter that goes into the query params
     * @param parameterForm This is the parameter that goes into the form data
     * @param parameterCookie This is the parameter that goes into the cookie
     * @param parameterPath This is the parameter that goes into the path
     * @param requestBody This is the parameter that goes into the body
     * @throws ApiError
     */
    public static callWithParameters(
        parameterHeader: string | null,
        parameterQuery: string | null,
        parameterForm: string | null,
        parameterCookie: string | null,
        parameterPath: string | null,
        requestBody: IModelWithString | null,
    ): Promise<void> {
        return __request<void>(OpenAPI, ParametersOptions.callWithParameters(
            parameterHeader,
            parameterQuery,
            parameterForm,
            parameterCookie,
            parameterPath,
            requestBody,
        ));
    }
    /**
     * @param parameterHeader This is the parameter that goes into the request header
     * @param parameterQuery This is the parameter that goes into the request query params
     * @param parameterForm This is the parameter that goes into the request form data
     * @param parameterCookie This is the parameter that goes into the cookie
     * @param requestBody This is the parameter that goes into the body
     * @param parameterPath1 This is the parameter that goes into the path
     * @param parameterPath2 This is the parameter that goes into the path
     * @param parameterPath3 This is the parameter that goes into the path
     * @param _default This is the parameter with a reserved keyword
     * @throws ApiError
     */
    public static callWithWeirdParameterNames(
        parameterHeader: string | null,
        parameterQuery: string | null,
        parameterForm: string | null,
        parameterCookie: string | null,
        requestBody: IModelWithString | null,
        parameterPath1?: string,
        parameterPath2?: string,
        parameterPath3?: string,
        _default?: string,
    ): Promise<void> {
        return __request<void>(OpenAPI, ParametersOptions.callWithWeirdParameterNames(
            parameterHeader,
            parameterQuery,
            parameterForm,
            parameterCookie,
            requestBody,
            parameterPath1,
            parameterPath2,
            parameterPath3,
            _default,
        ));
    }
    /**
     * @param requestBody This is a required parameter
     * @param parameter This is an optional parameter
     * @throws ApiError
     */
    public static getCallWithOptionalParam(
        requestBody: IModelWithString,
        parameter?: string,
    ): Promise<void> {
        return __request<void>(OpenAPI, ParametersOptions.getCallWithOptionalParam(
            requestBody,
            parameter,
        ));
    }
    /**
     * @param parameter This is a required parameter
     * @param requestBody This is an optional parameter
     * @throws ApiError
     */
    public static postCallWithOptionalParam(
        parameter: string,
        requestBody?: IModelWithString,
    ): Promise<void> {
        return __request<void>(OpenAPI, ParametersOptions.postCallWithOptionalParam(
            parameter,
            requestBody,
        ));
    }
}"
`;

exports[`v3 should generate: ./test/generated/v3/services/RequestBodyService.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
import type { IModelWithString } from './../models/ModelWithString';
import { request as __request } from './../core/request';
import type { ApiRequestOptions } from './../core/ApiRequestOptions';
import { OpenAPI } from './../core/OpenAPI';

const postRequestBodyService = (
    requestBody?: IModelWithString,
): ApiRequestOptions => ({
    method: 'POST',
    path: \`/api/v{api-version}/requestBody/\`,
    body: requestBody,
    mediaType: 'application/json',
});


export type TRequestBodyOptions = {
    postRequestBodyService: (
        requestBody?: IModelWithString,
    ) => ApiRequestOptions;
}

export const RequestBodyOptions: TRequestBodyOptions = {
    postRequestBodyService: postRequestBodyService,
}

export class RequestBodyService {

    /**
     * @param requestBody A reusable request body
     * @throws ApiError
     */
    public static postRequestBodyService(
        requestBody?: IModelWithString,
    ): Promise<void> {
        return __request<void>(OpenAPI, RequestBodyOptions.postRequestBodyService(
            requestBody,
        ));
    }
}"
`;

exports[`v3 should generate: ./test/generated/v3/services/ResponseService.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
import type { TModelThatExtendsExtends } from './../models/ModelThatExtendsExtends';
import type { TModelThatExtends } from './../models/ModelThatExtends';
import type { IModelWithString } from './../models/ModelWithString';
import { request as __request } from './../core/request';
import type { ApiRequestOptions } from './../core/ApiRequestOptions';
import { OpenAPI } from './../core/OpenAPI';

const callWithResponse = (): ApiRequestOptions => ({
    method: 'GET',
    path: \`/api/v{api-version}/response\`,
});

const callWithDuplicateResponses = (): ApiRequestOptions => ({
    method: 'POST',
    path: \`/api/v{api-version}/response\`,
    errors: {
        500: \`Message for 500 error\`,
        501: \`Message for 501 error\`,
        502: \`Message for 502 error\`,
    },
});

const callWithResponses = (): ApiRequestOptions => ({
    method: 'PUT',
    path: \`/api/v{api-version}/response\`,
    errors: {
        500: \`Message for 500 error\`,
        501: \`Message for 501 error\`,
        502: \`Message for 502 error\`,
    },
});


export type TResponseOptions = {
    callWithResponse: () => ApiRequestOptions;
    callWithDuplicateResponses: () => ApiRequestOptions;
    callWithResponses: () => ApiRequestOptions;
}

export const ResponseOptions: TResponseOptions = {
    callWithResponse: callWithResponse,
    callWithDuplicateResponses: callWithDuplicateResponses,
    callWithResponses: callWithResponses,
}

export class ResponseService {

    /**
     * @returns IModelWithString
     * @throws ApiError
     */
    public static callWithResponse(): Promise<IModelWithString> {
        return __request<IModelWithString>(OpenAPI, ResponseOptions.callWithResponse());
    }
    /**
     * @returns IModelWithString Message for default response
     * @throws ApiError
     */
    public static callWithDuplicateResponses(): Promise<IModelWithString> {
        return __request<IModelWithString>(OpenAPI, ResponseOptions.callWithDuplicateResponses());
    }
    /**
     * @returns any Message for 200 response
     * @returns IModelWithString Message for default response
     * @returns TModelThatExtends Message for 201 response
     * @returns TModelThatExtendsExtends Message for 202 response
     * @throws ApiError
     */
    public static callWithResponses(): Promise<{
        readonly '@namespace.string'?: string,
        readonly '@namespace.integer'?: number,
        readonly value?: Array<IModelWithString>,
    } | IModelWithString | TModelThatExtends | TModelThatExtendsExtends> {
        return __request<{
            readonly '@namespace.string'?: string,
            readonly '@namespace.integer'?: number,
            readonly value?: Array<IModelWithString>,
        } | IModelWithString | TModelThatExtends | TModelThatExtendsExtends>(OpenAPI, ResponseOptions.callWithResponses());
    }
}"
`;

exports[`v3 should generate: ./test/generated/v3/services/SimpleService.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
import { request as __request } from './../core/request';
import type { ApiRequestOptions } from './../core/ApiRequestOptions';
import { OpenAPI } from './../core/OpenAPI';

const getCallWithoutParametersAndResponse = (): ApiRequestOptions => ({
    method: 'GET',
    path: \`/api/v{api-version}/simple\`,
});

const putCallWithoutParametersAndResponse = (): ApiRequestOptions => ({
    method: 'PUT',
    path: \`/api/v{api-version}/simple\`,
});

const postCallWithoutParametersAndResponse = (): ApiRequestOptions => ({
    method: 'POST',
    path: \`/api/v{api-version}/simple\`,
});

const deleteCallWithoutParametersAndResponse = (): ApiRequestOptions => ({
    method: 'DELETE',
    path: \`/api/v{api-version}/simple\`,
});

const optionsCallWithoutParametersAndResponse = (): ApiRequestOptions => ({
    method: 'OPTIONS',
    path: \`/api/v{api-version}/simple\`,
});

const headCallWithoutParametersAndResponse = (): ApiRequestOptions => ({
    method: 'HEAD',
    path: \`/api/v{api-version}/simple\`,
});

const patchCallWithoutParametersAndResponse = (): ApiRequestOptions => ({
    method: 'PATCH',
    path: \`/api/v{api-version}/simple\`,
});


export type TSimpleOptions = {
    getCallWithoutParametersAndResponse: () => ApiRequestOptions;
    putCallWithoutParametersAndResponse: () => ApiRequestOptions;
    postCallWithoutParametersAndResponse: () => ApiRequestOptions;
    deleteCallWithoutParametersAndResponse: () => ApiRequestOptions;
    optionsCallWithoutParametersAndResponse: () => ApiRequestOptions;
    headCallWithoutParametersAndResponse: () => ApiRequestOptions;
    patchCallWithoutParametersAndResponse: () => ApiRequestOptions;
}

export const SimpleOptions: TSimpleOptions = {
    getCallWithoutParametersAndResponse: getCallWithoutParametersAndResponse,
    putCallWithoutParametersAndResponse: putCallWithoutParametersAndResponse,
    postCallWithoutParametersAndResponse: postCallWithoutParametersAndResponse,
    deleteCallWithoutParametersAndResponse: deleteCallWithoutParametersAndResponse,
    optionsCallWithoutParametersAndResponse: optionsCallWithoutParametersAndResponse,
    headCallWithoutParametersAndResponse: headCallWithoutParametersAndResponse,
    patchCallWithoutParametersAndResponse: patchCallWithoutParametersAndResponse,
}

export class SimpleService {

    /**
     * @throws ApiError
     */
    public static getCallWithoutParametersAndResponse(): Promise<void> {
        return __request<void>(OpenAPI, SimpleOptions.getCallWithoutParametersAndResponse());
    }
    /**
     * @throws ApiError
     */
    public static putCallWithoutParametersAndResponse(): Promise<void> {
        return __request<void>(OpenAPI, SimpleOptions.putCallWithoutParametersAndResponse());
    }
    /**
     * @throws ApiError
     */
    public static postCallWithoutParametersAndResponse(): Promise<void> {
        return __request<void>(OpenAPI, SimpleOptions.postCallWithoutParametersAndResponse());
    }
    /**
     * @throws ApiError
     */
    public static deleteCallWithoutParametersAndResponse(): Promise<void> {
        return __request<void>(OpenAPI, SimpleOptions.deleteCallWithoutParametersAndResponse());
    }
    /**
     * @throws ApiError
     */
    public static optionsCallWithoutParametersAndResponse(): Promise<void> {
        return __request<void>(OpenAPI, SimpleOptions.optionsCallWithoutParametersAndResponse());
    }
    /**
     * @throws ApiError
     */
    public static headCallWithoutParametersAndResponse(): Promise<void> {
        return __request<void>(OpenAPI, SimpleOptions.headCallWithoutParametersAndResponse());
    }
    /**
     * @throws ApiError
     */
    public static patchCallWithoutParametersAndResponse(): Promise<void> {
        return __request<void>(OpenAPI, SimpleOptions.patchCallWithoutParametersAndResponse());
    }
}"
`;

exports[`v3 should generate: ./test/generated/v3/services/TypesService.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
import { request as __request } from './../core/request';
import type { ApiRequestOptions } from './../core/ApiRequestOptions';
import { OpenAPI } from './../core/OpenAPI';

const types = (
    parameterArray: Array<string> | null,
    parameterDictionary: any,
    parameterEnum: 'Success' | 'Warning' | 'Error' | null,
    parameterNumber: number = 123,
    parameterString: string | null = 'default',
    parameterBoolean: boolean | null = true,
    parameterObject: any = null,
    id?: number,
): ApiRequestOptions => ({
    method: 'GET',
    path: \`/api/v{api-version}/types\`,
    query: {
        'parameterArray': parameterArray,
        'parameterDictionary': parameterDictionary,
        'parameterEnum': parameterEnum,
        'parameterNumber': parameterNumber,
        'parameterString': parameterString,
        'parameterBoolean': parameterBoolean,
        'parameterObject': parameterObject,
    },
});


export type TTypesOptions = {
    types: (
        parameterArray: Array<string> | null,
        parameterDictionary: any,
        parameterEnum: 'Success' | 'Warning' | 'Error' | null,
        parameterNumber: number,
        parameterString: string | null,
        parameterBoolean: boolean | null,
        parameterObject: any,
        id?: number,
    ) => ApiRequestOptions;
}

export const TypesOptions: TTypesOptions = {
    types: types,
}

export class TypesService {

    /**
     * @param parameterArray This is an array parameter
     * @param parameterDictionary This is a dictionary parameter
     * @param parameterEnum This is an enum parameter
     * @param parameterNumber This is a number parameter
     * @param parameterString This is a string parameter
     * @param parameterBoolean This is a boolean parameter
     * @param parameterObject This is an object parameter
     * @param id This is a number parameter
     * @returns number Response is a simple number
     * @returns string Response is a simple string
     * @returns boolean Response is a simple boolean
     * @returns any Response is a simple object
     * @throws ApiError
     */
    public static types(
        parameterArray: Array<string> | null,
        parameterDictionary: any,
        parameterEnum: 'Success' | 'Warning' | 'Error' | null,
        parameterNumber: number = 123,
        parameterString: string | null = 'default',
        parameterBoolean: boolean | null = true,
        parameterObject: any = null,
        id?: number,
    ): Promise<number | string | boolean | any> {
        return __request<number | string | boolean | any>(OpenAPI, TypesOptions.types(
            parameterArray,
            parameterDictionary,
            parameterEnum,
            parameterNumber,
            parameterString,
            parameterBoolean,
            parameterObject,
            id,
        ));
    }
}"
`;

exports[`v3 should generate: ./test/generated/v3/services/UploadService.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
import { request as __request } from './../core/request';
import type { ApiRequestOptions } from './../core/ApiRequestOptions';
import { OpenAPI } from './../core/OpenAPI';

const uploadFile = (
    file: Blob,
): ApiRequestOptions => ({
    method: 'POST',
    path: \`/api/v{api-version}/upload\`,
    formData: {
        'file': file,
    },
});


export type TUploadOptions = {
    uploadFile: (
        file: Blob,
    ) => ApiRequestOptions;
}

export const UploadOptions: TUploadOptions = {
    uploadFile: uploadFile,
}

export class UploadService {

    /**
     * @param file Supply a file reference for upload
     * @returns boolean
     * @throws ApiError
     */
    public static uploadFile(
        file: Blob,
    ): Promise<boolean> {
        return __request<boolean>(OpenAPI, UploadOptions.uploadFile(
            file,
        ));
    }
}"
`;
