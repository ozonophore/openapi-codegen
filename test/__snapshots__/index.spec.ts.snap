// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`v2 should generate: ./test/generated/v2/core/ApiError.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
import type { ApiResult } from './ApiResult';

export class ApiError extends Error {
    public readonly url: string;
    public readonly status: number;
    public readonly statusText: string;
    public readonly body: any;

    constructor(response: ApiResult, message: string) {
        super(message);

        this.url = response.url;
        this.status = response.status;
        this.statusText = response.statusText;
        this.body = response.body;
    }
}"
`;

exports[`v2 should generate: ./test/generated/v2/core/ApiRequestOptions.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
export type ApiRequestOptions = {
    readonly method: 'GET' | 'PUT' | 'POST' | 'DELETE' | 'OPTIONS' | 'HEAD' | 'PATCH';
    readonly path: string;
    readonly cookies?: Record<string, any>;
    readonly headers?: Record<string, any>;
    readonly query?: Record<string, any>;
    readonly formData?: Record<string, any>;
    readonly body?: any;
    readonly mediaType?: string;
    readonly responseHeader?: string;
    // TODO TS2344: Redesign the logic for generating errors. Use the string value of the error code.
    // @ts-ignore
    readonly errors?: Record<number, string>;
}"
`;

exports[`v2 should generate: ./test/generated/v2/core/ApiResult.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
export type ApiResult = {
    readonly url: string;
    readonly ok: boolean;
    readonly status: number;
    readonly statusText: string;
    readonly body: any;
}"
`;

exports[`v2 should generate: ./test/generated/v2/core/HttpStatusCode.ts 1`] = `
"export enum EHTTP_STATUS_CODES {
    BAD_REQUEST = 400,
    UNAUTHORIZED = 401,
    FORBIDDEN = 403,
    NOT_FOUND = 404,
    INTERNAL_SERVER_ERROR = 500,
    BAD_GATEWAY = 502,
    SERVICE_UNAVAILABLE = 503,
}

export enum EHTTP_STATUS_NAME {
    BAD_REQUEST = 'Bad Request',
    UNAUTHORIZED = 'Unauthorized',
    FORBIDDEN = 'Forbidden',
    NOT_FOUND = 'Not Found',
    INTERNAL_SERVER_ERROR = 'Internal Server Error',
    BAD_GATEWAY = 'Bad Gateway',
    SERVICE_UNAVAILABLE = 'Service Unavailable',
}"
`;

exports[`v2 should generate: ./test/generated/v2/core/OpenAPI.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
import type { ApiRequestOptions } from './ApiRequestOptions';

type Resolver<T> = (options: ApiRequestOptions) => Promise<T>;
type Headers = Record<string, string>;

export type TOpenAPIConfig = {
    BASE: string;
    VERSION: string;
    WITH_CREDENTIALS: boolean;
    TOKEN?: string | Resolver<string>;
    USERNAME?: string | Resolver<string>;
    PASSWORD?: string | Resolver<string>;
    HEADERS?: Headers | Resolver<Headers>;
}

export const OpenAPI: TOpenAPIConfig = {
    BASE: 'http://localhost:3000/base',
    VERSION: '1.0',
    WITH_CREDENTIALS: false,
    TOKEN: undefined,
    USERNAME: undefined,
    PASSWORD: undefined,
    HEADERS: undefined,
};"
`;

exports[`v2 should generate: ./test/generated/v2/core/errors.ts 1`] = `
"export class RequiredError extends Error {
    constructor(
        public parameterName: string,
        message?: string
    ) {
        super(message || \`Required parameter "\${parameterName}" was not specified\`);
        this.name = 'RequiredError';
        Object.setPrototypeOf(this, RequiredError.prototype);
    }
}"
`;

exports[`v2 should generate: ./test/generated/v2/core/request.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
import { ApiError } from './ApiError';
import type { ApiRequestOptions } from './ApiRequestOptions';
import type { ApiResult } from './ApiResult';
import type { TOpenAPIConfig } from './OpenAPI';
import { EHTTP_STATUS_CODES, EHTTP_STATUS_NAME } from './HttpStatusCode';

function isDefined<T>(value: T | null | undefined): value is Exclude<T, null | undefined> {
    return value !== undefined && value !== null;
}

function isString(value: any): value is string {
    return typeof value === 'string';
}

function isStringWithValue(value: any): value is string {
    return isString(value) && value !== '';
}

function isBlob(value: any): value is Blob {
    return value instanceof Blob;
}

function getQueryString(params: Record<string, any>): string {
    const qs: string[] = [];
    Object.keys(params).forEach(key => {
        const value = params[key];
        if (isDefined(value)) {
            if (Array.isArray(value)) {
                value.forEach(value => {
                    qs.push(\`\${encodeURIComponent(key)}=\${encodeURIComponent(String(value))}\`);
                });
            } else {
                qs.push(\`\${encodeURIComponent(key)}=\${encodeURIComponent(String(value))}\`);
            }
        }
    });
    if (qs.length > 0) {
        return \`?\${qs.join('&')}\`;
    }
    return '';
}

function getUrl(options: ApiRequestOptions, config: TOpenAPIConfig): string {
    const path = options.path.replace('{api-version}', config.VERSION).replace(/[:]/g, '_');
    const url = \`\${config.BASE}\${path}\`;

    if (options.query) {
        return \`\${url}\${getQueryString(options.query)}\`;
    }
    return url;
}

function getFormData(params: Record<string, any>): FormData {
    const formData = new FormData();
    Object.keys(params).forEach(key => {
        const value = params[key];
        if (isDefined(value)) {
            formData.append(key, value);
        }
    });
    return formData;
}

type Resolver<T> = (options: ApiRequestOptions) => Promise<T>;

async function resolve<T>(options: ApiRequestOptions, resolver?: T | Resolver<T>): Promise<T | undefined> {
    if (typeof resolver === 'function') {
        return (resolver as Resolver<T>)(options);
    }
    return resolver;
}

async function getHeaders(options: ApiRequestOptions, config: TOpenAPIConfig): Promise<Headers> {
    const token = await resolve(options, config.TOKEN);
    const username = await resolve(options, config.USERNAME);
    const password = await resolve(options, config.PASSWORD);
    const defaultHeaders = await resolve(options, config.HEADERS);

    const headers = new Headers({
        Accept: 'application/json',
        ...defaultHeaders,
        ...options.headers,
    });

    if (isStringWithValue(token)) {
        headers.append('Authorization', \`Bearer \${token}\`);
    }

    if (isStringWithValue(username) && isStringWithValue(password)) {
        const credentials = btoa(\`\${username}:\${password}\`);
        headers.append('Authorization', \`Basic \${credentials}\`);
    }

    if (options.body) {
        if (options.mediaType) {
            headers.append('Content-Type', options.mediaType);
        } else if (isBlob(options.body)) {
            headers.append('Content-Type', options.body.type || 'application/octet-stream');
        } else if (isString(options.body)) {
            headers.append('Content-Type', 'text/plain');
        } else {
            headers.append('Content-Type', 'application/json');
        }
    }
    return headers;
}

function getRequestBody(options: ApiRequestOptions): BodyInit | undefined {
    if (options.formData) {
        return getFormData(options.formData);
    }
    if (options.body) {
        if (options.mediaType?.includes('/json')) {
            return JSON.stringify(options.body)
        } else if (isString(options.body) || isBlob(options.body)) {
            return options.body;
        } else {
            return JSON.stringify(options.body);
        }
    }
    return undefined;
}

async function sendRequest(options: ApiRequestOptions, url: string, config: TOpenAPIConfig): Promise<Response> {

    const request: RequestInit = {
        method: options.method,
        headers: await getHeaders(options, config),
        body: getRequestBody(options),
    };

    if (config.WITH_CREDENTIALS) {
        request.credentials = 'include';
    }


    return await fetch(url, request);
}

function getResponseHeader(response: Response, responseHeader?: string): string | null {
    if (responseHeader) {
        const content = response.headers.get(responseHeader);
        if (isString(content)) {
            return content;
        }
    }
    return null;
}

async function getResponseBody(response: Response): Promise<any> {
    try {
        const contentType = response.headers.get('Content-Type');
        if (contentType) {
            const isJSON = contentType.toLowerCase().startsWith('application/json');
            if (isJSON) {
                return await response.json();
            } else {
                return await response.text();
            }
        }
    } catch (error) {
        console.error(error);
    }
    return null;
}

function catchErrors(options: ApiRequestOptions, result: ApiResult): void {
    const errors: Record<string, string> = {
        [EHTTP_STATUS_CODES.BAD_GATEWAY]: EHTTP_STATUS_NAME.BAD_GATEWAY,
        [EHTTP_STATUS_CODES.BAD_REQUEST]: EHTTP_STATUS_NAME.BAD_REQUEST,
        [EHTTP_STATUS_CODES.FORBIDDEN]: EHTTP_STATUS_NAME.FORBIDDEN,
        [EHTTP_STATUS_CODES.INTERNAL_SERVER_ERROR]: EHTTP_STATUS_NAME.INTERNAL_SERVER_ERROR,
        [EHTTP_STATUS_CODES.NOT_FOUND]: EHTTP_STATUS_NAME.NOT_FOUND,
        [EHTTP_STATUS_CODES.SERVICE_UNAVAILABLE]: EHTTP_STATUS_NAME.SERVICE_UNAVAILABLE,
        [EHTTP_STATUS_CODES.UNAUTHORIZED]: EHTTP_STATUS_NAME.UNAUTHORIZED,
        ...options.errors,
    }

    const error = errors[result.status];
    if (error) {
        throw new ApiError(result, error);
    }

    if (!result.ok) {
        throw new ApiError(result, 'Generic Error');
    }
}

/**
 * Request using fetch client
 * @param config The OpenAPI configuration object
 * @param options The request options from the the service
 * @returns ApiResult
 * @throws ApiError
 */
export async function request<T>(options: ApiRequestOptions, config: TOpenAPIConfig): Promise<T> {
    return new Promise(async (resolve, reject) => {
        try {
            const url = getUrl(options, config);
            const response = await sendRequest(options, url, config);
            const responseBody = await getResponseBody(response);
            const responseHeader = getResponseHeader(response, options.responseHeader);

            const result: ApiResult = {
                url,
                ok: response.ok,
                status: response.status,
                statusText: response.statusText,
                body: responseHeader || responseBody,
            };

            catchErrors(options, result);
            resolve(result.body);
        } catch (error) {
            reject(error);
        }
    });
}
"
`;

exports[`v2 should generate: ./test/generated/v2/index.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
export { ApiError } from '././core/ApiError';
export { OpenAPI } from '././core/OpenAPI';
export type { TOpenAPIConfig } from '././core/OpenAPI';

export type { IDictionaryWithReference } from '././models/DictionaryWithReference';
export type { IModelWithArray } from '././models/ModelWithArray';
export type { IModelWithDictionary } from '././models/ModelWithDictionary';
export { IModelWithEnumInteger } from '././models/ModelWithEnumInteger';
export type { IModelWithString } from '././models/ModelWithString';
export type { TModelThatExtends } from '././models/ModelThatExtends';
export type { TModelThatExtendsExtends } from '././models/ModelThatExtendsExtends';

export { IDictionaryWithReferenceSchema } from '././schemas/DictionaryWithReferenceSchema';
export { IModelWithArraySchema } from '././schemas/ModelWithArraySchema';
export { IModelWithDictionarySchema } from '././schemas/ModelWithDictionarySchema';
export { IModelWithEnumIntegerSchema } from '././schemas/ModelWithEnumIntegerSchema';
export { IModelWithStringSchema } from '././schemas/ModelWithStringSchema';
export { TModelThatExtendsSchema } from '././schemas/ModelThatExtendsSchema';
export { TModelThatExtendsExtendsSchema } from '././schemas/ModelThatExtendsExtendsSchema';

export { Service } from '././services/Service';
export { SimpleService } from '././services/SimpleService';
export { ParametersService } from '././services/ParametersService';
export { DefaultsService } from '././services/DefaultsService';
export { DuplicateService } from '././services/DuplicateService';
export { NoContentService } from '././services/NoContentService';
export { ResponseService } from '././services/ResponseService';
export { CollectionFormatService } from '././services/CollectionFormatService';
export { TypesService } from '././services/TypesService';
export { ComplexService } from '././services/ComplexService';
export { HeaderService } from '././services/HeaderService';
"
`;

exports[`v2 should generate: ./test/generated/v2/models/DictionaryWithReference.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */

import type { IModelWithString } from '././ModelWithString';

/**
 * This is a string reference
 */
export type IDictionaryWithReference = Record<string, IModelWithString>;
"
`;

exports[`v2 should generate: ./test/generated/v2/models/ModelThatExtends.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */

import type { IModelWithString } from '././ModelWithString';

/**
 * This is a model that extends another model
 */
export type TModelThatExtends = IModelWithString & {
    propExtendsA?: string;
    propExtendsB?: IModelWithString;
};
"
`;

exports[`v2 should generate: ./test/generated/v2/models/ModelThatExtendsExtends.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */

import type { TModelThatExtends } from '././ModelThatExtends';
import type { IModelWithString } from '././ModelWithString';

/**
 * This is a model that extends another model
 */
export type TModelThatExtendsExtends = IModelWithString &
    TModelThatExtends & {
        propExtendsC?: string;
        propExtendsD?: IModelWithString;
    };
"
`;

exports[`v2 should generate: ./test/generated/v2/models/ModelWithArray.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */

import type { IModelWithString } from '././ModelWithString';

/**
 * This is a model with one property containing an array
 */
export interface IModelWithArray {
    prop?: Array<IModelWithString>;
    propWithFile?: Array<Blob>;
    propWithNumber?: Array<number>;
}
"
`;

exports[`v2 should generate: ./test/generated/v2/models/ModelWithDictionary.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */

/**
 * This is a model with one property containing a dictionary
 */
export interface IModelWithDictionary {
    prop?: Record<string, string>;
}
"
`;

exports[`v2 should generate: ./test/generated/v2/models/ModelWithEnumInteger.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */

/**
 * This is a model with one number property
 */
export interface IModelWithEnumInteger {
    /**
     * VALUE_1=1,VALUE_2=2,VALUE_3=3
     */
    prop?: IModelWithEnumInteger.prop;
}

export namespace IModelWithEnumInteger {
    /**
     * VALUE_1=1,VALUE_2=2,VALUE_3=3
     */
    export enum prop {
        VALUE_1 = 1,
        VALUE_2 = 2,
        VALUE_3 = 3,
    }
}
"
`;

exports[`v2 should generate: ./test/generated/v2/models/ModelWithString.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */

/**
 * This is a model with one string property
 */
export interface IModelWithString {
    /**
     * This is a simple string property
     */
    prop?: string;
}
"
`;

exports[`v2 should generate: ./test/generated/v2/schemas/DictionaryWithReferenceSchema.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
export const IDictionaryWithReferenceSchema = {
    type: 'dictionary',
    contains: {
        type: 'IModelWithString',
    },
};
"
`;

exports[`v2 should generate: ./test/generated/v2/schemas/ModelThatExtendsExtendsSchema.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
export const TModelThatExtendsExtendsSchema = {
    type: 'all-of',
    contains: [
        {
            type: 'IModelWithString',
        },
        {
            type: 'TModelThatExtends',
        },
        {
            properties: {
                propExtendsC: {
                    type: 'string',
                },
                propExtendsD: {
                    type: 'IModelWithString',
                },
            },
        },
    ],
};
"
`;

exports[`v2 should generate: ./test/generated/v2/schemas/ModelThatExtendsSchema.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
export const TModelThatExtendsSchema = {
    type: 'all-of',
    contains: [
        {
            type: 'IModelWithString',
        },
        {
            properties: {
                propExtendsA: {
                    type: 'string',
                },
                propExtendsB: {
                    type: 'IModelWithString',
                },
            },
        },
    ],
};
"
`;

exports[`v2 should generate: ./test/generated/v2/schemas/ModelWithArraySchema.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
export const IModelWithArraySchema = {
    properties: {
        prop: {
            type: 'array',
            contains: {
                type: 'IModelWithString',
            },
        },
        propWithFile: {
            type: 'array',
            contains: {
                type: 'File',
            },
        },
        propWithNumber: {
            type: 'array',
            contains: {
                type: 'number',
            },
        },
    },
};
"
`;

exports[`v2 should generate: ./test/generated/v2/schemas/ModelWithDictionarySchema.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
export const IModelWithDictionarySchema = {
    properties: {
        prop: {
            type: 'dictionary',
            contains: {
                type: 'string',
            },
        },
    },
};
"
`;

exports[`v2 should generate: ./test/generated/v2/schemas/ModelWithEnumIntegerSchema.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
export const IModelWithEnumIntegerSchema = {
    properties: {
        prop: {
            type: 'Enum',
        },
    },
};
"
`;

exports[`v2 should generate: ./test/generated/v2/schemas/ModelWithStringSchema.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
export const IModelWithStringSchema = {
    properties: {
        prop: {
            type: 'string',
        },
    },
};
"
`;

exports[`v2 should generate: ./test/generated/v2/services/CollectionFormatService.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
import { request as __request } from './../core/request';
import type { ApiRequestOptions } from './../core/ApiRequestOptions';
import { OpenAPI } from './../core/OpenAPI';
import { RequiredError } from './../core/errors';

const collectionFormat = (
    parameterArrayCsv?: Array<string>,
    parameterArraySsv?: Array<string>,
    parameterArrayTsv?: Array<string>,
    parameterArrayPipes?: Array<string>,
    parameterArrayMulti?: Array<string>,
): ApiRequestOptions => ({
    method: 'GET',
    path: \`/api/v{api-version}/collectionFormat\`,
    query: {
        parameterArrayCSV: parameterArrayCsv,
        parameterArraySSV: parameterArraySsv,
        parameterArrayTSV: parameterArrayTsv,
        parameterArrayPipes: parameterArrayPipes,
        parameterArrayMulti: parameterArrayMulti,
    },
});

export type TCollectionFormatServiceOptions = {
    collectionFormat: (
        parameterArrayCsv?: Array<string>,
        parameterArraySsv?: Array<string>,
        parameterArrayTsv?: Array<string>,
        parameterArrayPipes?: Array<string>,
        parameterArrayMulti?: Array<string>,
    ) => ApiRequestOptions;
};

export const CollectionFormatServiceOptions: TCollectionFormatServiceOptions = {
    collectionFormat: collectionFormat,
};

export class CollectionFormatService {
    /**
     * @param parameterArrayCsv This is an array parameter that is send as csv format (comma-separated values)
     * @param parameterArraySsv This is an array parameter that is send as ssv format (space-separated values)
     * @param parameterArrayTsv This is an array parameter that is send as tsv format (tab-separated values)
     * @param parameterArrayPipes This is an array parameter that is send as pipes format (pipe-separated values)
     * @param parameterArrayMulti This is an array parameter that is send as multi format (multiple parameter instances)
     * @throws ApiError
     */
    public static collectionFormat(
        parameterArrayCsv?: Array<string>,
        parameterArraySsv?: Array<string>,
        parameterArrayTsv?: Array<string>,
        parameterArrayPipes?: Array<string>,
        parameterArrayMulti?: Array<string>,
    ): Promise<void> {
        // Validate required parameters
        if (parameterArrayCsv === null || parameterArrayCsv === undefined) {
            throw new RequiredError('parameterArrayCsv', 'Required parameter parameterArrayCsv was not specified');
        }
        if (parameterArraySsv === null || parameterArraySsv === undefined) {
            throw new RequiredError('parameterArraySsv', 'Required parameter parameterArraySsv was not specified');
        }
        if (parameterArrayTsv === null || parameterArrayTsv === undefined) {
            throw new RequiredError('parameterArrayTsv', 'Required parameter parameterArrayTsv was not specified');
        }
        if (parameterArrayPipes === null || parameterArrayPipes === undefined) {
            throw new RequiredError('parameterArrayPipes', 'Required parameter parameterArrayPipes was not specified');
        }
        if (parameterArrayMulti === null || parameterArrayMulti === undefined) {
            throw new RequiredError('parameterArrayMulti', 'Required parameter parameterArrayMulti was not specified');
        }

        return __request<void>(
            CollectionFormatServiceOptions.collectionFormat(
                parameterArrayCsv,
                parameterArraySsv,
                parameterArrayTsv,
                parameterArrayPipes,
                parameterArrayMulti,
            ),
            OpenAPI,
        );
    }
}
"
`;

exports[`v2 should generate: ./test/generated/v2/services/ComplexService.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
import type { IModelWithString } from './../models/./ModelWithString';
import { request as __request } from './../core/request';
import type { ApiRequestOptions } from './../core/ApiRequestOptions';
import { OpenAPI } from './../core/OpenAPI';
import { RequiredError } from './../core/errors';

const complexTypes = (
    parameterObject?: {
        first?: {
            second?: {
                third?: string;
            };
        };
    },
    parameterReference?: IModelWithString,
): ApiRequestOptions => ({
    method: 'GET',
    path: \`/api/v{api-version}/complex\`,
    query: {
        parameterObject: parameterObject,
        parameterReference: parameterReference,
    },
    errors: {
        400: \`400 server error\`,
        500: \`500 server error\`,
    },
});

export type TComplexServiceOptions = {
    complexTypes: (
        parameterObject?: {
            first?: {
                second?: {
                    third?: string;
                };
            };
        },
        parameterReference?: IModelWithString,
    ) => ApiRequestOptions;
};

export const ComplexServiceOptions: TComplexServiceOptions = {
    complexTypes: complexTypes,
};

export class ComplexService {
    /**
     * @param parameterObject Parameter containing object
     * @param parameterReference Parameter containing reference
     * @returns IModelWithString Successful response
     * @throws ApiError
     */
    public static complexTypes(
        parameterObject?: {
            first?: {
                second?: {
                    third?: string;
                };
            };
        },
        parameterReference?: IModelWithString,
    ): Promise<Array<IModelWithString>> {
        // Validate required parameters
        if (parameterObject === null || parameterObject === undefined) {
            throw new RequiredError('parameterObject', 'Required parameter parameterObject was not specified');
        }
        if (parameterReference === null || parameterReference === undefined) {
            throw new RequiredError('parameterReference', 'Required parameter parameterReference was not specified');
        }

        return __request<Array<IModelWithString>>(
            ComplexServiceOptions.complexTypes(parameterObject, parameterReference),
            OpenAPI,
        );
    }
}
"
`;

exports[`v2 should generate: ./test/generated/v2/services/DefaultsService.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
import type { IModelWithString } from './../models/./ModelWithString';
import { request as __request } from './../core/request';
import type { ApiRequestOptions } from './../core/ApiRequestOptions';
import { OpenAPI } from './../core/OpenAPI';
import { RequiredError } from './../core/errors';

const callWithDefaultParameters = (
    parameterString?: string = "'Hello World!'",
    parameterNumber?: number = 123,
    parameterBoolean?: boolean = 'true',
    parameterEnum?: 'Success' | 'Warning' | 'Error' = "'Success'",
    parameterModel?: IModelWithString = '{\\n    "prop": "Hello World!"\\n}',
): ApiRequestOptions => ({
    method: 'GET',
    path: \`/api/v{api-version}/defaults\`,
    query: {
        parameterString: parameterString,
        parameterNumber: parameterNumber,
        parameterBoolean: parameterBoolean,
        parameterEnum: parameterEnum,
        parameterModel: parameterModel,
    },
});

const callWithDefaultOptionalParameters = (
    parameterString?: string = "'Hello World!'",
    parameterNumber?: number = 123,
    parameterBoolean?: boolean = 'true',
    parameterEnum?: 'Success' | 'Warning' | 'Error' = "'Success'",
    parameterModel?: IModelWithString = '{\\n    "prop": "Hello World!"\\n}',
): ApiRequestOptions => ({
    method: 'POST',
    path: \`/api/v{api-version}/defaults\`,
    query: {
        parameterString: parameterString,
        parameterNumber: parameterNumber,
        parameterBoolean: parameterBoolean,
        parameterEnum: parameterEnum,
        parameterModel: parameterModel,
    },
});

const callToTestOrderOfParams = (
    parameterOptionalStringWithDefault?: string = "'Hello World!'",
    parameterOptionalStringWithEmptyDefault?: string = "''",
    parameterOptionalStringWithNoDefault?: string,
    parameterStringWithDefault?: string = "'Hello World!'",
    parameterStringWithEmptyDefault?: string = "''",
    parameterStringWithNoDefault?: string,
): ApiRequestOptions => ({
    method: 'PUT',
    path: \`/api/v{api-version}/defaults\`,
    query: {
        parameterOptionalStringWithDefault: parameterOptionalStringWithDefault,
        parameterOptionalStringWithEmptyDefault: parameterOptionalStringWithEmptyDefault,
        parameterOptionalStringWithNoDefault: parameterOptionalStringWithNoDefault,
        parameterStringWithDefault: parameterStringWithDefault,
        parameterStringWithEmptyDefault: parameterStringWithEmptyDefault,
        parameterStringWithNoDefault: parameterStringWithNoDefault,
    },
});

export type TDefaultsServiceOptions = {
    callWithDefaultParameters: (
        parameterString?: string,
        parameterNumber?: number,
        parameterBoolean?: boolean,
        parameterEnum?: 'Success' | 'Warning' | 'Error',
        parameterModel?: IModelWithString,
    ) => ApiRequestOptions;
    callWithDefaultOptionalParameters: (
        parameterString?: string,
        parameterNumber?: number,
        parameterBoolean?: boolean,
        parameterEnum?: 'Success' | 'Warning' | 'Error',
        parameterModel?: IModelWithString,
    ) => ApiRequestOptions;
    callToTestOrderOfParams: (
        parameterOptionalStringWithDefault?: string,
        parameterOptionalStringWithEmptyDefault?: string,
        parameterOptionalStringWithNoDefault?: string,
        parameterStringWithDefault?: string,
        parameterStringWithEmptyDefault?: string,
        parameterStringWithNoDefault?: string,
    ) => ApiRequestOptions;
};

export const DefaultsServiceOptions: TDefaultsServiceOptions = {
    callWithDefaultParameters: callWithDefaultParameters,
    callWithDefaultOptionalParameters: callWithDefaultOptionalParameters,
    callToTestOrderOfParams: callToTestOrderOfParams,
};

export class DefaultsService {
    /**
     * @param parameterString This is a simple string with default value
     * @param parameterNumber This is a simple number with default value
     * @param parameterBoolean This is a simple boolean with default value
     * @param parameterEnum This is a simple enum with default value
     * @param parameterModel This is a simple model with default value
     * @throws ApiError
     */
    public static callWithDefaultParameters(
        parameterString?: string = "'Hello World!'",
        parameterNumber?: number = 123,
        parameterBoolean?: boolean = 'true',
        parameterEnum?: 'Success' | 'Warning' | 'Error' = "'Success'",
        parameterModel?: IModelWithString = '{\\n    "prop": "Hello World!"\\n}',
    ): Promise<void> {
        // Validate required parameters
        if (parameterString === null || parameterString === undefined) {
            throw new RequiredError('parameterString', 'Required parameter parameterString was not specified');
        }
        if (parameterNumber === null || parameterNumber === undefined) {
            throw new RequiredError('parameterNumber', 'Required parameter parameterNumber was not specified');
        }
        if (parameterBoolean === null || parameterBoolean === undefined) {
            throw new RequiredError('parameterBoolean', 'Required parameter parameterBoolean was not specified');
        }
        if (parameterEnum === null || parameterEnum === undefined) {
            throw new RequiredError('parameterEnum', 'Required parameter parameterEnum was not specified');
        }
        if (parameterModel === null || parameterModel === undefined) {
            throw new RequiredError('parameterModel', 'Required parameter parameterModel was not specified');
        }

        return __request<void>(
            DefaultsServiceOptions.callWithDefaultParameters(
                parameterString,
                parameterNumber,
                parameterBoolean,
                parameterEnum,
                parameterModel,
            ),
            OpenAPI,
        );
    }
    /**
     * @param parameterString This is a simple string that is optional with default value
     * @param parameterNumber This is a simple number that is optional with default value
     * @param parameterBoolean This is a simple boolean that is optional with default value
     * @param parameterEnum This is a simple enum that is optional with default value
     * @param parameterModel This is a simple model that is optional with default value
     * @throws ApiError
     */
    public static callWithDefaultOptionalParameters(
        parameterString?: string = "'Hello World!'",
        parameterNumber?: number = 123,
        parameterBoolean?: boolean = 'true',
        parameterEnum?: 'Success' | 'Warning' | 'Error' = "'Success'",
        parameterModel?: IModelWithString = '{\\n    "prop": "Hello World!"\\n}',
    ): Promise<void> {
        // Validate required parameters

        return __request<void>(
            DefaultsServiceOptions.callWithDefaultOptionalParameters(
                parameterString,
                parameterNumber,
                parameterBoolean,
                parameterEnum,
                parameterModel,
            ),
            OpenAPI,
        );
    }
    /**
     * @param parameterOptionalStringWithDefault This is a optional string with default
     * @param parameterOptionalStringWithEmptyDefault This is a optional string with empty default
     * @param parameterOptionalStringWithNoDefault This is a optional string with no default
     * @param parameterStringWithDefault This is a string with default
     * @param parameterStringWithEmptyDefault This is a string with empty default
     * @param parameterStringWithNoDefault This is a string with no default
     * @throws ApiError
     */
    public static callToTestOrderOfParams(
        parameterOptionalStringWithDefault?: string = "'Hello World!'",
        parameterOptionalStringWithEmptyDefault?: string = "''",
        parameterOptionalStringWithNoDefault?: string,
        parameterStringWithDefault?: string = "'Hello World!'",
        parameterStringWithEmptyDefault?: string = "''",
        parameterStringWithNoDefault?: string,
    ): Promise<void> {
        // Validate required parameters
        if (parameterStringWithDefault === null || parameterStringWithDefault === undefined) {
            throw new RequiredError(
                'parameterStringWithDefault',
                'Required parameter parameterStringWithDefault was not specified',
            );
        }
        if (parameterStringWithEmptyDefault === null || parameterStringWithEmptyDefault === undefined) {
            throw new RequiredError(
                'parameterStringWithEmptyDefault',
                'Required parameter parameterStringWithEmptyDefault was not specified',
            );
        }
        if (parameterStringWithNoDefault === null || parameterStringWithNoDefault === undefined) {
            throw new RequiredError(
                'parameterStringWithNoDefault',
                'Required parameter parameterStringWithNoDefault was not specified',
            );
        }

        return __request<void>(
            DefaultsServiceOptions.callToTestOrderOfParams(
                parameterOptionalStringWithDefault,
                parameterOptionalStringWithEmptyDefault,
                parameterOptionalStringWithNoDefault,
                parameterStringWithDefault,
                parameterStringWithEmptyDefault,
                parameterStringWithNoDefault,
            ),
            OpenAPI,
        );
    }
}
"
`;

exports[`v2 should generate: ./test/generated/v2/services/DuplicateService.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
import { request as __request } from './../core/request';
import type { ApiRequestOptions } from './../core/ApiRequestOptions';
import { OpenAPI } from './../core/OpenAPI';
import { RequiredError } from './../core/errors';

const duplicateName = (): ApiRequestOptions => ({
    method: 'GET',
    path: \`/api/v{api-version}/duplicate\`,
});

const duplicateName1 = (): ApiRequestOptions => ({
    method: 'POST',
    path: \`/api/v{api-version}/duplicate\`,
});

const duplicateName2 = (): ApiRequestOptions => ({
    method: 'PUT',
    path: \`/api/v{api-version}/duplicate\`,
});

const duplicateName3 = (): ApiRequestOptions => ({
    method: 'DELETE',
    path: \`/api/v{api-version}/duplicate\`,
});

export type TDuplicateServiceOptions = {
    duplicateName: () => ApiRequestOptions;
    duplicateName1: () => ApiRequestOptions;
    duplicateName2: () => ApiRequestOptions;
    duplicateName3: () => ApiRequestOptions;
};

export const DuplicateServiceOptions: TDuplicateServiceOptions = {
    duplicateName: duplicateName,
    duplicateName1: duplicateName1,
    duplicateName2: duplicateName2,
    duplicateName3: duplicateName3,
};

export class DuplicateService {
    /**
     * @throws ApiError
     */
    public static duplicateName(): Promise<void> {
        // Validate required parameters

        return __request<void>(DuplicateServiceOptions.duplicateName(), OpenAPI);
    }
    /**
     * @throws ApiError
     */
    public static duplicateName1(): Promise<void> {
        // Validate required parameters

        return __request<void>(DuplicateServiceOptions.duplicateName1(), OpenAPI);
    }
    /**
     * @throws ApiError
     */
    public static duplicateName2(): Promise<void> {
        // Validate required parameters

        return __request<void>(DuplicateServiceOptions.duplicateName2(), OpenAPI);
    }
    /**
     * @throws ApiError
     */
    public static duplicateName3(): Promise<void> {
        // Validate required parameters

        return __request<void>(DuplicateServiceOptions.duplicateName3(), OpenAPI);
    }
}
"
`;

exports[`v2 should generate: ./test/generated/v2/services/HeaderService.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
import { request as __request } from './../core/request';
import type { ApiRequestOptions } from './../core/ApiRequestOptions';
import { OpenAPI } from './../core/OpenAPI';
import { RequiredError } from './../core/errors';

const callWithResultFromHeader = (): ApiRequestOptions => ({
    method: 'POST',
    path: \`/api/v{api-version}/header\`,
    responseHeader: 'operation-location',
    errors: {
        400: \`400 server error\`,
        500: \`500 server error\`,
    },
});

export type THeaderServiceOptions = {
    callWithResultFromHeader: () => ApiRequestOptions;
};

export const HeaderServiceOptions: THeaderServiceOptions = {
    callWithResultFromHeader: callWithResultFromHeader,
};

export class HeaderService {
    /**
     * @returns string Successful response
     * @throws ApiError
     */
    public static callWithResultFromHeader(): Promise<string> {
        // Validate required parameters

        return __request<string>(HeaderServiceOptions.callWithResultFromHeader(), OpenAPI);
    }
}
"
`;

exports[`v2 should generate: ./test/generated/v2/services/NoContentService.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
import { request as __request } from './../core/request';
import type { ApiRequestOptions } from './../core/ApiRequestOptions';
import { OpenAPI } from './../core/OpenAPI';
import { RequiredError } from './../core/errors';

const callWithNoContentResponse = (): ApiRequestOptions => ({
    method: 'GET',
    path: \`/api/v{api-version}/no-content\`,
});

export type TNoContentServiceOptions = {
    callWithNoContentResponse: () => ApiRequestOptions;
};

export const NoContentServiceOptions: TNoContentServiceOptions = {
    callWithNoContentResponse: callWithNoContentResponse,
};

export class NoContentService {
    /**
     * @returns void
     * @throws ApiError
     */
    public static callWithNoContentResponse(): Promise<void> {
        // Validate required parameters

        return __request<void>(NoContentServiceOptions.callWithNoContentResponse(), OpenAPI);
    }
}
"
`;

exports[`v2 should generate: ./test/generated/v2/services/ParametersService.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
import { request as __request } from './../core/request';
import type { ApiRequestOptions } from './../core/ApiRequestOptions';
import { OpenAPI } from './../core/OpenAPI';
import { RequiredError } from './../core/errors';

const callWithParameters = (
    parameterHeader?: string,
    parameterQuery?: string,
    parameterForm?: string,
    parameterBody?: string,
    parameterPath?: string,
): ApiRequestOptions => ({
    method: 'GET',
    path: \`/api/v{api-version}/parameters/\${parameterPath}\`,
    headers: {
        parameterHeader: parameterHeader,
    },
    query: {
        parameterQuery: parameterQuery,
    },
    formData: {
        parameterForm: parameterForm,
    },
    body: parameterBody,
});

const callWithWeirdParameterNames = (
    parameterPath1?: string,
    parameterPath2?: string,
    parameterPath3?: string,
    _default?: string,
    parameterHeader?: string,
    parameterQuery?: string,
    parameterForm?: string,
    parameterBody?: string,
): ApiRequestOptions => ({
    method: 'GET',
    path: \`/api/v{api-version}/parameters/\${parameterPath1}/\${parameterPath2}/\${parameterPath3}\`,
    headers: {
        'parameter.header': parameterHeader,
    },
    query: {
        default: _default,
        'parameter-query': parameterQuery,
    },
    formData: {
        parameter_form: parameterForm,
    },
    body: parameterBody,
});

export type TParametersServiceOptions = {
    callWithParameters: (
        parameterHeader?: string,
        parameterQuery?: string,
        parameterForm?: string,
        parameterBody?: string,
        parameterPath?: string,
    ) => ApiRequestOptions;
    callWithWeirdParameterNames: (
        parameterPath1?: string,
        parameterPath2?: string,
        parameterPath3?: string,
        _default?: string,
        parameterHeader?: string,
        parameterQuery?: string,
        parameterForm?: string,
        parameterBody?: string,
    ) => ApiRequestOptions;
};

export const ParametersServiceOptions: TParametersServiceOptions = {
    callWithParameters: callWithParameters,
    callWithWeirdParameterNames: callWithWeirdParameterNames,
};

export class ParametersService {
    /**
     * @param parameterHeader This is the parameter that goes into the header
     * @param parameterQuery This is the parameter that goes into the query params
     * @param parameterForm This is the parameter that goes into the form data
     * @param parameterBody This is the parameter that is send as request body
     * @param parameterPath This is the parameter that goes into the path
     * @throws ApiError
     */
    public static callWithParameters(
        parameterHeader?: string,
        parameterQuery?: string,
        parameterForm?: string,
        parameterBody?: string,
        parameterPath?: string,
    ): Promise<void> {
        // Validate required parameters
        if (parameterHeader === null || parameterHeader === undefined) {
            throw new RequiredError('parameterHeader', 'Required parameter parameterHeader was not specified');
        }
        if (parameterQuery === null || parameterQuery === undefined) {
            throw new RequiredError('parameterQuery', 'Required parameter parameterQuery was not specified');
        }
        if (parameterForm === null || parameterForm === undefined) {
            throw new RequiredError('parameterForm', 'Required parameter parameterForm was not specified');
        }
        if (parameterBody === null || parameterBody === undefined) {
            throw new RequiredError('parameterBody', 'Required parameter parameterBody was not specified');
        }
        if (parameterPath === null || parameterPath === undefined) {
            throw new RequiredError('parameterPath', 'Required parameter parameterPath was not specified');
        }

        return __request<void>(
            ParametersServiceOptions.callWithParameters(
                parameterHeader,
                parameterQuery,
                parameterForm,
                parameterBody,
                parameterPath,
            ),
            OpenAPI,
        );
    }
    /**
     * @param parameterPath1 This is the parameter that goes into the path
     * @param parameterPath2 This is the parameter that goes into the path
     * @param parameterPath3 This is the parameter that goes into the path
     * @param _default This is the parameter with a reserved keyword
     * @param parameterHeader This is the parameter that goes into the request header
     * @param parameterQuery This is the parameter that goes into the request query params
     * @param parameterForm This is the parameter that goes into the request form data
     * @param parameterBody This is the parameter that is send as request body
     * @throws ApiError
     */
    public static callWithWeirdParameterNames(
        parameterPath1?: string,
        parameterPath2?: string,
        parameterPath3?: string,
        _default?: string,
        parameterHeader?: string,
        parameterQuery?: string,
        parameterForm?: string,
        parameterBody?: string,
    ): Promise<void> {
        // Validate required parameters
        if (parameterHeader === null || parameterHeader === undefined) {
            throw new RequiredError('parameterHeader', 'Required parameter parameterHeader was not specified');
        }
        if (parameterQuery === null || parameterQuery === undefined) {
            throw new RequiredError('parameterQuery', 'Required parameter parameterQuery was not specified');
        }
        if (parameterForm === null || parameterForm === undefined) {
            throw new RequiredError('parameterForm', 'Required parameter parameterForm was not specified');
        }
        if (parameterBody === null || parameterBody === undefined) {
            throw new RequiredError('parameterBody', 'Required parameter parameterBody was not specified');
        }

        return __request<void>(
            ParametersServiceOptions.callWithWeirdParameterNames(
                parameterPath1,
                parameterPath2,
                parameterPath3,
                _default,
                parameterHeader,
                parameterQuery,
                parameterForm,
                parameterBody,
            ),
            OpenAPI,
        );
    }
}
"
`;

exports[`v2 should generate: ./test/generated/v2/services/ResponseService.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
import type { TModelThatExtendsExtends } from './../models/./ModelThatExtendsExtends';
import type { TModelThatExtends } from './../models/./ModelThatExtends';
import type { IModelWithString } from './../models/./ModelWithString';
import { request as __request } from './../core/request';
import type { ApiRequestOptions } from './../core/ApiRequestOptions';
import { OpenAPI } from './../core/OpenAPI';
import { RequiredError } from './../core/errors';

const callWithResponse = (): ApiRequestOptions => ({
    method: 'GET',
    path: \`/api/v{api-version}/response\`,
});

const callWithDuplicateResponses = (): ApiRequestOptions => ({
    method: 'POST',
    path: \`/api/v{api-version}/response\`,
    errors: {
        500: \`Message for 500 error\`,
        501: \`Message for 501 error\`,
        502: \`Message for 502 error\`,
    },
});

const callWithResponses = (): ApiRequestOptions => ({
    method: 'PUT',
    path: \`/api/v{api-version}/response\`,
    errors: {
        500: \`Message for 500 error\`,
        501: \`Message for 501 error\`,
        502: \`Message for 502 error\`,
    },
});

export type TResponseServiceOptions = {
    callWithResponse: () => ApiRequestOptions;
    callWithDuplicateResponses: () => ApiRequestOptions;
    callWithResponses: () => ApiRequestOptions;
};

export const ResponseServiceOptions: TResponseServiceOptions = {
    callWithResponse: callWithResponse,
    callWithDuplicateResponses: callWithDuplicateResponses,
    callWithResponses: callWithResponses,
};

export class ResponseService {
    /**
     * @returns IModelWithString Message for default response
     * @throws ApiError
     */
    public static callWithResponse(): Promise<IModelWithString> {
        // Validate required parameters

        return __request<IModelWithString>(ResponseServiceOptions.callWithResponse(), OpenAPI);
    }
    /**
     * @returns IModelWithString Message for default response
     * @throws ApiError
     */
    public static callWithDuplicateResponses(): Promise<IModelWithString> {
        // Validate required parameters

        return __request<IModelWithString>(ResponseServiceOptions.callWithDuplicateResponses(), OpenAPI);
    }
    /**
     * @returns any Message for 200 response
     * @returns IModelWithString Message for default response
     * @returns TModelThatExtends Message for 201 response
     * @returns TModelThatExtendsExtends Message for 202 response
     * @throws ApiError
     */
    public static callWithResponses(): Promise<
        | {
              readonly '@namespace.string'?: string;
              readonly '@namespace.integer'?: number;
              readonly value?: Array<IModelWithString>;
          }
        | IModelWithString
        | TModelThatExtends
        | TModelThatExtendsExtends
    > {
        // Validate required parameters

        return __request<
            | {
                  readonly '@namespace.string'?: string;
                  readonly '@namespace.integer'?: number;
                  readonly value?: Array<IModelWithString>;
              }
            | IModelWithString
            | TModelThatExtends
            | TModelThatExtendsExtends
        >(ResponseServiceOptions.callWithResponses(), OpenAPI);
    }
}
"
`;

exports[`v2 should generate: ./test/generated/v2/services/Service.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
import type { IDictionaryWithReference } from './../models/./DictionaryWithReference';
import type { IModelWithArray } from './../models/./ModelWithArray';
import type { IModelWithDictionary } from './../models/./ModelWithDictionary';
import type { IModelWithEnumInteger } from './../models/./ModelWithEnumInteger';
import { request as __request } from './../core/request';
import type { ApiRequestOptions } from './../core/ApiRequestOptions';
import { OpenAPI } from './../core/OpenAPI';
import { RequiredError } from './../core/errors';

const getCallWithModelWithDictionaryReference = (): ApiRequestOptions => ({
    method: 'GET',
    path: \`/api/v{api-version}/getModelWithDictionaryReference\`,
});

const getCallWithModelWithDictionary = (): ApiRequestOptions => ({
    method: 'GET',
    path: \`/api/v{api-version}/getModelWithDictionary\`,
});

const getCallWithSimpleInteger = (): ApiRequestOptions => ({
    method: 'GET',
    path: \`/api/v{api-version}/simpleEnum\`,
});

const getCallWithModelArray = (): ApiRequestOptions => ({
    method: 'GET',
    path: \`/api/v{api-version}/getModelWithArray\`,
});

export type TServiceOptions = {
    getCallWithModelWithDictionaryReference: () => ApiRequestOptions;
    getCallWithModelWithDictionary: () => ApiRequestOptions;
    getCallWithSimpleInteger: () => ApiRequestOptions;
    getCallWithModelArray: () => ApiRequestOptions;
};

export const ServiceOptions: TServiceOptions = {
    getCallWithModelWithDictionaryReference: getCallWithModelWithDictionaryReference,
    getCallWithModelWithDictionary: getCallWithModelWithDictionary,
    getCallWithSimpleInteger: getCallWithSimpleInteger,
    getCallWithModelArray: getCallWithModelArray,
};

export class Service {
    /**
     * @returns IDictionaryWithReference Message for default response
     * @throws ApiError
     */
    public static getCallWithModelWithDictionaryReference(): Promise<IDictionaryWithReference> {
        // Validate required parameters

        return __request<IDictionaryWithReference>(ServiceOptions.getCallWithModelWithDictionaryReference(), OpenAPI);
    }
    /**
     * @returns IModelWithDictionary Message for default response
     * @throws ApiError
     */
    public static getCallWithModelWithDictionary(): Promise<IModelWithDictionary> {
        // Validate required parameters

        return __request<IModelWithDictionary>(ServiceOptions.getCallWithModelWithDictionary(), OpenAPI);
    }
    /**
     * @returns IModelWithEnumInteger Message for default response
     * @throws ApiError
     */
    public static getCallWithSimpleInteger(): Promise<IModelWithEnumInteger> {
        // Validate required parameters

        return __request<IModelWithEnumInteger>(ServiceOptions.getCallWithSimpleInteger(), OpenAPI);
    }
    /**
     * @returns IModelWithArray Message for default response
     * @throws ApiError
     */
    public static getCallWithModelArray(): Promise<IModelWithArray> {
        // Validate required parameters

        return __request<IModelWithArray>(ServiceOptions.getCallWithModelArray(), OpenAPI);
    }
}
"
`;

exports[`v2 should generate: ./test/generated/v2/services/SimpleService.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
import { request as __request } from './../core/request';
import type { ApiRequestOptions } from './../core/ApiRequestOptions';
import { OpenAPI } from './../core/OpenAPI';
import { RequiredError } from './../core/errors';

const getCallWithoutParametersAndResponse = (): ApiRequestOptions => ({
    method: 'GET',
    path: \`/api/v{api-version}/simple\`,
});

const putCallWithoutParametersAndResponse = (): ApiRequestOptions => ({
    method: 'PUT',
    path: \`/api/v{api-version}/simple\`,
});

const postCallWithoutParametersAndResponse = (): ApiRequestOptions => ({
    method: 'POST',
    path: \`/api/v{api-version}/simple\`,
});

const deleteCallWithoutParametersAndResponse = (): ApiRequestOptions => ({
    method: 'DELETE',
    path: \`/api/v{api-version}/simple\`,
});

const optionsCallWithoutParametersAndResponse = (): ApiRequestOptions => ({
    method: 'OPTIONS',
    path: \`/api/v{api-version}/simple\`,
});

const headCallWithoutParametersAndResponse = (): ApiRequestOptions => ({
    method: 'HEAD',
    path: \`/api/v{api-version}/simple\`,
});

const patchCallWithoutParametersAndResponse = (): ApiRequestOptions => ({
    method: 'PATCH',
    path: \`/api/v{api-version}/simple\`,
});

export type TSimpleServiceOptions = {
    getCallWithoutParametersAndResponse: () => ApiRequestOptions;
    putCallWithoutParametersAndResponse: () => ApiRequestOptions;
    postCallWithoutParametersAndResponse: () => ApiRequestOptions;
    deleteCallWithoutParametersAndResponse: () => ApiRequestOptions;
    optionsCallWithoutParametersAndResponse: () => ApiRequestOptions;
    headCallWithoutParametersAndResponse: () => ApiRequestOptions;
    patchCallWithoutParametersAndResponse: () => ApiRequestOptions;
};

export const SimpleServiceOptions: TSimpleServiceOptions = {
    getCallWithoutParametersAndResponse: getCallWithoutParametersAndResponse,
    putCallWithoutParametersAndResponse: putCallWithoutParametersAndResponse,
    postCallWithoutParametersAndResponse: postCallWithoutParametersAndResponse,
    deleteCallWithoutParametersAndResponse: deleteCallWithoutParametersAndResponse,
    optionsCallWithoutParametersAndResponse: optionsCallWithoutParametersAndResponse,
    headCallWithoutParametersAndResponse: headCallWithoutParametersAndResponse,
    patchCallWithoutParametersAndResponse: patchCallWithoutParametersAndResponse,
};

export class SimpleService {
    /**
     * @throws ApiError
     */
    public static getCallWithoutParametersAndResponse(): Promise<void> {
        // Validate required parameters

        return __request<void>(SimpleServiceOptions.getCallWithoutParametersAndResponse(), OpenAPI);
    }
    /**
     * @throws ApiError
     */
    public static putCallWithoutParametersAndResponse(): Promise<void> {
        // Validate required parameters

        return __request<void>(SimpleServiceOptions.putCallWithoutParametersAndResponse(), OpenAPI);
    }
    /**
     * @throws ApiError
     */
    public static postCallWithoutParametersAndResponse(): Promise<void> {
        // Validate required parameters

        return __request<void>(SimpleServiceOptions.postCallWithoutParametersAndResponse(), OpenAPI);
    }
    /**
     * @throws ApiError
     */
    public static deleteCallWithoutParametersAndResponse(): Promise<void> {
        // Validate required parameters

        return __request<void>(SimpleServiceOptions.deleteCallWithoutParametersAndResponse(), OpenAPI);
    }
    /**
     * @throws ApiError
     */
    public static optionsCallWithoutParametersAndResponse(): Promise<void> {
        // Validate required parameters

        return __request<void>(SimpleServiceOptions.optionsCallWithoutParametersAndResponse(), OpenAPI);
    }
    /**
     * @throws ApiError
     */
    public static headCallWithoutParametersAndResponse(): Promise<void> {
        // Validate required parameters

        return __request<void>(SimpleServiceOptions.headCallWithoutParametersAndResponse(), OpenAPI);
    }
    /**
     * @throws ApiError
     */
    public static patchCallWithoutParametersAndResponse(): Promise<void> {
        // Validate required parameters

        return __request<void>(SimpleServiceOptions.patchCallWithoutParametersAndResponse(), OpenAPI);
    }
}
"
`;

exports[`v2 should generate: ./test/generated/v2/services/TypesService.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
import { request as __request } from './../core/request';
import type { ApiRequestOptions } from './../core/ApiRequestOptions';
import { OpenAPI } from './../core/OpenAPI';
import { RequiredError } from './../core/errors';

const types = (
    parameterNumber?: number = 123,
    parameterString?: string = "'default'",
    parameterBoolean?: boolean = 'true',
    parameterObject?: any = 'null',
    parameterArray?: Array<string>,
    parameterDictionary?: Record<string, string>,
    parameterEnum?: 'Success' | 'Warning' | 'Error',
    id?: number,
): ApiRequestOptions => ({
    method: 'GET',
    path: \`/api/v{api-version}/types\`,
    query: {
        parameterNumber: parameterNumber,
        parameterString: parameterString,
        parameterBoolean: parameterBoolean,
        parameterObject: parameterObject,
        parameterArray: parameterArray,
        parameterDictionary: parameterDictionary,
        parameterEnum: parameterEnum,
    },
});

export type TTypesServiceOptions = {
    types: (
        parameterNumber?: number,
        parameterString?: string,
        parameterBoolean?: boolean,
        parameterObject?: any,
        parameterArray?: Array<string>,
        parameterDictionary?: Record<string, string>,
        parameterEnum?: 'Success' | 'Warning' | 'Error',
        id?: number,
    ) => ApiRequestOptions;
};

export const TypesServiceOptions: TTypesServiceOptions = {
    types: types,
};

export class TypesService {
    /**
     * @param parameterNumber This is a number parameter
     * @param parameterString This is a string parameter
     * @param parameterBoolean This is a boolean parameter
     * @param parameterObject This is an object parameter
     * @param parameterArray This is an array parameter
     * @param parameterDictionary This is a dictionary parameter
     * @param parameterEnum This is an enum parameter
     * @param id This is a number parameter
     * @returns number Response is a simple number
     * @returns string Response is a simple string
     * @returns boolean Response is a simple boolean
     * @returns any Response is a simple object
     * @throws ApiError
     */
    public static types(
        parameterNumber?: number = 123,
        parameterString?: string = "'default'",
        parameterBoolean?: boolean = 'true',
        parameterObject?: any = 'null',
        parameterArray?: Array<string>,
        parameterDictionary?: Record<string, string>,
        parameterEnum?: 'Success' | 'Warning' | 'Error',
        id?: number,
    ): Promise<number | string | boolean | any> {
        // Validate required parameters
        if (parameterNumber === null || parameterNumber === undefined) {
            throw new RequiredError('parameterNumber', 'Required parameter parameterNumber was not specified');
        }
        if (parameterString === null || parameterString === undefined) {
            throw new RequiredError('parameterString', 'Required parameter parameterString was not specified');
        }
        if (parameterBoolean === null || parameterBoolean === undefined) {
            throw new RequiredError('parameterBoolean', 'Required parameter parameterBoolean was not specified');
        }
        if (parameterObject === null || parameterObject === undefined) {
            throw new RequiredError('parameterObject', 'Required parameter parameterObject was not specified');
        }
        if (parameterArray === null || parameterArray === undefined) {
            throw new RequiredError('parameterArray', 'Required parameter parameterArray was not specified');
        }
        if (parameterDictionary === null || parameterDictionary === undefined) {
            throw new RequiredError('parameterDictionary', 'Required parameter parameterDictionary was not specified');
        }
        if (parameterEnum === null || parameterEnum === undefined) {
            throw new RequiredError('parameterEnum', 'Required parameter parameterEnum was not specified');
        }

        return __request<number | string | boolean | any>(
            TypesServiceOptions.types(
                parameterNumber,
                parameterString,
                parameterBoolean,
                parameterObject,
                parameterArray,
                parameterDictionary,
                parameterEnum,
                id,
            ),
            OpenAPI,
        );
    }
}
"
`;

exports[`v3 should generate from different files: ./test/generated/v3_1/core/ApiError.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
import type { ApiResult } from './ApiResult';

export class ApiError extends Error {
    public readonly url: string;
    public readonly status: number;
    public readonly statusText: string;
    public readonly body: any;

    constructor(response: ApiResult, message: string) {
        super(message);

        this.url = response.url;
        this.status = response.status;
        this.statusText = response.statusText;
        this.body = response.body;
    }
}"
`;

exports[`v3 should generate from different files: ./test/generated/v3_1/core/ApiRequestOptions.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
export type ApiRequestOptions = {
    readonly method: 'GET' | 'PUT' | 'POST' | 'DELETE' | 'OPTIONS' | 'HEAD' | 'PATCH';
    readonly path: string;
    readonly cookies?: Record<string, any>;
    readonly headers?: Record<string, any>;
    readonly query?: Record<string, any>;
    readonly formData?: Record<string, any>;
    readonly body?: any;
    readonly mediaType?: string;
    readonly responseHeader?: string;
    // TODO TS2344: Redesign the logic for generating errors. Use the string value of the error code.
    // @ts-ignore
    readonly errors?: Record<number, string>;
}"
`;

exports[`v3 should generate from different files: ./test/generated/v3_1/core/ApiResult.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
export type ApiResult = {
    readonly url: string;
    readonly ok: boolean;
    readonly status: number;
    readonly statusText: string;
    readonly body: any;
}"
`;

exports[`v3 should generate from different files: ./test/generated/v3_1/core/HttpStatusCode.ts 1`] = `
"export enum EHTTP_STATUS_CODES {
    BAD_REQUEST = 400,
    UNAUTHORIZED = 401,
    FORBIDDEN = 403,
    NOT_FOUND = 404,
    INTERNAL_SERVER_ERROR = 500,
    BAD_GATEWAY = 502,
    SERVICE_UNAVAILABLE = 503,
}

export enum EHTTP_STATUS_NAME {
    BAD_REQUEST = 'Bad Request',
    UNAUTHORIZED = 'Unauthorized',
    FORBIDDEN = 'Forbidden',
    NOT_FOUND = 'Not Found',
    INTERNAL_SERVER_ERROR = 'Internal Server Error',
    BAD_GATEWAY = 'Bad Gateway',
    SERVICE_UNAVAILABLE = 'Service Unavailable',
}"
`;

exports[`v3 should generate from different files: ./test/generated/v3_1/core/OpenAPI.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
import type { ApiRequestOptions } from './ApiRequestOptions';

type Resolver<T> = (options: ApiRequestOptions) => Promise<T>;
type Headers = Record<string, string>;

export type TOpenAPIConfig = {
    BASE: string;
    VERSION: string;
    WITH_CREDENTIALS: boolean;
    TOKEN?: string | Resolver<string>;
    USERNAME?: string | Resolver<string>;
    PASSWORD?: string | Resolver<string>;
    HEADERS?: Headers | Resolver<Headers>;
}

export const OpenAPI: TOpenAPIConfig = {
    BASE: 'http://localhost:3000/base',
    VERSION: '1.0',
    WITH_CREDENTIALS: false,
    TOKEN: undefined,
    USERNAME: undefined,
    PASSWORD: undefined,
    HEADERS: undefined,
};"
`;

exports[`v3 should generate from different files: ./test/generated/v3_1/core/errors.ts 1`] = `
"export class RequiredError extends Error {
    constructor(
        public parameterName: string,
        message?: string
    ) {
        super(message || \`Required parameter "\${parameterName}" was not specified\`);
        this.name = 'RequiredError';
        Object.setPrototypeOf(this, RequiredError.prototype);
    }
}"
`;

exports[`v3 should generate from different files: ./test/generated/v3_1/core/request.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
import { ApiError } from './ApiError';
import type { ApiRequestOptions } from './ApiRequestOptions';
import type { ApiResult } from './ApiResult';
import type { TOpenAPIConfig } from './OpenAPI';
import { EHTTP_STATUS_CODES, EHTTP_STATUS_NAME } from './HttpStatusCode';

function isDefined<T>(value: T | null | undefined): value is Exclude<T, null | undefined> {
    return value !== undefined && value !== null;
}

function isString(value: any): value is string {
    return typeof value === 'string';
}

function isStringWithValue(value: any): value is string {
    return isString(value) && value !== '';
}

function isBlob(value: any): value is Blob {
    return value instanceof Blob;
}

function getQueryString(params: Record<string, any>): string {
    const qs: string[] = [];
    Object.keys(params).forEach(key => {
        const value = params[key];
        if (isDefined(value)) {
            if (Array.isArray(value)) {
                value.forEach(value => {
                    qs.push(\`\${encodeURIComponent(key)}=\${encodeURIComponent(String(value))}\`);
                });
            } else {
                qs.push(\`\${encodeURIComponent(key)}=\${encodeURIComponent(String(value))}\`);
            }
        }
    });
    if (qs.length > 0) {
        return \`?\${qs.join('&')}\`;
    }
    return '';
}

function getUrl(options: ApiRequestOptions, config: TOpenAPIConfig): string {
    const path = options.path.replace('{api-version}', config.VERSION).replace(/[:]/g, '_');
    const url = \`\${config.BASE}\${path}\`;

    if (options.query) {
        return \`\${url}\${getQueryString(options.query)}\`;
    }
    return url;
}

function getFormData(params: Record<string, any>): FormData {
    const formData = new FormData();
    Object.keys(params).forEach(key => {
        const value = params[key];
        if (isDefined(value)) {
            formData.append(key, value);
        }
    });
    return formData;
}

type Resolver<T> = (options: ApiRequestOptions) => Promise<T>;

async function resolve<T>(options: ApiRequestOptions, resolver?: T | Resolver<T>): Promise<T | undefined> {
    if (typeof resolver === 'function') {
        return (resolver as Resolver<T>)(options);
    }
    return resolver;
}

async function getHeaders(options: ApiRequestOptions, config: TOpenAPIConfig): Promise<Headers> {
    const token = await resolve(options, config.TOKEN);
    const username = await resolve(options, config.USERNAME);
    const password = await resolve(options, config.PASSWORD);
    const defaultHeaders = await resolve(options, config.HEADERS);

    const headers = new Headers({
        Accept: 'application/json',
        ...defaultHeaders,
        ...options.headers,
    });

    if (isStringWithValue(token)) {
        headers.append('Authorization', \`Bearer \${token}\`);
    }

    if (isStringWithValue(username) && isStringWithValue(password)) {
        const credentials = btoa(\`\${username}:\${password}\`);
        headers.append('Authorization', \`Basic \${credentials}\`);
    }

    if (options.body) {
        if (options.mediaType) {
            headers.append('Content-Type', options.mediaType);
        } else if (isBlob(options.body)) {
            headers.append('Content-Type', options.body.type || 'application/octet-stream');
        } else if (isString(options.body)) {
            headers.append('Content-Type', 'text/plain');
        } else {
            headers.append('Content-Type', 'application/json');
        }
    }
    return headers;
}

function getRequestBody(options: ApiRequestOptions): BodyInit | undefined {
    if (options.formData) {
        return getFormData(options.formData);
    }
    if (options.body) {
        if (options.mediaType?.includes('/json')) {
            return JSON.stringify(options.body)
        } else if (isString(options.body) || isBlob(options.body)) {
            return options.body;
        } else {
            return JSON.stringify(options.body);
        }
    }
    return undefined;
}

async function sendRequest(options: ApiRequestOptions, url: string, config: TOpenAPIConfig): Promise<Response> {

    const request: RequestInit = {
        method: options.method,
        headers: await getHeaders(options, config),
        body: getRequestBody(options),
    };

    if (config.WITH_CREDENTIALS) {
        request.credentials = 'include';
    }


    return await fetch(url, request);
}

function getResponseHeader(response: Response, responseHeader?: string): string | null {
    if (responseHeader) {
        const content = response.headers.get(responseHeader);
        if (isString(content)) {
            return content;
        }
    }
    return null;
}

async function getResponseBody(response: Response): Promise<any> {
    try {
        const contentType = response.headers.get('Content-Type');
        if (contentType) {
            const isJSON = contentType.toLowerCase().startsWith('application/json');
            if (isJSON) {
                return await response.json();
            } else {
                return await response.text();
            }
        }
    } catch (error) {
        console.error(error);
    }
    return null;
}

function catchErrors(options: ApiRequestOptions, result: ApiResult): void {
    const errors: Record<string, string> = {
        [EHTTP_STATUS_CODES.BAD_GATEWAY]: EHTTP_STATUS_NAME.BAD_GATEWAY,
        [EHTTP_STATUS_CODES.BAD_REQUEST]: EHTTP_STATUS_NAME.BAD_REQUEST,
        [EHTTP_STATUS_CODES.FORBIDDEN]: EHTTP_STATUS_NAME.FORBIDDEN,
        [EHTTP_STATUS_CODES.INTERNAL_SERVER_ERROR]: EHTTP_STATUS_NAME.INTERNAL_SERVER_ERROR,
        [EHTTP_STATUS_CODES.NOT_FOUND]: EHTTP_STATUS_NAME.NOT_FOUND,
        [EHTTP_STATUS_CODES.SERVICE_UNAVAILABLE]: EHTTP_STATUS_NAME.SERVICE_UNAVAILABLE,
        [EHTTP_STATUS_CODES.UNAUTHORIZED]: EHTTP_STATUS_NAME.UNAUTHORIZED,
        ...options.errors,
    }

    const error = errors[result.status];
    if (error) {
        throw new ApiError(result, error);
    }

    if (!result.ok) {
        throw new ApiError(result, 'Generic Error');
    }
}

/**
 * Request using fetch client
 * @param config The OpenAPI configuration object
 * @param options The request options from the the service
 * @returns ApiResult
 * @throws ApiError
 */
export async function request<T>(options: ApiRequestOptions, config: TOpenAPIConfig): Promise<T> {
    return new Promise(async (resolve, reject) => {
        try {
            const url = getUrl(options, config);
            const response = await sendRequest(options, url, config);
            const responseBody = await getResponseBody(response);
            const responseHeader = getResponseHeader(response, options.responseHeader);

            const result: ApiResult = {
                url,
                ok: response.ok,
                status: response.status,
                statusText: response.statusText,
                body: responseHeader || responseBody,
            };

            catchErrors(options, result);
            resolve(result.body);
        } catch (error) {
            reject(error);
        }
    });
}
"
`;

exports[`v3 should generate from different files: ./test/generated/v3_1/index.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
export { ApiError } from '././core/ApiError';
export { OpenAPI } from '././core/OpenAPI';
export type { TOpenAPIConfig } from '././core/OpenAPI';

export { EEnumWithNumbers } from '././models/schemas/EnumWithNumbers';
export { EEnumWithStrings } from '././models/schemas/EnumWithStrings';
export type { IModelWithArray } from '././models/schemas/ModelWithArray';
export type { IModelWithCircularReference } from '././models/schemas/ModelWithCircularReference';
export type { IModelWithDictionary } from '././models/schemas/ModelWithDictionary';
export { IModelWithEnum } from '././models/schemas/ModelWithEnum';
export type { IModelWithString } from '././models/schemas/ModelWithString';
export type { TArrayWithArray } from '././models/ArrayWithArray';
export type { TModelThatExtends } from '././models/schemas/ModelThatExtends';

export { EEnumWithNumbersSchema } from '././schemas/schemas/EnumWithNumbersSchema';
export { EEnumWithStringsSchema } from '././schemas/schemas/EnumWithStringsSchema';
export { IModelWithArraySchema } from '././schemas/schemas/ModelWithArraySchema';
export { IModelWithCircularReferenceSchema } from '././schemas/schemas/ModelWithCircularReferenceSchema';
export { IModelWithDictionarySchema } from '././schemas/schemas/ModelWithDictionarySchema';
export { IModelWithEnumSchema } from '././schemas/schemas/ModelWithEnumSchema';
export { IModelWithStringSchema } from '././schemas/schemas/ModelWithStringSchema';
export { TArrayWithArraySchema } from '././schemas/ArrayWithArraySchema';
export { TModelThatExtendsSchema } from '././schemas/schemas/ModelThatExtendsSchema';

export { SimpleService } from '././services/SimpleService';
export { ParametersService } from '././services/ParametersService';
export { RequestBodyService } from '././services/RequestBodyService';
export { DefaultsService } from '././services/DefaultsService';
export { DuplicateService } from '././services/DuplicateService';
export { NoContentService } from '././services/NoContentService';
export { ResponseService } from '././services/ResponseService';
export { CollectionFormatService } from '././services/CollectionFormatService';
export { TypesService } from '././services/TypesService';
export { UploadService } from '././services/UploadService';
export { ComplexService } from '././services/ComplexService';
export { MultipartService } from '././services/MultipartService';
export { HeaderService } from '././services/HeaderService';
export { CircularService } from '././services/CircularService';
export { EnumsService } from '././services/EnumsService';
"
`;

exports[`v3 should generate from different files: ./test/generated/v3_1/models/ArrayWithArray.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */

import type { IModelWithString } from '././schemas/ModelWithString';

/**
 * This is a simple array containing an array
 */
export type TArrayWithArray = Array<Array<IModelWithString>>;
"
`;

exports[`v3 should generate from different files: ./test/generated/v3_1/models/schemas/EnumWithNumbers.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */

/**
 * This is a simple enum with numbers
 */
export enum EEnumWithNumbers {
    '_1' = 1,
    '_2' = 2,
    '_3' = 3,
    '_1.1' = 1.1,
    '_1.2' = 1.2,
    '_1.3' = 1.3,
    '_100' = 100,
    '_200' = 200,
    '_300' = 300,
    '_-100' = -100,
    '_-200' = -200,
    '_-300' = -300,
    '_-1.1' = -1.1,
    '_-1.2' = -1.2,
    '_-1.3' = -1.3,
}
"
`;

exports[`v3 should generate from different files: ./test/generated/v3_1/models/schemas/EnumWithStrings.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */

/**
 * This is a simple enum with strings
 */
export enum EEnumWithStrings {
    SUCCESS = 'Success',
    WARNING = 'Warning',
    ERROR = 'Error',
}
"
`;

exports[`v3 should generate from different files: ./test/generated/v3_1/models/schemas/ModelThatExtends.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */

import type { IModelWithString } from '././ModelWithString';

/**
 * This is a model that extends another model
 */
export type TModelThatExtends = IModelWithString & {
    propExtendsA?: string;
    propExtendsB?: IModelWithString;
};
"
`;

exports[`v3 should generate from different files: ./test/generated/v3_1/models/schemas/ModelWithArray.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */

import type { IModelWithString } from '././ModelWithString';

/**
 * This is a model with one property containing an array
 */
export interface IModelWithArray {
    prop?: Array<IModelWithString>;
    propWithFile?: Array<Blob>;
    propWithNumber?: Array<number>;
}
"
`;

exports[`v3 should generate from different files: ./test/generated/v3_1/models/schemas/ModelWithCircularReference.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */

/**
 * This is a model with one property containing a circular reference
 */
export interface IModelWithCircularReference {
    prop?: IModelWithCircularReference;
}
"
`;

exports[`v3 should generate from different files: ./test/generated/v3_1/models/schemas/ModelWithDictionary.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */

/**
 * This is a model with one property containing a dictionary
 */
export interface IModelWithDictionary {
    prop?: Record<string, string>;
}
"
`;

exports[`v3 should generate from different files: ./test/generated/v3_1/models/schemas/ModelWithEnum.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */

/**
 * This is a model with one enum
 */
export interface IModelWithEnum {
    /**
     * This is a simple enum with strings
     */
    test?: IModelWithEnum.ETest;
    /**
     * These are the HTTP error code enums
     */
    statusCode?: IModelWithEnum.EStatusCode;
    /**
     * Simple boolean enum
     */
    bool?: boolean;
}

export namespace IModelWithEnum {
    /**
     * This is a simple enum with strings
     */
    export enum ETest {
        SUCCESS = 'Success',
        WARNING = 'Warning',
        ERROR = 'Error',
    }

    /**
     * These are the HTTP error code enums
     */
    export enum EStatusCode {
        _100 = '100',
        _200_FOO = '200 FOO',
        _300_FOO_BAR = '300 FOO_BAR',
        _400_FOO_BAR = '400 foo-bar',
        _500_FOO_BAR = '500 foo.bar',
        _600_FOO_BAR = '600 foo&bar',
    }
}
"
`;

exports[`v3 should generate from different files: ./test/generated/v3_1/models/schemas/ModelWithString.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */

/**
 * This is a model with one string property
 */
export interface IModelWithString {
    /**
     * This is a simple string property
     */
    prop?: string;
}
"
`;

exports[`v3 should generate from different files: ./test/generated/v3_1/schemas/ArrayWithArraySchema.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
export const TArrayWithArraySchema = {
    type: 'array',
    contains: {
        type: 'array',
        contains: {
            type: 'IModelWithString',
        },
    },
};
"
`;

exports[`v3 should generate from different files: ./test/generated/v3_1/schemas/schemas/EnumWithNumbersSchema.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
export const EEnumWithNumbersSchema = {
    type: 'Enum',
};
"
`;

exports[`v3 should generate from different files: ./test/generated/v3_1/schemas/schemas/EnumWithStringsSchema.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
export const EEnumWithStringsSchema = {
    type: 'Enum',
};
"
`;

exports[`v3 should generate from different files: ./test/generated/v3_1/schemas/schemas/ModelThatExtendsSchema.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
export const TModelThatExtendsSchema = {
    type: 'all-of',
    contains: [
        {
            type: 'IModelWithString',
        },
        {
            properties: {
                propExtendsA: {
                    type: 'string',
                },
                propExtendsB: {
                    type: 'IModelWithString',
                },
            },
        },
    ],
};
"
`;

exports[`v3 should generate from different files: ./test/generated/v3_1/schemas/schemas/ModelWithArraySchema.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
export const IModelWithArraySchema = {
    properties: {
        prop: {
            type: 'array',
            contains: {
                type: 'IModelWithString',
            },
        },
        propWithFile: {
            type: 'array',
            contains: {
                type: 'File',
            },
        },
        propWithNumber: {
            type: 'array',
            contains: {
                type: 'number',
            },
        },
    },
};
"
`;

exports[`v3 should generate from different files: ./test/generated/v3_1/schemas/schemas/ModelWithCircularReferenceSchema.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
export const IModelWithCircularReferenceSchema = {
    properties: {
        prop: {
            type: 'IModelWithCircularReference',
        },
    },
};
"
`;

exports[`v3 should generate from different files: ./test/generated/v3_1/schemas/schemas/ModelWithDictionarySchema.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
export const IModelWithDictionarySchema = {
    properties: {
        prop: {
            type: 'dictionary',
            contains: {
                type: 'string',
            },
        },
    },
};
"
`;

exports[`v3 should generate from different files: ./test/generated/v3_1/schemas/schemas/ModelWithEnumSchema.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
export const IModelWithEnumSchema = {
    properties: {
        test: {
            type: 'Enum',
        },
        statusCode: {
            type: 'Enum',
        },
        bool: {
            type: 'boolean',
        },
    },
};
"
`;

exports[`v3 should generate from different files: ./test/generated/v3_1/schemas/schemas/ModelWithStringSchema.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
export const IModelWithStringSchema = {
    properties: {
        prop: {
            type: 'string',
        },
    },
};
"
`;

exports[`v3 should generate from different files: ./test/generated/v3_1/services/CircularService.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
import type { IModelWithCircularReference } from './../models/./schemas/ModelWithCircularReference';
import { request as __request } from './../core/request';
import type { ApiRequestOptions } from './../core/ApiRequestOptions';
import { OpenAPI } from './../core/OpenAPI';
import { RequiredError } from './../core/errors';

const callWithCircularModel = (): ApiRequestOptions => ({
    method: 'GET',
    path: \`/api/v{api-version}/circular\`,
});

export type TCircularOptions = {
    callWithCircularModel: () => ApiRequestOptions;
};

export const CircularOptions: TCircularOptions = {
    callWithCircularModel: callWithCircularModel,
};

export class CircularService {
    /**
     * @returns IModelWithCircularReference
     * @throws ApiError
     */
    public static callWithCircularModel(): Promise<IModelWithCircularReference> {
        // Validate required parameters

        return __request<IModelWithCircularReference>(CircularOptions.callWithCircularModel(), OpenAPI);
    }
}
"
`;

exports[`v3 should generate from different files: ./test/generated/v3_1/services/CollectionFormatService.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
import { request as __request } from './../core/request';
import type { ApiRequestOptions } from './../core/ApiRequestOptions';
import { OpenAPI } from './../core/OpenAPI';
import { RequiredError } from './../core/errors';

const collectionFormat = (
    parameterArrayCsv?: Array<string> | null,
    parameterArraySsv?: Array<string> | null,
    parameterArrayTsv?: Array<string> | null,
    parameterArrayPipes?: Array<string> | null,
    parameterArrayMulti?: Array<string> | null,
): ApiRequestOptions => ({
    method: 'GET',
    path: \`/api/v{api-version}/collectionFormat\`,
    query: {
        parameterArrayCSV: parameterArrayCsv,
        parameterArraySSV: parameterArraySsv,
        parameterArrayTSV: parameterArrayTsv,
        parameterArrayPipes: parameterArrayPipes,
        parameterArrayMulti: parameterArrayMulti,
    },
});

export type TCollectionFormatOptions = {
    collectionFormat: (
        parameterArrayCsv?: Array<string> | null,
        parameterArraySsv?: Array<string> | null,
        parameterArrayTsv?: Array<string> | null,
        parameterArrayPipes?: Array<string> | null,
        parameterArrayMulti?: Array<string> | null,
    ) => ApiRequestOptions;
};

export const CollectionFormatOptions: TCollectionFormatOptions = {
    collectionFormat: collectionFormat,
};

export class CollectionFormatService {
    /**
     * @param parameterArrayCsv This is an array parameter that is send as csv format (comma-separated values)
     * @param parameterArraySsv This is an array parameter that is send as ssv format (space-separated values)
     * @param parameterArrayTsv This is an array parameter that is send as tsv format (tab-separated values)
     * @param parameterArrayPipes This is an array parameter that is send as pipes format (pipe-separated values)
     * @param parameterArrayMulti This is an array parameter that is send as multi format (multiple parameter instances)
     * @throws ApiError
     */
    public static collectionFormat(
        parameterArrayCsv?: Array<string> | null,
        parameterArraySsv?: Array<string> | null,
        parameterArrayTsv?: Array<string> | null,
        parameterArrayPipes?: Array<string> | null,
        parameterArrayMulti?: Array<string> | null,
    ): Promise<void> {
        // Validate required parameters
        if (parameterArrayCsv === null || parameterArrayCsv === undefined) {
            throw new RequiredError('parameterArrayCsv', 'Required parameter parameterArrayCsv was not specified');
        }
        if (parameterArraySsv === null || parameterArraySsv === undefined) {
            throw new RequiredError('parameterArraySsv', 'Required parameter parameterArraySsv was not specified');
        }
        if (parameterArrayTsv === null || parameterArrayTsv === undefined) {
            throw new RequiredError('parameterArrayTsv', 'Required parameter parameterArrayTsv was not specified');
        }
        if (parameterArrayPipes === null || parameterArrayPipes === undefined) {
            throw new RequiredError('parameterArrayPipes', 'Required parameter parameterArrayPipes was not specified');
        }
        if (parameterArrayMulti === null || parameterArrayMulti === undefined) {
            throw new RequiredError('parameterArrayMulti', 'Required parameter parameterArrayMulti was not specified');
        }

        return __request<void>(
            CollectionFormatOptions.collectionFormat(
                parameterArrayCsv,
                parameterArraySsv,
                parameterArrayTsv,
                parameterArrayPipes,
                parameterArrayMulti,
            ),
            OpenAPI,
        );
    }
}
"
`;

exports[`v3 should generate from different files: ./test/generated/v3_1/services/ComplexService.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
import type { IModelWithArray } from './../models/./schemas/ModelWithArray';
import type { IModelWithDictionary } from './../models/./schemas/ModelWithDictionary';
import type { IModelWithEnum } from './../models/./schemas/ModelWithEnum';
import type { IModelWithString } from './../models/./schemas/ModelWithString';
import { request as __request } from './../core/request';
import type { ApiRequestOptions } from './../core/ApiRequestOptions';
import { OpenAPI } from './../core/OpenAPI';
import { RequiredError } from './../core/errors';

const complexTypes = (
    parameterObject?: {
        first?: {
            second?: {
                third?: string;
            };
        };
    },
    parameterReference?: IModelWithString,
): ApiRequestOptions => ({
    method: 'GET',
    path: \`/api/v{api-version}/complex\`,
    query: {
        parameterObject: parameterObject,
        parameterReference: parameterReference,
    },
    errors: {
        400: \`400 server error\`,
        500: \`500 server error\`,
    },
});

const complexParams = (
    id?: number,
    requestBody?: {
        readonly key?: string | null;
        name?: string | null;
        enabled?: boolean;
        readonly type?: 'Monkey' | 'Horse' | 'Bird';
        listOfModels?: Array<IModelWithString> | null;
        listOfStrings?: Array<string> | null;
        parameters?: IModelWithString | IModelWithEnum | IModelWithArray | IModelWithDictionary;
        readonly user?: {
            readonly id?: number;
            readonly name?: string | null;
        };
    },
): ApiRequestOptions => ({
    method: 'PUT',
    path: \`/api/v{api-version}/complex/\${id}\`,
    body: requestBody,
    mediaType: 'application/json-patch+json',
});

export type TComplexOptions = {
    complexTypes: (
        parameterObject?: {
            first?: {
                second?: {
                    third?: string;
                };
            };
        },
        parameterReference?: IModelWithString,
    ) => ApiRequestOptions;
    complexParams: (
        id?: number,
        requestBody?: {
            readonly key?: string | null;
            name?: string | null;
            enabled?: boolean;
            readonly type?: 'Monkey' | 'Horse' | 'Bird';
            listOfModels?: Array<IModelWithString> | null;
            listOfStrings?: Array<string> | null;
            parameters?: IModelWithString | IModelWithEnum | IModelWithArray | IModelWithDictionary;
            readonly user?: {
                readonly id?: number;
                readonly name?: string | null;
            };
        },
    ) => ApiRequestOptions;
};

export const ComplexOptions: TComplexOptions = {
    complexTypes: complexTypes,
    complexParams: complexParams,
};

export class ComplexService {
    /**
     * @param parameterObject Parameter containing object
     * @param parameterReference Parameter containing reference
     * @returns IModelWithString Successful response
     * @throws ApiError
     */
    public static complexTypes(
        parameterObject?: {
            first?: {
                second?: {
                    third?: string;
                };
            };
        },
        parameterReference?: IModelWithString,
    ): Promise<Array<IModelWithString>> {
        // Validate required parameters
        if (parameterObject === null || parameterObject === undefined) {
            throw new RequiredError('parameterObject', 'Required parameter parameterObject was not specified');
        }
        if (parameterReference === null || parameterReference === undefined) {
            throw new RequiredError('parameterReference', 'Required parameter parameterReference was not specified');
        }

        return __request<Array<IModelWithString>>(
            ComplexOptions.complexTypes(parameterObject, parameterReference),
            OpenAPI,
        );
    }
    /**
     * @param id
     * @param requestBody
     * @returns IModelWithString Success
     * @throws ApiError
     */
    public static complexParams(
        id?: number,
        requestBody?: {
            readonly key?: string | null;
            name?: string | null;
            enabled?: boolean;
            readonly type?: 'Monkey' | 'Horse' | 'Bird';
            listOfModels?: Array<IModelWithString> | null;
            listOfStrings?: Array<string> | null;
            parameters?: IModelWithString | IModelWithEnum | IModelWithArray | IModelWithDictionary;
            readonly user?: {
                readonly id?: number;
                readonly name?: string | null;
            };
        },
    ): Promise<IModelWithString> {
        // Validate required parameters
        if (id === null || id === undefined) {
            throw new RequiredError('id', 'Required parameter id was not specified');
        }

        return __request<IModelWithString>(ComplexOptions.complexParams(id, requestBody), OpenAPI);
    }
}
"
`;

exports[`v3 should generate from different files: ./test/generated/v3_1/services/DefaultsService.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
import type { IModelWithString } from './../models/./schemas/ModelWithString';
import { request as __request } from './../core/request';
import type { ApiRequestOptions } from './../core/ApiRequestOptions';
import { OpenAPI } from './../core/OpenAPI';
import { RequiredError } from './../core/errors';

const callWithDefaultParameters = (
    parameterString?: string | null = "'Hello World!'",
    parameterNumber?: number | null = 123,
    parameterBoolean?: boolean | null = 'true',
    parameterEnum?: 'Success' | 'Warning' | 'Error' = "'Success'",
    parameterModel?: IModelWithString | null = '{\\n    "prop": "Hello World!"\\n}',
): ApiRequestOptions => ({
    method: 'GET',
    path: \`/api/v{api-version}/defaults\`,
    query: {
        parameterString: parameterString,
        parameterNumber: parameterNumber,
        parameterBoolean: parameterBoolean,
        parameterEnum: parameterEnum,
        parameterModel: parameterModel,
    },
});

const callWithDefaultOptionalParameters = (
    parameterString?: string = "'Hello World!'",
    parameterNumber?: number = 123,
    parameterBoolean?: boolean = 'true',
    parameterEnum?: 'Success' | 'Warning' | 'Error' = "'Success'",
    parameterModel?: IModelWithString = '{\\n    "prop": "Hello World!"\\n}',
): ApiRequestOptions => ({
    method: 'POST',
    path: \`/api/v{api-version}/defaults\`,
    query: {
        parameterString: parameterString,
        parameterNumber: parameterNumber,
        parameterBoolean: parameterBoolean,
        parameterEnum: parameterEnum,
        parameterModel: parameterModel,
    },
});

const callToTestOrderOfParams = (
    parameterOptionalStringWithDefault?: string = "'Hello World!'",
    parameterOptionalStringWithEmptyDefault?: string = "''",
    parameterOptionalStringWithNoDefault?: string,
    parameterStringWithDefault?: string = "'Hello World!'",
    parameterStringWithEmptyDefault?: string = "''",
    parameterStringWithNoDefault?: string,
): ApiRequestOptions => ({
    method: 'PUT',
    path: \`/api/v{api-version}/defaults\`,
    query: {
        parameterOptionalStringWithDefault: parameterOptionalStringWithDefault,
        parameterOptionalStringWithEmptyDefault: parameterOptionalStringWithEmptyDefault,
        parameterOptionalStringWithNoDefault: parameterOptionalStringWithNoDefault,
        parameterStringWithDefault: parameterStringWithDefault,
        parameterStringWithEmptyDefault: parameterStringWithEmptyDefault,
        parameterStringWithNoDefault: parameterStringWithNoDefault,
    },
});

export type TDefaultsOptions = {
    callWithDefaultParameters: (
        parameterString?: string | null,
        parameterNumber?: number | null,
        parameterBoolean?: boolean | null,
        parameterEnum?: 'Success' | 'Warning' | 'Error',
        parameterModel?: IModelWithString | null,
    ) => ApiRequestOptions;
    callWithDefaultOptionalParameters: (
        parameterString?: string,
        parameterNumber?: number,
        parameterBoolean?: boolean,
        parameterEnum?: 'Success' | 'Warning' | 'Error',
        parameterModel?: IModelWithString,
    ) => ApiRequestOptions;
    callToTestOrderOfParams: (
        parameterOptionalStringWithDefault?: string,
        parameterOptionalStringWithEmptyDefault?: string,
        parameterOptionalStringWithNoDefault?: string,
        parameterStringWithDefault?: string,
        parameterStringWithEmptyDefault?: string,
        parameterStringWithNoDefault?: string,
    ) => ApiRequestOptions;
};

export const DefaultsOptions: TDefaultsOptions = {
    callWithDefaultParameters: callWithDefaultParameters,
    callWithDefaultOptionalParameters: callWithDefaultOptionalParameters,
    callToTestOrderOfParams: callToTestOrderOfParams,
};

export class DefaultsService {
    /**
     * @param parameterString This is a simple string with default value
     * @param parameterNumber This is a simple number with default value
     * @param parameterBoolean This is a simple boolean with default value
     * @param parameterEnum This is a simple enum with default value
     * @param parameterModel This is a simple model with default value
     * @throws ApiError
     */
    public static callWithDefaultParameters(
        parameterString?: string | null = "'Hello World!'",
        parameterNumber?: number | null = 123,
        parameterBoolean?: boolean | null = 'true',
        parameterEnum?: 'Success' | 'Warning' | 'Error' = "'Success'",
        parameterModel?: IModelWithString | null = '{\\n    "prop": "Hello World!"\\n}',
    ): Promise<void> {
        // Validate required parameters
        if (parameterString === null || parameterString === undefined) {
            throw new RequiredError('parameterString', 'Required parameter parameterString was not specified');
        }
        if (parameterNumber === null || parameterNumber === undefined) {
            throw new RequiredError('parameterNumber', 'Required parameter parameterNumber was not specified');
        }
        if (parameterBoolean === null || parameterBoolean === undefined) {
            throw new RequiredError('parameterBoolean', 'Required parameter parameterBoolean was not specified');
        }
        if (parameterEnum === null || parameterEnum === undefined) {
            throw new RequiredError('parameterEnum', 'Required parameter parameterEnum was not specified');
        }

        return __request<void>(
            DefaultsOptions.callWithDefaultParameters(
                parameterString,
                parameterNumber,
                parameterBoolean,
                parameterEnum,
                parameterModel,
            ),
            OpenAPI,
        );
    }
    /**
     * @param parameterString This is a simple string that is optional with default value
     * @param parameterNumber This is a simple number that is optional with default value
     * @param parameterBoolean This is a simple boolean that is optional with default value
     * @param parameterEnum This is a simple enum that is optional with default value
     * @param parameterModel This is a simple model that is optional with default value
     * @throws ApiError
     */
    public static callWithDefaultOptionalParameters(
        parameterString?: string = "'Hello World!'",
        parameterNumber?: number = 123,
        parameterBoolean?: boolean = 'true',
        parameterEnum?: 'Success' | 'Warning' | 'Error' = "'Success'",
        parameterModel?: IModelWithString = '{\\n    "prop": "Hello World!"\\n}',
    ): Promise<void> {
        // Validate required parameters
        if (parameterString === null || parameterString === undefined) {
            throw new RequiredError('parameterString', 'Required parameter parameterString was not specified');
        }
        if (parameterNumber === null || parameterNumber === undefined) {
            throw new RequiredError('parameterNumber', 'Required parameter parameterNumber was not specified');
        }
        if (parameterBoolean === null || parameterBoolean === undefined) {
            throw new RequiredError('parameterBoolean', 'Required parameter parameterBoolean was not specified');
        }
        if (parameterEnum === null || parameterEnum === undefined) {
            throw new RequiredError('parameterEnum', 'Required parameter parameterEnum was not specified');
        }

        return __request<void>(
            DefaultsOptions.callWithDefaultOptionalParameters(
                parameterString,
                parameterNumber,
                parameterBoolean,
                parameterEnum,
                parameterModel,
            ),
            OpenAPI,
        );
    }
    /**
     * @param parameterOptionalStringWithDefault This is a optional string with default
     * @param parameterOptionalStringWithEmptyDefault This is a optional string with empty default
     * @param parameterOptionalStringWithNoDefault This is a optional string with no default
     * @param parameterStringWithDefault This is a string with default
     * @param parameterStringWithEmptyDefault This is a string with empty default
     * @param parameterStringWithNoDefault This is a string with no default
     * @throws ApiError
     */
    public static callToTestOrderOfParams(
        parameterOptionalStringWithDefault?: string = "'Hello World!'",
        parameterOptionalStringWithEmptyDefault?: string = "''",
        parameterOptionalStringWithNoDefault?: string,
        parameterStringWithDefault?: string = "'Hello World!'",
        parameterStringWithEmptyDefault?: string = "''",
        parameterStringWithNoDefault?: string,
    ): Promise<void> {
        // Validate required parameters
        if (parameterOptionalStringWithDefault === null || parameterOptionalStringWithDefault === undefined) {
            throw new RequiredError(
                'parameterOptionalStringWithDefault',
                'Required parameter parameterOptionalStringWithDefault was not specified',
            );
        }
        if (parameterOptionalStringWithEmptyDefault === null || parameterOptionalStringWithEmptyDefault === undefined) {
            throw new RequiredError(
                'parameterOptionalStringWithEmptyDefault',
                'Required parameter parameterOptionalStringWithEmptyDefault was not specified',
            );
        }
        if (parameterStringWithDefault === null || parameterStringWithDefault === undefined) {
            throw new RequiredError(
                'parameterStringWithDefault',
                'Required parameter parameterStringWithDefault was not specified',
            );
        }
        if (parameterStringWithEmptyDefault === null || parameterStringWithEmptyDefault === undefined) {
            throw new RequiredError(
                'parameterStringWithEmptyDefault',
                'Required parameter parameterStringWithEmptyDefault was not specified',
            );
        }
        if (parameterStringWithNoDefault === null || parameterStringWithNoDefault === undefined) {
            throw new RequiredError(
                'parameterStringWithNoDefault',
                'Required parameter parameterStringWithNoDefault was not specified',
            );
        }

        return __request<void>(
            DefaultsOptions.callToTestOrderOfParams(
                parameterOptionalStringWithDefault,
                parameterOptionalStringWithEmptyDefault,
                parameterOptionalStringWithNoDefault,
                parameterStringWithDefault,
                parameterStringWithEmptyDefault,
                parameterStringWithNoDefault,
            ),
            OpenAPI,
        );
    }
}
"
`;

exports[`v3 should generate from different files: ./test/generated/v3_1/services/DuplicateService.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
import { request as __request } from './../core/request';
import type { ApiRequestOptions } from './../core/ApiRequestOptions';
import { OpenAPI } from './../core/OpenAPI';
import { RequiredError } from './../core/errors';

const duplicateName = (): ApiRequestOptions => ({
    method: 'GET',
    path: \`/api/v{api-version}/duplicate\`,
});

const duplicateName1 = (): ApiRequestOptions => ({
    method: 'POST',
    path: \`/api/v{api-version}/duplicate\`,
});

const duplicateName2 = (): ApiRequestOptions => ({
    method: 'PUT',
    path: \`/api/v{api-version}/duplicate\`,
});

const duplicateName3 = (): ApiRequestOptions => ({
    method: 'DELETE',
    path: \`/api/v{api-version}/duplicate\`,
});

export type TDuplicateOptions = {
    duplicateName: () => ApiRequestOptions;
    duplicateName1: () => ApiRequestOptions;
    duplicateName2: () => ApiRequestOptions;
    duplicateName3: () => ApiRequestOptions;
};

export const DuplicateOptions: TDuplicateOptions = {
    duplicateName: duplicateName,
    duplicateName1: duplicateName1,
    duplicateName2: duplicateName2,
    duplicateName3: duplicateName3,
};

export class DuplicateService {
    /**
     * @throws ApiError
     */
    public static duplicateName(): Promise<void> {
        // Validate required parameters

        return __request<void>(DuplicateOptions.duplicateName(), OpenAPI);
    }
    /**
     * @throws ApiError
     */
    public static duplicateName1(): Promise<void> {
        // Validate required parameters

        return __request<void>(DuplicateOptions.duplicateName1(), OpenAPI);
    }
    /**
     * @throws ApiError
     */
    public static duplicateName2(): Promise<void> {
        // Validate required parameters

        return __request<void>(DuplicateOptions.duplicateName2(), OpenAPI);
    }
    /**
     * @throws ApiError
     */
    public static duplicateName3(): Promise<void> {
        // Validate required parameters

        return __request<void>(DuplicateOptions.duplicateName3(), OpenAPI);
    }
}
"
`;

exports[`v3 should generate from different files: ./test/generated/v3_1/services/EnumsService.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
import type { EEnumWithNumbers } from './../models/./schemas/EnumWithNumbers';
import type { EEnumWithStrings } from './../models/./schemas/EnumWithStrings';
import { request as __request } from './../core/request';
import type { ApiRequestOptions } from './../core/ApiRequestOptions';
import { OpenAPI } from './../core/OpenAPI';
import { RequiredError } from './../core/errors';

const callWithEnums = (requestBody?: {
    enumWithNumbers?: EEnumWithNumbers;
    enumWithStrings?: EEnumWithStrings;
}): ApiRequestOptions => ({
    method: 'POST',
    path: \`/api/v{api-version}/enums\`,
    body: requestBody,
    mediaType: 'application/json; charset=utf-8',
});

export type TEnumsOptions = {
    callWithEnums: (requestBody?: {
        enumWithNumbers?: EEnumWithNumbers;
        enumWithStrings?: EEnumWithStrings;
    }) => ApiRequestOptions;
};

export const EnumsOptions: TEnumsOptions = {
    callWithEnums: callWithEnums,
};

export class EnumsService {
    /**
     * @param requestBody
     * @throws ApiError
     */
    public static callWithEnums(requestBody?: {
        enumWithNumbers?: EEnumWithNumbers;
        enumWithStrings?: EEnumWithStrings;
    }): Promise<void> {
        // Validate required parameters

        return __request<void>(EnumsOptions.callWithEnums(requestBody), OpenAPI);
    }
}
"
`;

exports[`v3 should generate from different files: ./test/generated/v3_1/services/HeaderService.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
import { request as __request } from './../core/request';
import type { ApiRequestOptions } from './../core/ApiRequestOptions';
import { OpenAPI } from './../core/OpenAPI';
import { RequiredError } from './../core/errors';

const callWithResultFromHeader = (): ApiRequestOptions => ({
    method: 'POST',
    path: \`/api/v{api-version}/header\`,
    responseHeader: 'operation-location',
    errors: {
        400: \`400 server error\`,
        500: \`500 server error\`,
    },
});

export type THeaderOptions = {
    callWithResultFromHeader: () => ApiRequestOptions;
};

export const HeaderOptions: THeaderOptions = {
    callWithResultFromHeader: callWithResultFromHeader,
};

export class HeaderService {
    /**
     * @returns string Successful response
     * @throws ApiError
     */
    public static callWithResultFromHeader(): Promise<string> {
        // Validate required parameters

        return __request<string>(HeaderOptions.callWithResultFromHeader(), OpenAPI);
    }
}
"
`;

exports[`v3 should generate from different files: ./test/generated/v3_1/services/MultipartService.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
import { request as __request } from './../core/request';
import type { ApiRequestOptions } from './../core/ApiRequestOptions';
import { OpenAPI } from './../core/OpenAPI';
import { RequiredError } from './../core/errors';

const multipartResponse = (): ApiRequestOptions => ({
    method: 'GET',
    path: \`/api/v{api-version}/multipart\`,
});

export type TMultipartOptions = {
    multipartResponse: () => ApiRequestOptions;
};

export const MultipartOptions: TMultipartOptions = {
    multipartResponse: multipartResponse,
};

export class MultipartService {
    /**
     * @returns any OK
     * @throws ApiError
     */
    public static multipartResponse(): Promise<{
        file?: string;
        metadata?: {
            foo?: string;
            bar?: string;
        };
    }> {
        // Validate required parameters

        return __request<{
            file?: string;
            metadata?: {
                foo?: string;
                bar?: string;
            };
        }>(MultipartOptions.multipartResponse(), OpenAPI);
    }
}
"
`;

exports[`v3 should generate from different files: ./test/generated/v3_1/services/NoContentService.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
import { request as __request } from './../core/request';
import type { ApiRequestOptions } from './../core/ApiRequestOptions';
import { OpenAPI } from './../core/OpenAPI';
import { RequiredError } from './../core/errors';

const callWithNoContentResponse = (): ApiRequestOptions => ({
    method: 'GET',
    path: \`/api/v{api-version}/no-content\`,
});

export type TNoContentOptions = {
    callWithNoContentResponse: () => ApiRequestOptions;
};

export const NoContentOptions: TNoContentOptions = {
    callWithNoContentResponse: callWithNoContentResponse,
};

export class NoContentService {
    /**
     * @returns void
     * @throws ApiError
     */
    public static callWithNoContentResponse(): Promise<void> {
        // Validate required parameters

        return __request<void>(NoContentOptions.callWithNoContentResponse(), OpenAPI);
    }
}
"
`;

exports[`v3 should generate from different files: ./test/generated/v3_1/services/ParametersService.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
import type { IModelWithString } from './../models/./schemas/ModelWithString';
import { request as __request } from './../core/request';
import type { ApiRequestOptions } from './../core/ApiRequestOptions';
import { OpenAPI } from './../core/OpenAPI';
import { RequiredError } from './../core/errors';

const callWithParameters = (
    parameterHeader?: string | null,
    parameterQuery?: string | null,
    parameterForm?: string | null,
    parameterCookie?: string | null,
    parameterPath?: string | null,
    requestBody?: IModelWithString | null,
): ApiRequestOptions => ({
    method: 'GET',
    path: \`/api/v{api-version}/parameters/\${parameterPath}\`,
    cookies: {
        parameterCookie: parameterCookie,
    },
    headers: {
        parameterHeader: parameterHeader,
    },
    query: {
        parameterQuery: parameterQuery,
    },
    formData: {
        parameterForm: parameterForm,
    },
    body: requestBody,
    mediaType: 'application/json',
});

const callWithWeirdParameterNames = (
    parameterPath1?: string,
    parameterPath2?: string,
    parameterPath3?: string,
    _default?: string,
    parameterHeader?: string | null,
    parameterQuery?: string | null,
    parameterForm?: string | null,
    parameterCookie?: string | null,
    requestBody?: IModelWithString | null,
): ApiRequestOptions => ({
    method: 'GET',
    path: \`/api/v{api-version}/parameters/\${parameterPath1}/\${parameterPath2}/\${parameterPath3}\`,
    cookies: {
        'PARAMETER-COOKIE': parameterCookie,
    },
    headers: {
        'parameter.header': parameterHeader,
    },
    query: {
        default: _default,
        'parameter-query': parameterQuery,
    },
    formData: {
        parameter_form: parameterForm,
    },
    body: requestBody,
    mediaType: 'application/json',
});

const getCallWithOptionalParam = (parameter?: string, requestBody?: IModelWithString): ApiRequestOptions => ({
    method: 'GET',
    path: \`/api/v{api-version}/parameters/\`,
    query: {
        parameter: parameter,
    },
    body: requestBody,
    mediaType: 'application/json',
});

const postCallWithOptionalParam = (parameter?: string, requestBody?: IModelWithString): ApiRequestOptions => ({
    method: 'POST',
    path: \`/api/v{api-version}/parameters/\`,
    query: {
        parameter: parameter,
    },
    body: requestBody,
    mediaType: 'application/json',
});

export type TParametersOptions = {
    callWithParameters: (
        parameterHeader?: string | null,
        parameterQuery?: string | null,
        parameterForm?: string | null,
        parameterCookie?: string | null,
        parameterPath?: string | null,
        requestBody?: IModelWithString | null,
    ) => ApiRequestOptions;
    callWithWeirdParameterNames: (
        parameterPath1?: string,
        parameterPath2?: string,
        parameterPath3?: string,
        _default?: string,
        parameterHeader?: string | null,
        parameterQuery?: string | null,
        parameterForm?: string | null,
        parameterCookie?: string | null,
        requestBody?: IModelWithString | null,
    ) => ApiRequestOptions;
    getCallWithOptionalParam: (parameter?: string, requestBody?: IModelWithString) => ApiRequestOptions;
    postCallWithOptionalParam: (parameter?: string, requestBody?: IModelWithString) => ApiRequestOptions;
};

export const ParametersOptions: TParametersOptions = {
    callWithParameters: callWithParameters,
    callWithWeirdParameterNames: callWithWeirdParameterNames,
    getCallWithOptionalParam: getCallWithOptionalParam,
    postCallWithOptionalParam: postCallWithOptionalParam,
};

export class ParametersService {
    /**
     * @param parameterHeader This is the parameter that goes into the header
     * @param parameterQuery This is the parameter that goes into the query params
     * @param parameterForm This is the parameter that goes into the form data
     * @param parameterCookie This is the parameter that goes into the cookie
     * @param parameterPath This is the parameter that goes into the path
     * @param requestBody This is the parameter that goes into the body
     * @throws ApiError
     */
    public static callWithParameters(
        parameterHeader?: string | null,
        parameterQuery?: string | null,
        parameterForm?: string | null,
        parameterCookie?: string | null,
        parameterPath?: string | null,
        requestBody?: IModelWithString | null,
    ): Promise<void> {
        // Validate required parameters
        if (parameterHeader === null || parameterHeader === undefined) {
            throw new RequiredError('parameterHeader', 'Required parameter parameterHeader was not specified');
        }
        if (parameterQuery === null || parameterQuery === undefined) {
            throw new RequiredError('parameterQuery', 'Required parameter parameterQuery was not specified');
        }
        if (parameterForm === null || parameterForm === undefined) {
            throw new RequiredError('parameterForm', 'Required parameter parameterForm was not specified');
        }
        if (parameterCookie === null || parameterCookie === undefined) {
            throw new RequiredError('parameterCookie', 'Required parameter parameterCookie was not specified');
        }
        if (parameterPath === null || parameterPath === undefined) {
            throw new RequiredError('parameterPath', 'Required parameter parameterPath was not specified');
        }
        if (requestBody === null || requestBody === undefined) {
            throw new RequiredError('requestBody', 'Required parameter requestBody was not specified');
        }

        return __request<void>(
            ParametersOptions.callWithParameters(
                parameterHeader,
                parameterQuery,
                parameterForm,
                parameterCookie,
                parameterPath,
                requestBody,
            ),
            OpenAPI,
        );
    }
    /**
     * @param parameterPath1 This is the parameter that goes into the path
     * @param parameterPath2 This is the parameter that goes into the path
     * @param parameterPath3 This is the parameter that goes into the path
     * @param _default This is the parameter with a reserved keyword
     * @param parameterHeader This is the parameter that goes into the request header
     * @param parameterQuery This is the parameter that goes into the request query params
     * @param parameterForm This is the parameter that goes into the request form data
     * @param parameterCookie This is the parameter that goes into the cookie
     * @param requestBody This is the parameter that goes into the body
     * @throws ApiError
     */
    public static callWithWeirdParameterNames(
        parameterPath1?: string,
        parameterPath2?: string,
        parameterPath3?: string,
        _default?: string,
        parameterHeader?: string | null,
        parameterQuery?: string | null,
        parameterForm?: string | null,
        parameterCookie?: string | null,
        requestBody?: IModelWithString | null,
    ): Promise<void> {
        // Validate required parameters
        if (parameterHeader === null || parameterHeader === undefined) {
            throw new RequiredError('parameterHeader', 'Required parameter parameterHeader was not specified');
        }
        if (parameterQuery === null || parameterQuery === undefined) {
            throw new RequiredError('parameterQuery', 'Required parameter parameterQuery was not specified');
        }
        if (parameterForm === null || parameterForm === undefined) {
            throw new RequiredError('parameterForm', 'Required parameter parameterForm was not specified');
        }
        if (parameterCookie === null || parameterCookie === undefined) {
            throw new RequiredError('parameterCookie', 'Required parameter parameterCookie was not specified');
        }
        if (requestBody === null || requestBody === undefined) {
            throw new RequiredError('requestBody', 'Required parameter requestBody was not specified');
        }

        return __request<void>(
            ParametersOptions.callWithWeirdParameterNames(
                parameterPath1,
                parameterPath2,
                parameterPath3,
                _default,
                parameterHeader,
                parameterQuery,
                parameterForm,
                parameterCookie,
                requestBody,
            ),
            OpenAPI,
        );
    }
    /**
     * @param parameter This is an optional parameter
     * @param requestBody This is a required parameter
     * @throws ApiError
     */
    public static getCallWithOptionalParam(parameter?: string, requestBody?: IModelWithString): Promise<void> {
        // Validate required parameters
        if (requestBody === null || requestBody === undefined) {
            throw new RequiredError('requestBody', 'Required parameter requestBody was not specified');
        }

        return __request<void>(ParametersOptions.getCallWithOptionalParam(parameter, requestBody), OpenAPI);
    }
    /**
     * @param parameter This is a required parameter
     * @param requestBody This is an optional parameter
     * @throws ApiError
     */
    public static postCallWithOptionalParam(parameter?: string, requestBody?: IModelWithString): Promise<void> {
        // Validate required parameters
        if (parameter === null || parameter === undefined) {
            throw new RequiredError('parameter', 'Required parameter parameter was not specified');
        }

        return __request<void>(ParametersOptions.postCallWithOptionalParam(parameter, requestBody), OpenAPI);
    }
}
"
`;

exports[`v3 should generate from different files: ./test/generated/v3_1/services/RequestBodyService.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
import type { IModelWithString } from './../models/./schemas/ModelWithString';
import { request as __request } from './../core/request';
import type { ApiRequestOptions } from './../core/ApiRequestOptions';
import { OpenAPI } from './../core/OpenAPI';
import { RequiredError } from './../core/errors';

const postRequestBodyService = (requestBody?: IModelWithString): ApiRequestOptions => ({
    method: 'POST',
    path: \`/api/v{api-version}/requestBody/\`,
    body: requestBody,
    mediaType: 'application/json',
});

export type TRequestBodyOptions = {
    postRequestBodyService: (requestBody?: IModelWithString) => ApiRequestOptions;
};

export const RequestBodyOptions: TRequestBodyOptions = {
    postRequestBodyService: postRequestBodyService,
};

export class RequestBodyService {
    /**
     * @param requestBody A reusable request body
     * @throws ApiError
     */
    public static postRequestBodyService(requestBody?: IModelWithString): Promise<void> {
        // Validate required parameters

        return __request<void>(RequestBodyOptions.postRequestBodyService(requestBody), OpenAPI);
    }
}
"
`;

exports[`v3 should generate from different files: ./test/generated/v3_1/services/ResponseService.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
import type { TModelThatExtends } from './../models/./schemas/ModelThatExtends';
import type { IModelWithString } from './../models/./schemas/ModelWithString';
import { request as __request } from './../core/request';
import type { ApiRequestOptions } from './../core/ApiRequestOptions';
import { OpenAPI } from './../core/OpenAPI';
import { RequiredError } from './../core/errors';

const callWithResponse = (): ApiRequestOptions => ({
    method: 'GET',
    path: \`/api/v{api-version}/response\`,
});

const callWithDuplicateResponses = (): ApiRequestOptions => ({
    method: 'POST',
    path: \`/api/v{api-version}/response\`,
    errors: {
        500: \`Message for 500 error\`,
        501: \`Message for 501 error\`,
        502: \`Message for 502 error\`,
    },
});

const callWithResponses = (): ApiRequestOptions => ({
    method: 'PUT',
    path: \`/api/v{api-version}/response\`,
    errors: {
        500: \`Message for 500 error\`,
        501: \`Message for 501 error\`,
        502: \`Message for 502 error\`,
    },
});

export type TResponseOptions = {
    callWithResponse: () => ApiRequestOptions;
    callWithDuplicateResponses: () => ApiRequestOptions;
    callWithResponses: () => ApiRequestOptions;
};

export const ResponseOptions: TResponseOptions = {
    callWithResponse: callWithResponse,
    callWithDuplicateResponses: callWithDuplicateResponses,
    callWithResponses: callWithResponses,
};

export class ResponseService {
    /**
     * @returns IModelWithString
     * @throws ApiError
     */
    public static callWithResponse(): Promise<IModelWithString> {
        // Validate required parameters

        return __request<IModelWithString>(ResponseOptions.callWithResponse(), OpenAPI);
    }
    /**
     * @returns IModelWithString Message for default response
     * @throws ApiError
     */
    public static callWithDuplicateResponses(): Promise<IModelWithString> {
        // Validate required parameters

        return __request<IModelWithString>(ResponseOptions.callWithDuplicateResponses(), OpenAPI);
    }
    /**
     * @returns any Message for 200 response
     * @returns IModelWithString Message for default response
     * @returns TModelThatExtends Message for 201 response
     * @throws ApiError
     */
    public static callWithResponses(): Promise<
        | {
              readonly '@namespace.string'?: string;
              readonly '@namespace.integer'?: number;
              readonly value?: Array<IModelWithString>;
          }
        | IModelWithString
        | TModelThatExtends
    > {
        // Validate required parameters

        return __request<
            | {
                  readonly '@namespace.string'?: string;
                  readonly '@namespace.integer'?: number;
                  readonly value?: Array<IModelWithString>;
              }
            | IModelWithString
            | TModelThatExtends
        >(ResponseOptions.callWithResponses(), OpenAPI);
    }
}
"
`;

exports[`v3 should generate from different files: ./test/generated/v3_1/services/SimpleService.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
import { request as __request } from './../core/request';
import type { ApiRequestOptions } from './../core/ApiRequestOptions';
import { OpenAPI } from './../core/OpenAPI';
import { RequiredError } from './../core/errors';

const getCallWithoutParametersAndResponse = (): ApiRequestOptions => ({
    method: 'GET',
    path: \`/api/v{api-version}/simple\`,
});

const putCallWithoutParametersAndResponse = (): ApiRequestOptions => ({
    method: 'PUT',
    path: \`/api/v{api-version}/simple\`,
});

const postCallWithoutParametersAndResponse = (): ApiRequestOptions => ({
    method: 'POST',
    path: \`/api/v{api-version}/simple\`,
});

const deleteCallWithoutParametersAndResponse = (): ApiRequestOptions => ({
    method: 'DELETE',
    path: \`/api/v{api-version}/simple\`,
});

const optionsCallWithoutParametersAndResponse = (): ApiRequestOptions => ({
    method: 'OPTIONS',
    path: \`/api/v{api-version}/simple\`,
});

const headCallWithoutParametersAndResponse = (): ApiRequestOptions => ({
    method: 'HEAD',
    path: \`/api/v{api-version}/simple\`,
});

const patchCallWithoutParametersAndResponse = (): ApiRequestOptions => ({
    method: 'PATCH',
    path: \`/api/v{api-version}/simple\`,
});

export type TSimpleOptions = {
    getCallWithoutParametersAndResponse: () => ApiRequestOptions;
    putCallWithoutParametersAndResponse: () => ApiRequestOptions;
    postCallWithoutParametersAndResponse: () => ApiRequestOptions;
    deleteCallWithoutParametersAndResponse: () => ApiRequestOptions;
    optionsCallWithoutParametersAndResponse: () => ApiRequestOptions;
    headCallWithoutParametersAndResponse: () => ApiRequestOptions;
    patchCallWithoutParametersAndResponse: () => ApiRequestOptions;
};

export const SimpleOptions: TSimpleOptions = {
    getCallWithoutParametersAndResponse: getCallWithoutParametersAndResponse,
    putCallWithoutParametersAndResponse: putCallWithoutParametersAndResponse,
    postCallWithoutParametersAndResponse: postCallWithoutParametersAndResponse,
    deleteCallWithoutParametersAndResponse: deleteCallWithoutParametersAndResponse,
    optionsCallWithoutParametersAndResponse: optionsCallWithoutParametersAndResponse,
    headCallWithoutParametersAndResponse: headCallWithoutParametersAndResponse,
    patchCallWithoutParametersAndResponse: patchCallWithoutParametersAndResponse,
};

export class SimpleService {
    /**
     * @throws ApiError
     */
    public static getCallWithoutParametersAndResponse(): Promise<void> {
        // Validate required parameters

        return __request<void>(SimpleOptions.getCallWithoutParametersAndResponse(), OpenAPI);
    }
    /**
     * @throws ApiError
     */
    public static putCallWithoutParametersAndResponse(): Promise<void> {
        // Validate required parameters

        return __request<void>(SimpleOptions.putCallWithoutParametersAndResponse(), OpenAPI);
    }
    /**
     * @throws ApiError
     */
    public static postCallWithoutParametersAndResponse(): Promise<void> {
        // Validate required parameters

        return __request<void>(SimpleOptions.postCallWithoutParametersAndResponse(), OpenAPI);
    }
    /**
     * @throws ApiError
     */
    public static deleteCallWithoutParametersAndResponse(): Promise<void> {
        // Validate required parameters

        return __request<void>(SimpleOptions.deleteCallWithoutParametersAndResponse(), OpenAPI);
    }
    /**
     * @throws ApiError
     */
    public static optionsCallWithoutParametersAndResponse(): Promise<void> {
        // Validate required parameters

        return __request<void>(SimpleOptions.optionsCallWithoutParametersAndResponse(), OpenAPI);
    }
    /**
     * @throws ApiError
     */
    public static headCallWithoutParametersAndResponse(): Promise<void> {
        // Validate required parameters

        return __request<void>(SimpleOptions.headCallWithoutParametersAndResponse(), OpenAPI);
    }
    /**
     * @throws ApiError
     */
    public static patchCallWithoutParametersAndResponse(): Promise<void> {
        // Validate required parameters

        return __request<void>(SimpleOptions.patchCallWithoutParametersAndResponse(), OpenAPI);
    }
}
"
`;

exports[`v3 should generate from different files: ./test/generated/v3_1/services/TypesService.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
import { request as __request } from './../core/request';
import type { ApiRequestOptions } from './../core/ApiRequestOptions';
import { OpenAPI } from './../core/OpenAPI';
import { RequiredError } from './../core/errors';

const types = (
    parameterNumber?: number = 123,
    parameterString?: string | null = "'default'",
    parameterBoolean?: boolean | null = 'true',
    parameterObject?: any = 'null',
    parameterArray?: Array<string> | null,
    parameterDictionary?: any,
    parameterEnum?: 'Success' | 'Warning' | 'Error' | null,
    id?: number,
): ApiRequestOptions => ({
    method: 'GET',
    path: \`/api/v{api-version}/types\`,
    query: {
        parameterNumber: parameterNumber,
        parameterString: parameterString,
        parameterBoolean: parameterBoolean,
        parameterObject: parameterObject,
        parameterArray: parameterArray,
        parameterDictionary: parameterDictionary,
        parameterEnum: parameterEnum,
    },
});

export type TTypesOptions = {
    types: (
        parameterNumber?: number,
        parameterString?: string | null,
        parameterBoolean?: boolean | null,
        parameterObject?: any,
        parameterArray?: Array<string> | null,
        parameterDictionary?: any,
        parameterEnum?: 'Success' | 'Warning' | 'Error' | null,
        id?: number,
    ) => ApiRequestOptions;
};

export const TypesOptions: TTypesOptions = {
    types: types,
};

export class TypesService {
    /**
     * @param parameterNumber This is a number parameter
     * @param parameterString This is a string parameter
     * @param parameterBoolean This is a boolean parameter
     * @param parameterObject This is an object parameter
     * @param parameterArray This is an array parameter
     * @param parameterDictionary This is a dictionary parameter
     * @param parameterEnum This is an enum parameter
     * @param id This is a number parameter
     * @returns number Response is a simple number
     * @returns string Response is a simple string
     * @returns boolean Response is a simple boolean
     * @returns any Response is a simple object
     * @throws ApiError
     */
    public static types(
        parameterNumber?: number = 123,
        parameterString?: string | null = "'default'",
        parameterBoolean?: boolean | null = 'true',
        parameterObject?: any = 'null',
        parameterArray?: Array<string> | null,
        parameterDictionary?: any,
        parameterEnum?: 'Success' | 'Warning' | 'Error' | null,
        id?: number,
    ): Promise<number | string | boolean | any> {
        // Validate required parameters
        if (parameterNumber === null || parameterNumber === undefined) {
            throw new RequiredError('parameterNumber', 'Required parameter parameterNumber was not specified');
        }
        if (parameterString === null || parameterString === undefined) {
            throw new RequiredError('parameterString', 'Required parameter parameterString was not specified');
        }
        if (parameterBoolean === null || parameterBoolean === undefined) {
            throw new RequiredError('parameterBoolean', 'Required parameter parameterBoolean was not specified');
        }
        if (parameterObject === null || parameterObject === undefined) {
            throw new RequiredError('parameterObject', 'Required parameter parameterObject was not specified');
        }
        if (parameterArray === null || parameterArray === undefined) {
            throw new RequiredError('parameterArray', 'Required parameter parameterArray was not specified');
        }
        if (parameterDictionary === null || parameterDictionary === undefined) {
            throw new RequiredError('parameterDictionary', 'Required parameter parameterDictionary was not specified');
        }
        if (parameterEnum === null || parameterEnum === undefined) {
            throw new RequiredError('parameterEnum', 'Required parameter parameterEnum was not specified');
        }

        return __request<number | string | boolean | any>(
            TypesOptions.types(
                parameterNumber,
                parameterString,
                parameterBoolean,
                parameterObject,
                parameterArray,
                parameterDictionary,
                parameterEnum,
                id,
            ),
            OpenAPI,
        );
    }
}
"
`;

exports[`v3 should generate from different files: ./test/generated/v3_1/services/UploadService.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
import { request as __request } from './../core/request';
import type { ApiRequestOptions } from './../core/ApiRequestOptions';
import { OpenAPI } from './../core/OpenAPI';
import { RequiredError } from './../core/errors';

const uploadFile = (file?: Blob): ApiRequestOptions => ({
    method: 'POST',
    path: \`/api/v{api-version}/upload\`,
    formData: {
        file: file,
    },
});

export type TUploadOptions = {
    uploadFile: (file?: Blob) => ApiRequestOptions;
};

export const UploadOptions: TUploadOptions = {
    uploadFile: uploadFile,
};

export class UploadService {
    /**
     * @param file Supply a file reference for upload
     * @returns boolean
     * @throws ApiError
     */
    public static uploadFile(file?: Blob): Promise<boolean> {
        // Validate required parameters
        if (file === null || file === undefined) {
            throw new RequiredError('file', 'Required parameter file was not specified');
        }

        return __request<boolean>(UploadOptions.uploadFile(file), OpenAPI);
    }
}
"
`;

exports[`v3 should generate: ./test/generated/v3/core/ApiError.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
import type { ApiResult } from './ApiResult';

export class ApiError extends Error {
    public readonly url: string;
    public readonly status: number;
    public readonly statusText: string;
    public readonly body: any;

    constructor(response: ApiResult, message: string) {
        super(message);

        this.url = response.url;
        this.status = response.status;
        this.statusText = response.statusText;
        this.body = response.body;
    }
}"
`;

exports[`v3 should generate: ./test/generated/v3/core/ApiRequestOptions.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
export type ApiRequestOptions = {
    readonly method: 'GET' | 'PUT' | 'POST' | 'DELETE' | 'OPTIONS' | 'HEAD' | 'PATCH';
    readonly path: string;
    readonly cookies?: Record<string, any>;
    readonly headers?: Record<string, any>;
    readonly query?: Record<string, any>;
    readonly formData?: Record<string, any>;
    readonly body?: any;
    readonly mediaType?: string;
    readonly responseHeader?: string;
    // TODO TS2344: Redesign the logic for generating errors. Use the string value of the error code.
    // @ts-ignore
    readonly errors?: Record<number, string>;
}"
`;

exports[`v3 should generate: ./test/generated/v3/core/ApiResult.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
export type ApiResult = {
    readonly url: string;
    readonly ok: boolean;
    readonly status: number;
    readonly statusText: string;
    readonly body: any;
}"
`;

exports[`v3 should generate: ./test/generated/v3/core/HttpStatusCode.ts 1`] = `
"export enum EHTTP_STATUS_CODES {
    BAD_REQUEST = 400,
    UNAUTHORIZED = 401,
    FORBIDDEN = 403,
    NOT_FOUND = 404,
    INTERNAL_SERVER_ERROR = 500,
    BAD_GATEWAY = 502,
    SERVICE_UNAVAILABLE = 503,
}

export enum EHTTP_STATUS_NAME {
    BAD_REQUEST = 'Bad Request',
    UNAUTHORIZED = 'Unauthorized',
    FORBIDDEN = 'Forbidden',
    NOT_FOUND = 'Not Found',
    INTERNAL_SERVER_ERROR = 'Internal Server Error',
    BAD_GATEWAY = 'Bad Gateway',
    SERVICE_UNAVAILABLE = 'Service Unavailable',
}"
`;

exports[`v3 should generate: ./test/generated/v3/core/OpenAPI.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
import type { ApiRequestOptions } from './ApiRequestOptions';

type Resolver<T> = (options: ApiRequestOptions) => Promise<T>;
type Headers = Record<string, string>;

export type TOpenAPIConfig = {
    BASE: string;
    VERSION: string;
    WITH_CREDENTIALS: boolean;
    TOKEN?: string | Resolver<string>;
    USERNAME?: string | Resolver<string>;
    PASSWORD?: string | Resolver<string>;
    HEADERS?: Headers | Resolver<Headers>;
}

export const OpenAPI: TOpenAPIConfig = {
    BASE: 'http://localhost:3000/base',
    VERSION: '1.0',
    WITH_CREDENTIALS: false,
    TOKEN: undefined,
    USERNAME: undefined,
    PASSWORD: undefined,
    HEADERS: undefined,
};"
`;

exports[`v3 should generate: ./test/generated/v3/core/errors.ts 1`] = `
"export class RequiredError extends Error {
    constructor(
        public parameterName: string,
        message?: string
    ) {
        super(message || \`Required parameter "\${parameterName}" was not specified\`);
        this.name = 'RequiredError';
        Object.setPrototypeOf(this, RequiredError.prototype);
    }
}"
`;

exports[`v3 should generate: ./test/generated/v3/core/request.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
import { ApiError } from './ApiError';
import type { ApiRequestOptions } from './ApiRequestOptions';
import type { ApiResult } from './ApiResult';
import type { TOpenAPIConfig } from './OpenAPI';
import { EHTTP_STATUS_CODES, EHTTP_STATUS_NAME } from './HttpStatusCode';

function isDefined<T>(value: T | null | undefined): value is Exclude<T, null | undefined> {
    return value !== undefined && value !== null;
}

function isString(value: any): value is string {
    return typeof value === 'string';
}

function isStringWithValue(value: any): value is string {
    return isString(value) && value !== '';
}

function isBlob(value: any): value is Blob {
    return value instanceof Blob;
}

function getQueryString(params: Record<string, any>): string {
    const qs: string[] = [];
    Object.keys(params).forEach(key => {
        const value = params[key];
        if (isDefined(value)) {
            if (Array.isArray(value)) {
                value.forEach(value => {
                    qs.push(\`\${encodeURIComponent(key)}=\${encodeURIComponent(String(value))}\`);
                });
            } else {
                qs.push(\`\${encodeURIComponent(key)}=\${encodeURIComponent(String(value))}\`);
            }
        }
    });
    if (qs.length > 0) {
        return \`?\${qs.join('&')}\`;
    }
    return '';
}

function getUrl(options: ApiRequestOptions, config: TOpenAPIConfig): string {
    const path = options.path.replace('{api-version}', config.VERSION).replace(/[:]/g, '_');
    const url = \`\${config.BASE}\${path}\`;

    if (options.query) {
        return \`\${url}\${getQueryString(options.query)}\`;
    }
    return url;
}

function getFormData(params: Record<string, any>): FormData {
    const formData = new FormData();
    Object.keys(params).forEach(key => {
        const value = params[key];
        if (isDefined(value)) {
            formData.append(key, value);
        }
    });
    return formData;
}

type Resolver<T> = (options: ApiRequestOptions) => Promise<T>;

async function resolve<T>(options: ApiRequestOptions, resolver?: T | Resolver<T>): Promise<T | undefined> {
    if (typeof resolver === 'function') {
        return (resolver as Resolver<T>)(options);
    }
    return resolver;
}

async function getHeaders(options: ApiRequestOptions, config: TOpenAPIConfig): Promise<Headers> {
    const token = await resolve(options, config.TOKEN);
    const username = await resolve(options, config.USERNAME);
    const password = await resolve(options, config.PASSWORD);
    const defaultHeaders = await resolve(options, config.HEADERS);

    const headers = new Headers({
        Accept: 'application/json',
        ...defaultHeaders,
        ...options.headers,
    });

    if (isStringWithValue(token)) {
        headers.append('Authorization', \`Bearer \${token}\`);
    }

    if (isStringWithValue(username) && isStringWithValue(password)) {
        const credentials = btoa(\`\${username}:\${password}\`);
        headers.append('Authorization', \`Basic \${credentials}\`);
    }

    if (options.body) {
        if (options.mediaType) {
            headers.append('Content-Type', options.mediaType);
        } else if (isBlob(options.body)) {
            headers.append('Content-Type', options.body.type || 'application/octet-stream');
        } else if (isString(options.body)) {
            headers.append('Content-Type', 'text/plain');
        } else {
            headers.append('Content-Type', 'application/json');
        }
    }
    return headers;
}

function getRequestBody(options: ApiRequestOptions): BodyInit | undefined {
    if (options.formData) {
        return getFormData(options.formData);
    }
    if (options.body) {
        if (options.mediaType?.includes('/json')) {
            return JSON.stringify(options.body)
        } else if (isString(options.body) || isBlob(options.body)) {
            return options.body;
        } else {
            return JSON.stringify(options.body);
        }
    }
    return undefined;
}

async function sendRequest(options: ApiRequestOptions, url: string, config: TOpenAPIConfig): Promise<Response> {

    const request: RequestInit = {
        method: options.method,
        headers: await getHeaders(options, config),
        body: getRequestBody(options),
    };

    if (config.WITH_CREDENTIALS) {
        request.credentials = 'include';
    }


    return await fetch(url, request);
}

function getResponseHeader(response: Response, responseHeader?: string): string | null {
    if (responseHeader) {
        const content = response.headers.get(responseHeader);
        if (isString(content)) {
            return content;
        }
    }
    return null;
}

async function getResponseBody(response: Response): Promise<any> {
    try {
        const contentType = response.headers.get('Content-Type');
        if (contentType) {
            const isJSON = contentType.toLowerCase().startsWith('application/json');
            if (isJSON) {
                return await response.json();
            } else {
                return await response.text();
            }
        }
    } catch (error) {
        console.error(error);
    }
    return null;
}

function catchErrors(options: ApiRequestOptions, result: ApiResult): void {
    const errors: Record<string, string> = {
        [EHTTP_STATUS_CODES.BAD_GATEWAY]: EHTTP_STATUS_NAME.BAD_GATEWAY,
        [EHTTP_STATUS_CODES.BAD_REQUEST]: EHTTP_STATUS_NAME.BAD_REQUEST,
        [EHTTP_STATUS_CODES.FORBIDDEN]: EHTTP_STATUS_NAME.FORBIDDEN,
        [EHTTP_STATUS_CODES.INTERNAL_SERVER_ERROR]: EHTTP_STATUS_NAME.INTERNAL_SERVER_ERROR,
        [EHTTP_STATUS_CODES.NOT_FOUND]: EHTTP_STATUS_NAME.NOT_FOUND,
        [EHTTP_STATUS_CODES.SERVICE_UNAVAILABLE]: EHTTP_STATUS_NAME.SERVICE_UNAVAILABLE,
        [EHTTP_STATUS_CODES.UNAUTHORIZED]: EHTTP_STATUS_NAME.UNAUTHORIZED,
        ...options.errors,
    }

    const error = errors[result.status];
    if (error) {
        throw new ApiError(result, error);
    }

    if (!result.ok) {
        throw new ApiError(result, 'Generic Error');
    }
}

/**
 * Request using fetch client
 * @param config The OpenAPI configuration object
 * @param options The request options from the the service
 * @returns ApiResult
 * @throws ApiError
 */
export async function request<T>(options: ApiRequestOptions, config: TOpenAPIConfig): Promise<T> {
    return new Promise(async (resolve, reject) => {
        try {
            const url = getUrl(options, config);
            const response = await sendRequest(options, url, config);
            const responseBody = await getResponseBody(response);
            const responseHeader = getResponseHeader(response, options.responseHeader);

            const result: ApiResult = {
                url,
                ok: response.ok,
                status: response.status,
                statusText: response.statusText,
                body: responseHeader || responseBody,
            };

            catchErrors(options, result);
            resolve(result.body);
        } catch (error) {
            reject(error);
        }
    });
}
"
`;

exports[`v3 should generate: ./test/generated/v3/index.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
export { ApiError } from '././core/ApiError';
export { OpenAPI } from '././core/OpenAPI';
export type { TOpenAPIConfig } from '././core/OpenAPI';

export { EEnumWithNumbers } from '././models/EnumWithNumbers';
export { EEnumWithStrings } from '././models/EnumWithStrings';
export { EEnumWithStringsWithType } from '././models/EnumWithStringsWithType';
export type { IModelWithArray } from '././models/ModelWithArray';
export type { IModelWithDictionary } from '././models/ModelWithDictionary';
export { IModelWithEnum } from '././models/ModelWithEnum';
export type { IModelWithString } from '././models/ModelWithString';
export type { TArrayWithArray } from '././models/ArrayWithArray';
export type { TModelThatExtends } from '././models/ModelThatExtends';
export type { TModelThatExtendsExtends } from '././models/ModelThatExtendsExtends';

export { EEnumWithNumbersSchema } from '././schemas/EnumWithNumbersSchema';
export { EEnumWithStringsSchema } from '././schemas/EnumWithStringsSchema';
export { EEnumWithStringsWithTypeSchema } from '././schemas/EnumWithStringsWithTypeSchema';
export { IModelWithArraySchema } from '././schemas/ModelWithArraySchema';
export { IModelWithDictionarySchema } from '././schemas/ModelWithDictionarySchema';
export { IModelWithEnumSchema } from '././schemas/ModelWithEnumSchema';
export { IModelWithStringSchema } from '././schemas/ModelWithStringSchema';
export { TArrayWithArraySchema } from '././schemas/ArrayWithArraySchema';
export { TModelThatExtendsSchema } from '././schemas/ModelThatExtendsSchema';
export { TModelThatExtendsExtendsSchema } from '././schemas/ModelThatExtendsExtendsSchema';

export { SimpleService } from '././services/SimpleService';
export { ParametersService } from '././services/ParametersService';
export { RequestBodyService } from '././services/RequestBodyService';
export { DefaultsService } from '././services/DefaultsService';
export { DuplicateService } from '././services/DuplicateService';
export { NoContentService } from '././services/NoContentService';
export { ResponseService } from '././services/ResponseService';
export { CollectionFormatService } from '././services/CollectionFormatService';
export { TypesService } from '././services/TypesService';
export { UploadService } from '././services/UploadService';
export { ComplexService } from '././services/ComplexService';
export { MultipartService } from '././services/MultipartService';
export { HeaderService } from '././services/HeaderService';
export { EnumsService } from '././services/EnumsService';
"
`;

exports[`v3 should generate: ./test/generated/v3/models/ArrayWithArray.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */

import type { IModelWithString } from '././ModelWithString';

/**
 * This is a simple array containing an array
 */
export type TArrayWithArray = Array<Array<IModelWithString>>;
"
`;

exports[`v3 should generate: ./test/generated/v3/models/EnumWithNumbers.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */

/**
 * This is a simple enum with numbers
 */
export enum EEnumWithNumbers {
    '_1' = 1,
    '_2' = 2,
    '_3' = 3,
    '_1.1' = 1.1,
    '_1.2' = 1.2,
    '_1.3' = 1.3,
    '_100' = 100,
    '_200' = 200,
    '_300' = 300,
    '_-100' = -100,
    '_-200' = -200,
    '_-300' = -300,
    '_-1.1' = -1.1,
    '_-1.2' = -1.2,
    '_-1.3' = -1.3,
}
"
`;

exports[`v3 should generate: ./test/generated/v3/models/EnumWithStrings.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */

/**
 * This is a simple enum with strings
 */
export enum EEnumWithStrings {
    SUCCESS = 'Success',
    WARNING = 'Warning',
    ERROR = 'Error',
}
"
`;

exports[`v3 should generate: ./test/generated/v3/models/EnumWithStringsWithType.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */

/**
 * This is a simple enum with strings and type
 */
export enum EEnumWithStringsWithType {
    VALUE1 = 'VALUE1',
    VALUE2 = 'VALUE2',
}
"
`;

exports[`v3 should generate: ./test/generated/v3/models/ModelThatExtends.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */

import type { IModelWithString } from '././ModelWithString';

/**
 * This is a model that extends another model
 */
export type TModelThatExtends = IModelWithString & {
    propExtendsA?: string;
    propExtendsB?: IModelWithString;
};
"
`;

exports[`v3 should generate: ./test/generated/v3/models/ModelThatExtendsExtends.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */

import type { TModelThatExtends } from '././ModelThatExtends';
import type { IModelWithString } from '././ModelWithString';

/**
 * This is a model that extends another model
 */
export type TModelThatExtendsExtends = IModelWithString &
    TModelThatExtends & {
        propExtendsC?: string;
        propExtendsD?: IModelWithString;
    };
"
`;

exports[`v3 should generate: ./test/generated/v3/models/ModelWithArray.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */

import type { IModelWithString } from '././ModelWithString';

/**
 * This is a model with one property containing an array
 */
export interface IModelWithArray {
    prop?: Array<IModelWithString>;
    propWithFile?: Array<Blob>;
    propWithNumber?: Array<number>;
}
"
`;

exports[`v3 should generate: ./test/generated/v3/models/ModelWithDictionary.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */

/**
 * This is a model with one property containing a dictionary
 */
export interface IModelWithDictionary {
    prop?: Record<string, string>;
}
"
`;

exports[`v3 should generate: ./test/generated/v3/models/ModelWithEnum.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */

/**
 * This is a model with one enum
 */
export interface IModelWithEnum {
    /**
     * This is a simple enum with strings
     */
    test?: IModelWithEnum.ETest;
    /**
     * These are the HTTP error code enums
     */
    statusCode?: IModelWithEnum.EStatusCode;
    /**
     * Simple boolean enum
     */
    bool?: boolean;
}

export namespace IModelWithEnum {
    /**
     * This is a simple enum with strings
     */
    export enum ETest {
        SUCCESS = 'Success',
        WARNING = 'Warning',
        ERROR = 'Error',
    }

    /**
     * These are the HTTP error code enums
     */
    export enum EStatusCode {
        _100 = '100',
        _200_FOO = '200 FOO',
        _300_FOO_BAR = '300 FOO_BAR',
        _400_FOO_BAR = '400 foo-bar',
        _500_FOO_BAR = '500 foo.bar',
        _600_FOO_BAR = '600 foo&bar',
    }
}
"
`;

exports[`v3 should generate: ./test/generated/v3/models/ModelWithString.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */

/**
 * This is a model with one string property
 */
export interface IModelWithString {
    /**
     * This is a simple string property
     */
    prop?: string;
}
"
`;

exports[`v3 should generate: ./test/generated/v3/schemas/ArrayWithArraySchema.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
export const TArrayWithArraySchema = {
    type: 'array',
    contains: {
        type: 'array',
        contains: {
            type: 'IModelWithString',
        },
    },
};
"
`;

exports[`v3 should generate: ./test/generated/v3/schemas/EnumWithNumbersSchema.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
export const EEnumWithNumbersSchema = {
    type: 'Enum',
};
"
`;

exports[`v3 should generate: ./test/generated/v3/schemas/EnumWithStringsSchema.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
export const EEnumWithStringsSchema = {
    type: 'Enum',
};
"
`;

exports[`v3 should generate: ./test/generated/v3/schemas/EnumWithStringsWithTypeSchema.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
export const EEnumWithStringsWithTypeSchema = {
    type: 'Enum',
};
"
`;

exports[`v3 should generate: ./test/generated/v3/schemas/ModelThatExtendsExtendsSchema.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
export const TModelThatExtendsExtendsSchema = {
    type: 'all-of',
    contains: [
        {
            type: 'IModelWithString',
        },
        {
            type: 'TModelThatExtends',
        },
        {
            properties: {
                propExtendsC: {
                    type: 'string',
                },
                propExtendsD: {
                    type: 'IModelWithString',
                },
            },
        },
    ],
};
"
`;

exports[`v3 should generate: ./test/generated/v3/schemas/ModelThatExtendsSchema.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
export const TModelThatExtendsSchema = {
    type: 'all-of',
    contains: [
        {
            type: 'IModelWithString',
        },
        {
            properties: {
                propExtendsA: {
                    type: 'string',
                },
                propExtendsB: {
                    type: 'IModelWithString',
                },
            },
        },
    ],
};
"
`;

exports[`v3 should generate: ./test/generated/v3/schemas/ModelWithArraySchema.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
export const IModelWithArraySchema = {
    properties: {
        prop: {
            type: 'array',
            contains: {
                type: 'IModelWithString',
            },
        },
        propWithFile: {
            type: 'array',
            contains: {
                type: 'File',
            },
        },
        propWithNumber: {
            type: 'array',
            contains: {
                type: 'number',
            },
        },
    },
};
"
`;

exports[`v3 should generate: ./test/generated/v3/schemas/ModelWithDictionarySchema.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
export const IModelWithDictionarySchema = {
    properties: {
        prop: {
            type: 'dictionary',
            contains: {
                type: 'string',
            },
        },
    },
};
"
`;

exports[`v3 should generate: ./test/generated/v3/schemas/ModelWithEnumSchema.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
export const IModelWithEnumSchema = {
    properties: {
        test: {
            type: 'Enum',
        },
        statusCode: {
            type: 'Enum',
        },
        bool: {
            type: 'boolean',
        },
    },
};
"
`;

exports[`v3 should generate: ./test/generated/v3/schemas/ModelWithStringSchema.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
export const IModelWithStringSchema = {
    properties: {
        prop: {
            type: 'string',
        },
    },
};
"
`;

exports[`v3 should generate: ./test/generated/v3/services/CollectionFormatService.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
import { request as __request } from './../core/request';
import type { ApiRequestOptions } from './../core/ApiRequestOptions';
import { OpenAPI } from './../core/OpenAPI';
import { RequiredError } from './../core/errors';

const collectionFormat = (
    parameterArrayCsv?: Array<string> | null,
    parameterArraySsv?: Array<string> | null,
    parameterArrayTsv?: Array<string> | null,
    parameterArrayPipes?: Array<string> | null,
    parameterArrayMulti?: Array<string> | null,
): ApiRequestOptions => ({
    method: 'GET',
    path: \`/api/v{api-version}/collectionFormat\`,
    query: {
        parameterArrayCSV: parameterArrayCsv,
        parameterArraySSV: parameterArraySsv,
        parameterArrayTSV: parameterArrayTsv,
        parameterArrayPipes: parameterArrayPipes,
        parameterArrayMulti: parameterArrayMulti,
    },
});

export type TCollectionFormatOptions = {
    collectionFormat: (
        parameterArrayCsv?: Array<string> | null,
        parameterArraySsv?: Array<string> | null,
        parameterArrayTsv?: Array<string> | null,
        parameterArrayPipes?: Array<string> | null,
        parameterArrayMulti?: Array<string> | null,
    ) => ApiRequestOptions;
};

export const CollectionFormatOptions: TCollectionFormatOptions = {
    collectionFormat: collectionFormat,
};

export class CollectionFormatService {
    /**
     * @param parameterArrayCsv This is an array parameter that is send as csv format (comma-separated values)
     * @param parameterArraySsv This is an array parameter that is send as ssv format (space-separated values)
     * @param parameterArrayTsv This is an array parameter that is send as tsv format (tab-separated values)
     * @param parameterArrayPipes This is an array parameter that is send as pipes format (pipe-separated values)
     * @param parameterArrayMulti This is an array parameter that is send as multi format (multiple parameter instances)
     * @throws ApiError
     */
    public static collectionFormat(
        parameterArrayCsv?: Array<string> | null,
        parameterArraySsv?: Array<string> | null,
        parameterArrayTsv?: Array<string> | null,
        parameterArrayPipes?: Array<string> | null,
        parameterArrayMulti?: Array<string> | null,
    ): Promise<void> {
        // Validate required parameters
        if (parameterArrayCsv === null || parameterArrayCsv === undefined) {
            throw new RequiredError('parameterArrayCsv', 'Required parameter parameterArrayCsv was not specified');
        }
        if (parameterArraySsv === null || parameterArraySsv === undefined) {
            throw new RequiredError('parameterArraySsv', 'Required parameter parameterArraySsv was not specified');
        }
        if (parameterArrayTsv === null || parameterArrayTsv === undefined) {
            throw new RequiredError('parameterArrayTsv', 'Required parameter parameterArrayTsv was not specified');
        }
        if (parameterArrayPipes === null || parameterArrayPipes === undefined) {
            throw new RequiredError('parameterArrayPipes', 'Required parameter parameterArrayPipes was not specified');
        }
        if (parameterArrayMulti === null || parameterArrayMulti === undefined) {
            throw new RequiredError('parameterArrayMulti', 'Required parameter parameterArrayMulti was not specified');
        }

        return __request<void>(
            CollectionFormatOptions.collectionFormat(
                parameterArrayCsv,
                parameterArraySsv,
                parameterArrayTsv,
                parameterArrayPipes,
                parameterArrayMulti,
            ),
            OpenAPI,
        );
    }
}
"
`;

exports[`v3 should generate: ./test/generated/v3/services/ComplexService.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
import type { IModelWithArray } from './../models/./ModelWithArray';
import type { IModelWithDictionary } from './../models/./ModelWithDictionary';
import type { IModelWithEnum } from './../models/./ModelWithEnum';
import type { IModelWithString } from './../models/./ModelWithString';
import { request as __request } from './../core/request';
import type { ApiRequestOptions } from './../core/ApiRequestOptions';
import { OpenAPI } from './../core/OpenAPI';
import { RequiredError } from './../core/errors';

const complexTypes = (
    parameterObject?: {
        first?: {
            second?: {
                third?: string;
            };
        };
    },
    parameterReference?: IModelWithString,
): ApiRequestOptions => ({
    method: 'GET',
    path: \`/api/v{api-version}/complex\`,
    query: {
        parameterObject: parameterObject,
        parameterReference: parameterReference,
    },
    errors: {
        400: \`400 server error\`,
        500: \`500 server error\`,
    },
});

const complexParams = (
    id?: number,
    requestBody?: {
        readonly key?: string | null;
        name?: string | null;
        enabled?: boolean;
        readonly type?: 'Monkey' | 'Horse' | 'Bird';
        listOfModels?: Array<IModelWithString> | null;
        listOfStrings?: Array<string> | null;
        parameters?: IModelWithString | IModelWithEnum | IModelWithArray | IModelWithDictionary;
        readonly user?: {
            readonly id?: number;
            readonly name?: string | null;
        };
    },
): ApiRequestOptions => ({
    method: 'PUT',
    path: \`/api/v{api-version}/complex/\${id}\`,
    body: requestBody,
    mediaType: 'application/json-patch+json',
});

export type TComplexOptions = {
    complexTypes: (
        parameterObject?: {
            first?: {
                second?: {
                    third?: string;
                };
            };
        },
        parameterReference?: IModelWithString,
    ) => ApiRequestOptions;
    complexParams: (
        id?: number,
        requestBody?: {
            readonly key?: string | null;
            name?: string | null;
            enabled?: boolean;
            readonly type?: 'Monkey' | 'Horse' | 'Bird';
            listOfModels?: Array<IModelWithString> | null;
            listOfStrings?: Array<string> | null;
            parameters?: IModelWithString | IModelWithEnum | IModelWithArray | IModelWithDictionary;
            readonly user?: {
                readonly id?: number;
                readonly name?: string | null;
            };
        },
    ) => ApiRequestOptions;
};

export const ComplexOptions: TComplexOptions = {
    complexTypes: complexTypes,
    complexParams: complexParams,
};

export class ComplexService {
    /**
     * @param parameterObject Parameter containing object
     * @param parameterReference Parameter containing reference
     * @returns IModelWithString Successful response
     * @throws ApiError
     */
    public static complexTypes(
        parameterObject?: {
            first?: {
                second?: {
                    third?: string;
                };
            };
        },
        parameterReference?: IModelWithString,
    ): Promise<Array<IModelWithString>> {
        // Validate required parameters
        if (parameterObject === null || parameterObject === undefined) {
            throw new RequiredError('parameterObject', 'Required parameter parameterObject was not specified');
        }
        if (parameterReference === null || parameterReference === undefined) {
            throw new RequiredError('parameterReference', 'Required parameter parameterReference was not specified');
        }

        return __request<Array<IModelWithString>>(
            ComplexOptions.complexTypes(parameterObject, parameterReference),
            OpenAPI,
        );
    }
    /**
     * @param id
     * @param requestBody
     * @returns IModelWithString Success
     * @throws ApiError
     */
    public static complexParams(
        id?: number,
        requestBody?: {
            readonly key?: string | null;
            name?: string | null;
            enabled?: boolean;
            readonly type?: 'Monkey' | 'Horse' | 'Bird';
            listOfModels?: Array<IModelWithString> | null;
            listOfStrings?: Array<string> | null;
            parameters?: IModelWithString | IModelWithEnum | IModelWithArray | IModelWithDictionary;
            readonly user?: {
                readonly id?: number;
                readonly name?: string | null;
            };
        },
    ): Promise<IModelWithString> {
        // Validate required parameters
        if (id === null || id === undefined) {
            throw new RequiredError('id', 'Required parameter id was not specified');
        }

        return __request<IModelWithString>(ComplexOptions.complexParams(id, requestBody), OpenAPI);
    }
}
"
`;

exports[`v3 should generate: ./test/generated/v3/services/DefaultsService.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
import type { IModelWithString } from './../models/./ModelWithString';
import { request as __request } from './../core/request';
import type { ApiRequestOptions } from './../core/ApiRequestOptions';
import { OpenAPI } from './../core/OpenAPI';
import { RequiredError } from './../core/errors';

const callWithDefaultParameters = (
    parameterString?: string | null = "'Hello World!'",
    parameterNumber?: number | null = 123,
    parameterBoolean?: boolean | null = 'true',
    parameterEnum?: 'Success' | 'Warning' | 'Error' = "'Success'",
    parameterModel?: IModelWithString | null = '{\\n    "prop": "Hello World!"\\n}',
): ApiRequestOptions => ({
    method: 'GET',
    path: \`/api/v{api-version}/defaults\`,
    query: {
        parameterString: parameterString,
        parameterNumber: parameterNumber,
        parameterBoolean: parameterBoolean,
        parameterEnum: parameterEnum,
        parameterModel: parameterModel,
    },
});

const callWithDefaultOptionalParameters = (
    parameterString?: string = "'Hello World!'",
    parameterNumber?: number = 123,
    parameterBoolean?: boolean = 'true',
    parameterEnum?: 'Success' | 'Warning' | 'Error' = "'Success'",
    parameterModel?: IModelWithString = '{\\n    "prop": "Hello World!"\\n}',
): ApiRequestOptions => ({
    method: 'POST',
    path: \`/api/v{api-version}/defaults\`,
    query: {
        parameterString: parameterString,
        parameterNumber: parameterNumber,
        parameterBoolean: parameterBoolean,
        parameterEnum: parameterEnum,
        parameterModel: parameterModel,
    },
});

const callToTestOrderOfParams = (
    parameterOptionalStringWithDefault?: string = "'Hello World!'",
    parameterOptionalStringWithEmptyDefault?: string = "''",
    parameterOptionalStringWithNoDefault?: string,
    parameterStringWithDefault?: string = "'Hello World!'",
    parameterStringWithEmptyDefault?: string = "''",
    parameterStringWithNoDefault?: string,
): ApiRequestOptions => ({
    method: 'PUT',
    path: \`/api/v{api-version}/defaults\`,
    query: {
        parameterOptionalStringWithDefault: parameterOptionalStringWithDefault,
        parameterOptionalStringWithEmptyDefault: parameterOptionalStringWithEmptyDefault,
        parameterOptionalStringWithNoDefault: parameterOptionalStringWithNoDefault,
        parameterStringWithDefault: parameterStringWithDefault,
        parameterStringWithEmptyDefault: parameterStringWithEmptyDefault,
        parameterStringWithNoDefault: parameterStringWithNoDefault,
    },
});

export type TDefaultsOptions = {
    callWithDefaultParameters: (
        parameterString?: string | null,
        parameterNumber?: number | null,
        parameterBoolean?: boolean | null,
        parameterEnum?: 'Success' | 'Warning' | 'Error',
        parameterModel?: IModelWithString | null,
    ) => ApiRequestOptions;
    callWithDefaultOptionalParameters: (
        parameterString?: string,
        parameterNumber?: number,
        parameterBoolean?: boolean,
        parameterEnum?: 'Success' | 'Warning' | 'Error',
        parameterModel?: IModelWithString,
    ) => ApiRequestOptions;
    callToTestOrderOfParams: (
        parameterOptionalStringWithDefault?: string,
        parameterOptionalStringWithEmptyDefault?: string,
        parameterOptionalStringWithNoDefault?: string,
        parameterStringWithDefault?: string,
        parameterStringWithEmptyDefault?: string,
        parameterStringWithNoDefault?: string,
    ) => ApiRequestOptions;
};

export const DefaultsOptions: TDefaultsOptions = {
    callWithDefaultParameters: callWithDefaultParameters,
    callWithDefaultOptionalParameters: callWithDefaultOptionalParameters,
    callToTestOrderOfParams: callToTestOrderOfParams,
};

export class DefaultsService {
    /**
     * @param parameterString This is a simple string with default value
     * @param parameterNumber This is a simple number with default value
     * @param parameterBoolean This is a simple boolean with default value
     * @param parameterEnum This is a simple enum with default value
     * @param parameterModel This is a simple model with default value
     * @throws ApiError
     */
    public static callWithDefaultParameters(
        parameterString?: string | null = "'Hello World!'",
        parameterNumber?: number | null = 123,
        parameterBoolean?: boolean | null = 'true',
        parameterEnum?: 'Success' | 'Warning' | 'Error' = "'Success'",
        parameterModel?: IModelWithString | null = '{\\n    "prop": "Hello World!"\\n}',
    ): Promise<void> {
        // Validate required parameters
        if (parameterString === null || parameterString === undefined) {
            throw new RequiredError('parameterString', 'Required parameter parameterString was not specified');
        }
        if (parameterNumber === null || parameterNumber === undefined) {
            throw new RequiredError('parameterNumber', 'Required parameter parameterNumber was not specified');
        }
        if (parameterBoolean === null || parameterBoolean === undefined) {
            throw new RequiredError('parameterBoolean', 'Required parameter parameterBoolean was not specified');
        }
        if (parameterEnum === null || parameterEnum === undefined) {
            throw new RequiredError('parameterEnum', 'Required parameter parameterEnum was not specified');
        }

        return __request<void>(
            DefaultsOptions.callWithDefaultParameters(
                parameterString,
                parameterNumber,
                parameterBoolean,
                parameterEnum,
                parameterModel,
            ),
            OpenAPI,
        );
    }
    /**
     * @param parameterString This is a simple string that is optional with default value
     * @param parameterNumber This is a simple number that is optional with default value
     * @param parameterBoolean This is a simple boolean that is optional with default value
     * @param parameterEnum This is a simple enum that is optional with default value
     * @param parameterModel This is a simple model that is optional with default value
     * @throws ApiError
     */
    public static callWithDefaultOptionalParameters(
        parameterString?: string = "'Hello World!'",
        parameterNumber?: number = 123,
        parameterBoolean?: boolean = 'true',
        parameterEnum?: 'Success' | 'Warning' | 'Error' = "'Success'",
        parameterModel?: IModelWithString = '{\\n    "prop": "Hello World!"\\n}',
    ): Promise<void> {
        // Validate required parameters
        if (parameterString === null || parameterString === undefined) {
            throw new RequiredError('parameterString', 'Required parameter parameterString was not specified');
        }
        if (parameterNumber === null || parameterNumber === undefined) {
            throw new RequiredError('parameterNumber', 'Required parameter parameterNumber was not specified');
        }
        if (parameterBoolean === null || parameterBoolean === undefined) {
            throw new RequiredError('parameterBoolean', 'Required parameter parameterBoolean was not specified');
        }
        if (parameterEnum === null || parameterEnum === undefined) {
            throw new RequiredError('parameterEnum', 'Required parameter parameterEnum was not specified');
        }

        return __request<void>(
            DefaultsOptions.callWithDefaultOptionalParameters(
                parameterString,
                parameterNumber,
                parameterBoolean,
                parameterEnum,
                parameterModel,
            ),
            OpenAPI,
        );
    }
    /**
     * @param parameterOptionalStringWithDefault This is a optional string with default
     * @param parameterOptionalStringWithEmptyDefault This is a optional string with empty default
     * @param parameterOptionalStringWithNoDefault This is a optional string with no default
     * @param parameterStringWithDefault This is a string with default
     * @param parameterStringWithEmptyDefault This is a string with empty default
     * @param parameterStringWithNoDefault This is a string with no default
     * @throws ApiError
     */
    public static callToTestOrderOfParams(
        parameterOptionalStringWithDefault?: string = "'Hello World!'",
        parameterOptionalStringWithEmptyDefault?: string = "''",
        parameterOptionalStringWithNoDefault?: string,
        parameterStringWithDefault?: string = "'Hello World!'",
        parameterStringWithEmptyDefault?: string = "''",
        parameterStringWithNoDefault?: string,
    ): Promise<void> {
        // Validate required parameters
        if (parameterOptionalStringWithDefault === null || parameterOptionalStringWithDefault === undefined) {
            throw new RequiredError(
                'parameterOptionalStringWithDefault',
                'Required parameter parameterOptionalStringWithDefault was not specified',
            );
        }
        if (parameterOptionalStringWithEmptyDefault === null || parameterOptionalStringWithEmptyDefault === undefined) {
            throw new RequiredError(
                'parameterOptionalStringWithEmptyDefault',
                'Required parameter parameterOptionalStringWithEmptyDefault was not specified',
            );
        }
        if (parameterStringWithDefault === null || parameterStringWithDefault === undefined) {
            throw new RequiredError(
                'parameterStringWithDefault',
                'Required parameter parameterStringWithDefault was not specified',
            );
        }
        if (parameterStringWithEmptyDefault === null || parameterStringWithEmptyDefault === undefined) {
            throw new RequiredError(
                'parameterStringWithEmptyDefault',
                'Required parameter parameterStringWithEmptyDefault was not specified',
            );
        }
        if (parameterStringWithNoDefault === null || parameterStringWithNoDefault === undefined) {
            throw new RequiredError(
                'parameterStringWithNoDefault',
                'Required parameter parameterStringWithNoDefault was not specified',
            );
        }

        return __request<void>(
            DefaultsOptions.callToTestOrderOfParams(
                parameterOptionalStringWithDefault,
                parameterOptionalStringWithEmptyDefault,
                parameterOptionalStringWithNoDefault,
                parameterStringWithDefault,
                parameterStringWithEmptyDefault,
                parameterStringWithNoDefault,
            ),
            OpenAPI,
        );
    }
}
"
`;

exports[`v3 should generate: ./test/generated/v3/services/DuplicateService.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
import { request as __request } from './../core/request';
import type { ApiRequestOptions } from './../core/ApiRequestOptions';
import { OpenAPI } from './../core/OpenAPI';
import { RequiredError } from './../core/errors';

const duplicateName = (): ApiRequestOptions => ({
    method: 'GET',
    path: \`/api/v{api-version}/duplicate\`,
});

const duplicateName1 = (): ApiRequestOptions => ({
    method: 'POST',
    path: \`/api/v{api-version}/duplicate\`,
});

const duplicateName2 = (): ApiRequestOptions => ({
    method: 'PUT',
    path: \`/api/v{api-version}/duplicate\`,
});

const duplicateName3 = (): ApiRequestOptions => ({
    method: 'DELETE',
    path: \`/api/v{api-version}/duplicate\`,
});

export type TDuplicateOptions = {
    duplicateName: () => ApiRequestOptions;
    duplicateName1: () => ApiRequestOptions;
    duplicateName2: () => ApiRequestOptions;
    duplicateName3: () => ApiRequestOptions;
};

export const DuplicateOptions: TDuplicateOptions = {
    duplicateName: duplicateName,
    duplicateName1: duplicateName1,
    duplicateName2: duplicateName2,
    duplicateName3: duplicateName3,
};

export class DuplicateService {
    /**
     * @throws ApiError
     */
    public static duplicateName(): Promise<void> {
        // Validate required parameters

        return __request<void>(DuplicateOptions.duplicateName(), OpenAPI);
    }
    /**
     * @throws ApiError
     */
    public static duplicateName1(): Promise<void> {
        // Validate required parameters

        return __request<void>(DuplicateOptions.duplicateName1(), OpenAPI);
    }
    /**
     * @throws ApiError
     */
    public static duplicateName2(): Promise<void> {
        // Validate required parameters

        return __request<void>(DuplicateOptions.duplicateName2(), OpenAPI);
    }
    /**
     * @throws ApiError
     */
    public static duplicateName3(): Promise<void> {
        // Validate required parameters

        return __request<void>(DuplicateOptions.duplicateName3(), OpenAPI);
    }
}
"
`;

exports[`v3 should generate: ./test/generated/v3/services/EnumsService.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
import type { EEnumWithNumbers } from './../models/./EnumWithNumbers';
import type { EEnumWithStrings } from './../models/./EnumWithStrings';
import type { EEnumWithStringsWithType } from './../models/./EnumWithStringsWithType';
import { request as __request } from './../core/request';
import type { ApiRequestOptions } from './../core/ApiRequestOptions';
import { OpenAPI } from './../core/OpenAPI';
import { RequiredError } from './../core/errors';

const callWithEnums = (requestBody?: {
    enumWithNumbers?: EEnumWithNumbers;
    enumWithStrings?: EEnumWithStrings;
    enumWithStringsWithType?: EEnumWithStringsWithType;
}): ApiRequestOptions => ({
    method: 'POST',
    path: \`/api/v{api-version}/enums\`,
    body: requestBody,
    mediaType: 'application/json; charset=utf-8',
});

export type TEnumsOptions = {
    callWithEnums: (requestBody?: {
        enumWithNumbers?: EEnumWithNumbers;
        enumWithStrings?: EEnumWithStrings;
        enumWithStringsWithType?: EEnumWithStringsWithType;
    }) => ApiRequestOptions;
};

export const EnumsOptions: TEnumsOptions = {
    callWithEnums: callWithEnums,
};

export class EnumsService {
    /**
     * @param requestBody
     * @throws ApiError
     */
    public static callWithEnums(requestBody?: {
        enumWithNumbers?: EEnumWithNumbers;
        enumWithStrings?: EEnumWithStrings;
        enumWithStringsWithType?: EEnumWithStringsWithType;
    }): Promise<void> {
        // Validate required parameters

        return __request<void>(EnumsOptions.callWithEnums(requestBody), OpenAPI);
    }
}
"
`;

exports[`v3 should generate: ./test/generated/v3/services/HeaderService.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
import { request as __request } from './../core/request';
import type { ApiRequestOptions } from './../core/ApiRequestOptions';
import { OpenAPI } from './../core/OpenAPI';
import { RequiredError } from './../core/errors';

const callWithResultFromHeader = (): ApiRequestOptions => ({
    method: 'POST',
    path: \`/api/v{api-version}/header\`,
    responseHeader: 'operation-location',
    errors: {
        400: \`400 server error\`,
        500: \`500 server error\`,
    },
});

export type THeaderOptions = {
    callWithResultFromHeader: () => ApiRequestOptions;
};

export const HeaderOptions: THeaderOptions = {
    callWithResultFromHeader: callWithResultFromHeader,
};

export class HeaderService {
    /**
     * @returns string Successful response
     * @throws ApiError
     */
    public static callWithResultFromHeader(): Promise<string> {
        // Validate required parameters

        return __request<string>(HeaderOptions.callWithResultFromHeader(), OpenAPI);
    }
}
"
`;

exports[`v3 should generate: ./test/generated/v3/services/MultipartService.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
import type { IModelWithString } from './../models/./ModelWithString';
import { request as __request } from './../core/request';
import type { ApiRequestOptions } from './../core/ApiRequestOptions';
import { OpenAPI } from './../core/OpenAPI';
import { RequiredError } from './../core/errors';

const multipartResponse = (): ApiRequestOptions => ({
    method: 'GET',
    path: \`/api/v{api-version}/multipart\`,
});

const multipartRequest = (formData?: { content?: string; data?: IModelWithString | null }): ApiRequestOptions => ({
    method: 'POST',
    path: \`/api/v{api-version}/multipart\`,
    body: formData,
    mediaType: 'multipart/form-data',
});

export type TMultipartOptions = {
    multipartResponse: () => ApiRequestOptions;
    multipartRequest: (formData?: { content?: string; data?: IModelWithString | null }) => ApiRequestOptions;
};

export const MultipartOptions: TMultipartOptions = {
    multipartResponse: multipartResponse,
    multipartRequest: multipartRequest,
};

export class MultipartService {
    /**
     * @returns any OK
     * @throws ApiError
     */
    public static multipartResponse(): Promise<{
        file?: string;
        metadata?: {
            foo?: string;
            bar?: string;
        };
    }> {
        // Validate required parameters

        return __request<{
            file?: string;
            metadata?: {
                foo?: string;
                bar?: string;
            };
        }>(MultipartOptions.multipartResponse(), OpenAPI);
    }
    /**
     * @param formData
     * @throws ApiError
     */
    public static multipartRequest(formData?: { content?: string; data?: IModelWithString | null }): Promise<void> {
        // Validate required parameters

        return __request<void>(MultipartOptions.multipartRequest(formData), OpenAPI);
    }
}
"
`;

exports[`v3 should generate: ./test/generated/v3/services/NoContentService.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
import { request as __request } from './../core/request';
import type { ApiRequestOptions } from './../core/ApiRequestOptions';
import { OpenAPI } from './../core/OpenAPI';
import { RequiredError } from './../core/errors';

const callWithNoContentResponse = (): ApiRequestOptions => ({
    method: 'GET',
    path: \`/api/v{api-version}/no-content\`,
});

export type TNoContentOptions = {
    callWithNoContentResponse: () => ApiRequestOptions;
};

export const NoContentOptions: TNoContentOptions = {
    callWithNoContentResponse: callWithNoContentResponse,
};

export class NoContentService {
    /**
     * @returns void
     * @throws ApiError
     */
    public static callWithNoContentResponse(): Promise<void> {
        // Validate required parameters

        return __request<void>(NoContentOptions.callWithNoContentResponse(), OpenAPI);
    }
}
"
`;

exports[`v3 should generate: ./test/generated/v3/services/ParametersService.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
import type { IModelWithString } from './../models/./ModelWithString';
import { request as __request } from './../core/request';
import type { ApiRequestOptions } from './../core/ApiRequestOptions';
import { OpenAPI } from './../core/OpenAPI';
import { RequiredError } from './../core/errors';

const callWithParameters = (
    parameterHeader?: string | null,
    parameterQuery?: string | null,
    parameterForm?: string | null,
    parameterCookie?: string | null,
    parameterPath?: string | null,
    requestBody?: IModelWithString | null,
): ApiRequestOptions => ({
    method: 'GET',
    path: \`/api/v{api-version}/parameters/\${parameterPath}\`,
    cookies: {
        parameterCookie: parameterCookie,
    },
    headers: {
        parameterHeader: parameterHeader,
    },
    query: {
        parameterQuery: parameterQuery,
    },
    formData: {
        parameterForm: parameterForm,
    },
    body: requestBody,
    mediaType: 'application/json',
});

const callWithWeirdParameterNames = (
    parameterPath1?: string,
    parameterPath2?: string,
    parameterPath3?: string,
    _default?: string,
    parameterHeader?: string | null,
    parameterQuery?: string | null,
    parameterForm?: string | null,
    parameterCookie?: string | null,
    requestBody?: IModelWithString | null,
): ApiRequestOptions => ({
    method: 'GET',
    path: \`/api/v{api-version}/parameters/\${parameterPath1}/\${parameterPath2}/\${parameterPath3}\`,
    cookies: {
        'PARAMETER-COOKIE': parameterCookie,
    },
    headers: {
        'parameter.header': parameterHeader,
    },
    query: {
        default: _default,
        'parameter-query': parameterQuery,
    },
    formData: {
        parameter_form: parameterForm,
    },
    body: requestBody,
    mediaType: 'application/json',
});

const getCallWithOptionalParam = (parameter?: string, requestBody?: IModelWithString): ApiRequestOptions => ({
    method: 'GET',
    path: \`/api/v{api-version}/parameters/\`,
    query: {
        parameter: parameter,
    },
    body: requestBody,
    mediaType: 'application/json',
});

const postCallWithOptionalParam = (parameter?: string, requestBody?: IModelWithString): ApiRequestOptions => ({
    method: 'POST',
    path: \`/api/v{api-version}/parameters/\`,
    query: {
        parameter: parameter,
    },
    body: requestBody,
    mediaType: 'application/json',
});

export type TParametersOptions = {
    callWithParameters: (
        parameterHeader?: string | null,
        parameterQuery?: string | null,
        parameterForm?: string | null,
        parameterCookie?: string | null,
        parameterPath?: string | null,
        requestBody?: IModelWithString | null,
    ) => ApiRequestOptions;
    callWithWeirdParameterNames: (
        parameterPath1?: string,
        parameterPath2?: string,
        parameterPath3?: string,
        _default?: string,
        parameterHeader?: string | null,
        parameterQuery?: string | null,
        parameterForm?: string | null,
        parameterCookie?: string | null,
        requestBody?: IModelWithString | null,
    ) => ApiRequestOptions;
    getCallWithOptionalParam: (parameter?: string, requestBody?: IModelWithString) => ApiRequestOptions;
    postCallWithOptionalParam: (parameter?: string, requestBody?: IModelWithString) => ApiRequestOptions;
};

export const ParametersOptions: TParametersOptions = {
    callWithParameters: callWithParameters,
    callWithWeirdParameterNames: callWithWeirdParameterNames,
    getCallWithOptionalParam: getCallWithOptionalParam,
    postCallWithOptionalParam: postCallWithOptionalParam,
};

export class ParametersService {
    /**
     * @param parameterHeader This is the parameter that goes into the header
     * @param parameterQuery This is the parameter that goes into the query params
     * @param parameterForm This is the parameter that goes into the form data
     * @param parameterCookie This is the parameter that goes into the cookie
     * @param parameterPath This is the parameter that goes into the path
     * @param requestBody This is the parameter that goes into the body
     * @throws ApiError
     */
    public static callWithParameters(
        parameterHeader?: string | null,
        parameterQuery?: string | null,
        parameterForm?: string | null,
        parameterCookie?: string | null,
        parameterPath?: string | null,
        requestBody?: IModelWithString | null,
    ): Promise<void> {
        // Validate required parameters
        if (parameterHeader === null || parameterHeader === undefined) {
            throw new RequiredError('parameterHeader', 'Required parameter parameterHeader was not specified');
        }
        if (parameterQuery === null || parameterQuery === undefined) {
            throw new RequiredError('parameterQuery', 'Required parameter parameterQuery was not specified');
        }
        if (parameterForm === null || parameterForm === undefined) {
            throw new RequiredError('parameterForm', 'Required parameter parameterForm was not specified');
        }
        if (parameterCookie === null || parameterCookie === undefined) {
            throw new RequiredError('parameterCookie', 'Required parameter parameterCookie was not specified');
        }
        if (parameterPath === null || parameterPath === undefined) {
            throw new RequiredError('parameterPath', 'Required parameter parameterPath was not specified');
        }
        if (requestBody === null || requestBody === undefined) {
            throw new RequiredError('requestBody', 'Required parameter requestBody was not specified');
        }

        return __request<void>(
            ParametersOptions.callWithParameters(
                parameterHeader,
                parameterQuery,
                parameterForm,
                parameterCookie,
                parameterPath,
                requestBody,
            ),
            OpenAPI,
        );
    }
    /**
     * @param parameterPath1 This is the parameter that goes into the path
     * @param parameterPath2 This is the parameter that goes into the path
     * @param parameterPath3 This is the parameter that goes into the path
     * @param _default This is the parameter with a reserved keyword
     * @param parameterHeader This is the parameter that goes into the request header
     * @param parameterQuery This is the parameter that goes into the request query params
     * @param parameterForm This is the parameter that goes into the request form data
     * @param parameterCookie This is the parameter that goes into the cookie
     * @param requestBody This is the parameter that goes into the body
     * @throws ApiError
     */
    public static callWithWeirdParameterNames(
        parameterPath1?: string,
        parameterPath2?: string,
        parameterPath3?: string,
        _default?: string,
        parameterHeader?: string | null,
        parameterQuery?: string | null,
        parameterForm?: string | null,
        parameterCookie?: string | null,
        requestBody?: IModelWithString | null,
    ): Promise<void> {
        // Validate required parameters
        if (parameterHeader === null || parameterHeader === undefined) {
            throw new RequiredError('parameterHeader', 'Required parameter parameterHeader was not specified');
        }
        if (parameterQuery === null || parameterQuery === undefined) {
            throw new RequiredError('parameterQuery', 'Required parameter parameterQuery was not specified');
        }
        if (parameterForm === null || parameterForm === undefined) {
            throw new RequiredError('parameterForm', 'Required parameter parameterForm was not specified');
        }
        if (parameterCookie === null || parameterCookie === undefined) {
            throw new RequiredError('parameterCookie', 'Required parameter parameterCookie was not specified');
        }
        if (requestBody === null || requestBody === undefined) {
            throw new RequiredError('requestBody', 'Required parameter requestBody was not specified');
        }

        return __request<void>(
            ParametersOptions.callWithWeirdParameterNames(
                parameterPath1,
                parameterPath2,
                parameterPath3,
                _default,
                parameterHeader,
                parameterQuery,
                parameterForm,
                parameterCookie,
                requestBody,
            ),
            OpenAPI,
        );
    }
    /**
     * @param parameter This is an optional parameter
     * @param requestBody This is a required parameter
     * @throws ApiError
     */
    public static getCallWithOptionalParam(parameter?: string, requestBody?: IModelWithString): Promise<void> {
        // Validate required parameters
        if (requestBody === null || requestBody === undefined) {
            throw new RequiredError('requestBody', 'Required parameter requestBody was not specified');
        }

        return __request<void>(ParametersOptions.getCallWithOptionalParam(parameter, requestBody), OpenAPI);
    }
    /**
     * @param parameter This is a required parameter
     * @param requestBody This is an optional parameter
     * @throws ApiError
     */
    public static postCallWithOptionalParam(parameter?: string, requestBody?: IModelWithString): Promise<void> {
        // Validate required parameters
        if (parameter === null || parameter === undefined) {
            throw new RequiredError('parameter', 'Required parameter parameter was not specified');
        }

        return __request<void>(ParametersOptions.postCallWithOptionalParam(parameter, requestBody), OpenAPI);
    }
}
"
`;

exports[`v3 should generate: ./test/generated/v3/services/RequestBodyService.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
import type { IModelWithString } from './../models/./ModelWithString';
import { request as __request } from './../core/request';
import type { ApiRequestOptions } from './../core/ApiRequestOptions';
import { OpenAPI } from './../core/OpenAPI';
import { RequiredError } from './../core/errors';

const postRequestBodyService = (requestBody?: IModelWithString): ApiRequestOptions => ({
    method: 'POST',
    path: \`/api/v{api-version}/requestBody/\`,
    body: requestBody,
    mediaType: 'application/json',
});

export type TRequestBodyOptions = {
    postRequestBodyService: (requestBody?: IModelWithString) => ApiRequestOptions;
};

export const RequestBodyOptions: TRequestBodyOptions = {
    postRequestBodyService: postRequestBodyService,
};

export class RequestBodyService {
    /**
     * @param requestBody A reusable request body
     * @throws ApiError
     */
    public static postRequestBodyService(requestBody?: IModelWithString): Promise<void> {
        // Validate required parameters

        return __request<void>(RequestBodyOptions.postRequestBodyService(requestBody), OpenAPI);
    }
}
"
`;

exports[`v3 should generate: ./test/generated/v3/services/ResponseService.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
import type { TModelThatExtendsExtends } from './../models/./ModelThatExtendsExtends';
import type { TModelThatExtends } from './../models/./ModelThatExtends';
import type { IModelWithString } from './../models/./ModelWithString';
import { request as __request } from './../core/request';
import type { ApiRequestOptions } from './../core/ApiRequestOptions';
import { OpenAPI } from './../core/OpenAPI';
import { RequiredError } from './../core/errors';

const callWithResponse = (): ApiRequestOptions => ({
    method: 'GET',
    path: \`/api/v{api-version}/response\`,
});

const callWithDuplicateResponses = (): ApiRequestOptions => ({
    method: 'POST',
    path: \`/api/v{api-version}/response\`,
    errors: {
        500: \`Message for 500 error\`,
        501: \`Message for 501 error\`,
        502: \`Message for 502 error\`,
    },
});

const callWithResponses = (): ApiRequestOptions => ({
    method: 'PUT',
    path: \`/api/v{api-version}/response\`,
    errors: {
        500: \`Message for 500 error\`,
        501: \`Message for 501 error\`,
        502: \`Message for 502 error\`,
    },
});

export type TResponseOptions = {
    callWithResponse: () => ApiRequestOptions;
    callWithDuplicateResponses: () => ApiRequestOptions;
    callWithResponses: () => ApiRequestOptions;
};

export const ResponseOptions: TResponseOptions = {
    callWithResponse: callWithResponse,
    callWithDuplicateResponses: callWithDuplicateResponses,
    callWithResponses: callWithResponses,
};

export class ResponseService {
    /**
     * @returns IModelWithString
     * @throws ApiError
     */
    public static callWithResponse(): Promise<IModelWithString> {
        // Validate required parameters

        return __request<IModelWithString>(ResponseOptions.callWithResponse(), OpenAPI);
    }
    /**
     * @returns IModelWithString Message for default response
     * @throws ApiError
     */
    public static callWithDuplicateResponses(): Promise<IModelWithString> {
        // Validate required parameters

        return __request<IModelWithString>(ResponseOptions.callWithDuplicateResponses(), OpenAPI);
    }
    /**
     * @returns any Message for 200 response
     * @returns IModelWithString Message for default response
     * @returns TModelThatExtends Message for 201 response
     * @returns TModelThatExtendsExtends Message for 202 response
     * @throws ApiError
     */
    public static callWithResponses(): Promise<
        | {
              readonly '@namespace.string'?: string;
              readonly '@namespace.integer'?: number;
              readonly value?: Array<IModelWithString>;
          }
        | IModelWithString
        | TModelThatExtends
        | TModelThatExtendsExtends
    > {
        // Validate required parameters

        return __request<
            | {
                  readonly '@namespace.string'?: string;
                  readonly '@namespace.integer'?: number;
                  readonly value?: Array<IModelWithString>;
              }
            | IModelWithString
            | TModelThatExtends
            | TModelThatExtendsExtends
        >(ResponseOptions.callWithResponses(), OpenAPI);
    }
}
"
`;

exports[`v3 should generate: ./test/generated/v3/services/SimpleService.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
import { request as __request } from './../core/request';
import type { ApiRequestOptions } from './../core/ApiRequestOptions';
import { OpenAPI } from './../core/OpenAPI';
import { RequiredError } from './../core/errors';

const getCallWithoutParametersAndResponse = (): ApiRequestOptions => ({
    method: 'GET',
    path: \`/api/v{api-version}/simple\`,
});

const putCallWithoutParametersAndResponse = (): ApiRequestOptions => ({
    method: 'PUT',
    path: \`/api/v{api-version}/simple\`,
});

const postCallWithoutParametersAndResponse = (): ApiRequestOptions => ({
    method: 'POST',
    path: \`/api/v{api-version}/simple\`,
});

const deleteCallWithoutParametersAndResponse = (): ApiRequestOptions => ({
    method: 'DELETE',
    path: \`/api/v{api-version}/simple\`,
});

const optionsCallWithoutParametersAndResponse = (): ApiRequestOptions => ({
    method: 'OPTIONS',
    path: \`/api/v{api-version}/simple\`,
});

const headCallWithoutParametersAndResponse = (): ApiRequestOptions => ({
    method: 'HEAD',
    path: \`/api/v{api-version}/simple\`,
});

const patchCallWithoutParametersAndResponse = (): ApiRequestOptions => ({
    method: 'PATCH',
    path: \`/api/v{api-version}/simple\`,
});

export type TSimpleOptions = {
    getCallWithoutParametersAndResponse: () => ApiRequestOptions;
    putCallWithoutParametersAndResponse: () => ApiRequestOptions;
    postCallWithoutParametersAndResponse: () => ApiRequestOptions;
    deleteCallWithoutParametersAndResponse: () => ApiRequestOptions;
    optionsCallWithoutParametersAndResponse: () => ApiRequestOptions;
    headCallWithoutParametersAndResponse: () => ApiRequestOptions;
    patchCallWithoutParametersAndResponse: () => ApiRequestOptions;
};

export const SimpleOptions: TSimpleOptions = {
    getCallWithoutParametersAndResponse: getCallWithoutParametersAndResponse,
    putCallWithoutParametersAndResponse: putCallWithoutParametersAndResponse,
    postCallWithoutParametersAndResponse: postCallWithoutParametersAndResponse,
    deleteCallWithoutParametersAndResponse: deleteCallWithoutParametersAndResponse,
    optionsCallWithoutParametersAndResponse: optionsCallWithoutParametersAndResponse,
    headCallWithoutParametersAndResponse: headCallWithoutParametersAndResponse,
    patchCallWithoutParametersAndResponse: patchCallWithoutParametersAndResponse,
};

export class SimpleService {
    /**
     * @throws ApiError
     */
    public static getCallWithoutParametersAndResponse(): Promise<void> {
        // Validate required parameters

        return __request<void>(SimpleOptions.getCallWithoutParametersAndResponse(), OpenAPI);
    }
    /**
     * @throws ApiError
     */
    public static putCallWithoutParametersAndResponse(): Promise<void> {
        // Validate required parameters

        return __request<void>(SimpleOptions.putCallWithoutParametersAndResponse(), OpenAPI);
    }
    /**
     * @throws ApiError
     */
    public static postCallWithoutParametersAndResponse(): Promise<void> {
        // Validate required parameters

        return __request<void>(SimpleOptions.postCallWithoutParametersAndResponse(), OpenAPI);
    }
    /**
     * @throws ApiError
     */
    public static deleteCallWithoutParametersAndResponse(): Promise<void> {
        // Validate required parameters

        return __request<void>(SimpleOptions.deleteCallWithoutParametersAndResponse(), OpenAPI);
    }
    /**
     * @throws ApiError
     */
    public static optionsCallWithoutParametersAndResponse(): Promise<void> {
        // Validate required parameters

        return __request<void>(SimpleOptions.optionsCallWithoutParametersAndResponse(), OpenAPI);
    }
    /**
     * @throws ApiError
     */
    public static headCallWithoutParametersAndResponse(): Promise<void> {
        // Validate required parameters

        return __request<void>(SimpleOptions.headCallWithoutParametersAndResponse(), OpenAPI);
    }
    /**
     * @throws ApiError
     */
    public static patchCallWithoutParametersAndResponse(): Promise<void> {
        // Validate required parameters

        return __request<void>(SimpleOptions.patchCallWithoutParametersAndResponse(), OpenAPI);
    }
}
"
`;

exports[`v3 should generate: ./test/generated/v3/services/TypesService.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
import { request as __request } from './../core/request';
import type { ApiRequestOptions } from './../core/ApiRequestOptions';
import { OpenAPI } from './../core/OpenAPI';
import { RequiredError } from './../core/errors';

const types = (
    parameterNumber?: number = 123,
    parameterString?: string | null = "'default'",
    parameterBoolean?: boolean | null = 'true',
    parameterObject?: any = 'null',
    parameterArray?: Array<string> | null,
    parameterDictionary?: any,
    parameterEnum?: 'Success' | 'Warning' | 'Error' | null,
    id?: number,
): ApiRequestOptions => ({
    method: 'GET',
    path: \`/api/v{api-version}/types\`,
    query: {
        parameterNumber: parameterNumber,
        parameterString: parameterString,
        parameterBoolean: parameterBoolean,
        parameterObject: parameterObject,
        parameterArray: parameterArray,
        parameterDictionary: parameterDictionary,
        parameterEnum: parameterEnum,
    },
});

export type TTypesOptions = {
    types: (
        parameterNumber?: number,
        parameterString?: string | null,
        parameterBoolean?: boolean | null,
        parameterObject?: any,
        parameterArray?: Array<string> | null,
        parameterDictionary?: any,
        parameterEnum?: 'Success' | 'Warning' | 'Error' | null,
        id?: number,
    ) => ApiRequestOptions;
};

export const TypesOptions: TTypesOptions = {
    types: types,
};

export class TypesService {
    /**
     * @param parameterNumber This is a number parameter
     * @param parameterString This is a string parameter
     * @param parameterBoolean This is a boolean parameter
     * @param parameterObject This is an object parameter
     * @param parameterArray This is an array parameter
     * @param parameterDictionary This is a dictionary parameter
     * @param parameterEnum This is an enum parameter
     * @param id This is a number parameter
     * @returns number Response is a simple number
     * @returns string Response is a simple string
     * @returns boolean Response is a simple boolean
     * @returns any Response is a simple object
     * @throws ApiError
     */
    public static types(
        parameterNumber?: number = 123,
        parameterString?: string | null = "'default'",
        parameterBoolean?: boolean | null = 'true',
        parameterObject?: any = 'null',
        parameterArray?: Array<string> | null,
        parameterDictionary?: any,
        parameterEnum?: 'Success' | 'Warning' | 'Error' | null,
        id?: number,
    ): Promise<number | string | boolean | any> {
        // Validate required parameters
        if (parameterNumber === null || parameterNumber === undefined) {
            throw new RequiredError('parameterNumber', 'Required parameter parameterNumber was not specified');
        }
        if (parameterString === null || parameterString === undefined) {
            throw new RequiredError('parameterString', 'Required parameter parameterString was not specified');
        }
        if (parameterBoolean === null || parameterBoolean === undefined) {
            throw new RequiredError('parameterBoolean', 'Required parameter parameterBoolean was not specified');
        }
        if (parameterObject === null || parameterObject === undefined) {
            throw new RequiredError('parameterObject', 'Required parameter parameterObject was not specified');
        }
        if (parameterArray === null || parameterArray === undefined) {
            throw new RequiredError('parameterArray', 'Required parameter parameterArray was not specified');
        }
        if (parameterDictionary === null || parameterDictionary === undefined) {
            throw new RequiredError('parameterDictionary', 'Required parameter parameterDictionary was not specified');
        }
        if (parameterEnum === null || parameterEnum === undefined) {
            throw new RequiredError('parameterEnum', 'Required parameter parameterEnum was not specified');
        }

        return __request<number | string | boolean | any>(
            TypesOptions.types(
                parameterNumber,
                parameterString,
                parameterBoolean,
                parameterObject,
                parameterArray,
                parameterDictionary,
                parameterEnum,
                id,
            ),
            OpenAPI,
        );
    }
}
"
`;

exports[`v3 should generate: ./test/generated/v3/services/UploadService.ts 1`] = `
"/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
import { request as __request } from './../core/request';
import type { ApiRequestOptions } from './../core/ApiRequestOptions';
import { OpenAPI } from './../core/OpenAPI';
import { RequiredError } from './../core/errors';

const uploadFile = (file?: Blob): ApiRequestOptions => ({
    method: 'POST',
    path: \`/api/v{api-version}/upload\`,
    formData: {
        file: file,
    },
});

export type TUploadOptions = {
    uploadFile: (file?: Blob) => ApiRequestOptions;
};

export const UploadOptions: TUploadOptions = {
    uploadFile: uploadFile,
};

export class UploadService {
    /**
     * @param file Supply a file reference for upload
     * @returns boolean
     * @throws ApiError
     */
    public static uploadFile(file?: Blob): Promise<boolean> {
        // Validate required parameters
        if (file === null || file === undefined) {
            throw new RequiredError('file', 'Required parameter file was not specified');
        }

        return __request<boolean>(UploadOptions.uploadFile(file), OpenAPI);
    }
}
"
`;
