{{>header}}

import type { RequestExecutor, RequestConfig } from './request-executor';
{{#unless @root.useCustomRequest}}
import type { ApiRequestOptions } from './ApiRequestOptions';
import type { TOpenAPIConfig } from './OpenAPI';
import { OpenAPI } from './OpenAPI';
{{/unless}}
import { request as __request } from './request';

export function createExecutorAdapter<TRequestOptions extends Record<string, any>>(
{{#unless @root.useCustomRequest}}
    openApiConfig: TOpenAPIConfig = OpenAPI,
    mapOptions?: (options: TRequestOptions | undefined) => Partial<ApiRequestOptions>,
{{/unless}}
): RequestExecutor<TRequestOptions> {
    return {
        {{#if @root.useCustomRequest}}
        request<TResponse>(config: RequestConfig, options?: TRequestOptions): Promise<TResponse> {
            return __request(config, options) as Promise<TResponse>;
        },
        {{else}}
        request<TResponse>(config: RequestConfig, options?: TRequestOptions): Promise<TResponse> {
            const baseOptions: ApiRequestOptions = {
                method: config.method as ApiRequestOptions['method'],
                path: config.path,
                headers: config.headers,
                query: config.query,
                body: config.body,
            };

            const mergedOptions: ApiRequestOptions = {
                ...baseOptions,
                ...(mapOptions ? mapOptions(options) : {}),
            };

            return __request<TResponse>(mergedOptions, openApiConfig);
        },
        {{/if}}
    };
}
