{{>header}}

import type { RequestExecutor, RequestConfig } from './request-executor';
{{#if useCancelableRequest}}
import type { CancelablePromise } from './CancelablePromise';
{{/if}}

/**
 * Определите свой тип опций (опционально)
 * Измените этот интерфейс в соответствии с вашими потребностями
 */
interface MyCustomOptions {
    timeout?: number;
    retries?: number;
}

/**
 * Создайте пользовательский executor
 * Реализуйте свою логику запросов здесь
 *
 * @example Пример использования:
 * 
 * import { createLegacyExecutor } from './generated/core/legacy-request-adapter';
 * import { SimpleService } from './generated/services/SimpleService';
 *
 * const executorWithOptions = createLegacyExecutor<MyCustomOptions>(OpenAPI, (options) => {
 *  // Мапьте ваши пользовательские опции в ApiRequestOptions при необходимости
 *  return {
 *      // Добавьте любые поля ApiRequestOptions на основе options
 *  };
 * });
 * 
 * const simpleService = new SimpleService(executorWithOptions);
 * await simpleService.getCallWithoutParametersAndResponse();
 */
{{#if useCancelableRequest}}
export function request<T>(options: ApiRequestOptions, config: TOpenAPIConfig): CancelablePromise<T> {
    return new CancelablePromise(async (resolve, reject, onCancel) => {
        try {
            const abortController = new AbortController();
            
            if (options?.timeout) {
                const timeoutId = setTimeout(() => abortController.abort(), options.timeout);
                onCancel(() => clearTimeout(timeoutId));
            }
            
            onCancel(() => abortController.abort());
            
            if (onCancel.isCancelled) {
                return;
            }
            
            // Ваша пользовательская логика запросов здесь
            const response = await fetch(config.url, {
                method: config.method,
                headers: config.headers,
                body: config.body ? JSON.stringify(config.body) : undefined,
                signal: abortController.signal,
            });
            
            if (!response.ok) {
                throw new Error(`Request failed: ${response.statusText}`);
            }
            
            const data = await response.json();
            resolve(data);
        } catch (error) {
            reject(error);
        }
    });
};
{{else}}
export async function request<T>(options: ApiRequestOptions, config: TOpenAPIConfig): Promise<T> {
    return new Promise(async (resolve, reject) => {
        try {
            const url = getUrl(options, config);
            const response = await sendRequest(options, url, config);
            const responseBody = getResponseBody(response);
            const responseHeader = getResponseHeader(response, options.responseHeader);

            const result: ApiResult = {
                url,
                ok: isSuccess(response.status),
                status: response.status,
                statusText: response.statusText,
                body: responseHeader || responseBody,
            };

            catchErrors(options, result);
            resolve(result.body);
        } catch (error) {
            reject(error);
        }
    });
}
{{/if}}
